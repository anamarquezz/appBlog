{"ast":null,"code":"'use strict';\n\nmodule.exports = npa;\nmodule.exports.resolve = resolve;\nmodule.exports.Result = Result;\n\nconst url = require('url');\n\nconst HostedGit = require('hosted-git-info');\n\nconst semver = require('semver');\n\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path');\n\nconst validatePackageName = require('validate-npm-package-name');\n\nconst {\n  homedir\n} = require('os');\n\nconst log = require('proc-log');\n\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS;\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/;\nconst isURL = /^(?:git[+])?[a-z]+:/i;\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i;\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i;\n\nfunction npa(arg, where) {\n  let name;\n  let spec;\n\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg;\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where);\n    } else {\n      return npa(arg.raw, where || arg.where);\n    }\n  }\n\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@');\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;\n\n  if (isURL.test(arg)) {\n    spec = arg;\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`;\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg;\n  } else if (nameEndsAt > 0) {\n    name = namePart;\n    spec = arg.slice(nameEndsAt + 1);\n  } else {\n    const valid = validatePackageName(arg);\n\n    if (valid.validForOldPackages) {\n      name = arg;\n    } else {\n      spec = arg;\n    }\n  }\n\n  return resolve(name, spec, where, arg);\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;\n\nfunction resolve(name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null\n  });\n\n  if (name) {\n    res.setName(name);\n  }\n\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where);\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where);\n  }\n\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true\n  });\n\n  if (hosted) {\n    return fromHostedGit(res, hosted);\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res);\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where);\n  } else {\n    return fromRegistry(res);\n  }\n}\n\nfunction invalidPackageName(name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`);\n  err.code = 'EINVALIDPACKAGENAME';\n  return err;\n}\n\nfunction invalidTagName(name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`);\n  err.code = 'EINVALIDTAGNAME';\n  return err;\n}\n\nfunction Result(opts) {\n  this.type = opts.type;\n  this.registry = opts.registry;\n  this.where = opts.where;\n\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec;\n  } else {\n    this.raw = opts.raw;\n  }\n\n  this.name = undefined;\n  this.escapedName = undefined;\n  this.scope = undefined;\n  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec;\n  this.saveSpec = opts.saveSpec;\n  this.fetchSpec = opts.fetchSpec;\n\n  if (opts.name) {\n    this.setName(opts.name);\n  }\n\n  this.gitRange = opts.gitRange;\n  this.gitCommittish = opts.gitCommittish;\n  this.gitSubdir = opts.gitSubdir;\n  this.hosted = opts.hosted;\n}\n\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name);\n\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid, this.raw);\n  }\n\n  this.name = name;\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined; // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n\n  this.escapedName = name.replace('/', '%2f');\n  return this;\n};\n\nResult.prototype.toString = function () {\n  const full = [];\n\n  if (this.name != null && this.name !== '') {\n    full.push(this.name);\n  }\n\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec;\n\n  if (spec != null && spec !== '') {\n    full.push(spec);\n  }\n\n  return full.length ? full.join('@') : this.raw;\n};\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this);\n  delete result.hosted;\n  return result;\n};\n\nfunction setGitCommittish(res, committish) {\n  if (!committish) {\n    res.gitCommittish = null;\n    return res;\n  } // for each :: separated item:\n\n\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish');\n      }\n\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish');\n      }\n\n      res.gitCommittish = part;\n      continue;\n    } // split on name:value\n\n\n    const [name, value] = part.split(':'); // if name is semver do semver lookup of ref or tag\n\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range');\n      }\n\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range');\n      }\n\n      res.gitRange = decodeURIComponent(value);\n      continue;\n    }\n\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path');\n      }\n\n      res.gitSubdir = `/${value}`;\n      continue;\n    }\n\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`);\n  }\n\n  return res;\n}\n\nfunction fromFile(res, where) {\n  if (!where) {\n    where = process.cwd();\n  }\n\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory';\n  res.where = where; // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/bar/foo\n\n  let specUrl;\n  let resolvedUrl;\n  const prefix = !/^file:/.test(res.rawSpec) ? 'file:' : '';\n  const rawWithPrefix = prefix + res.rawSpec;\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '');\n\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`);\n    specUrl = new url.URL(rawWithPrefix);\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909');\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError\n    });\n  } // environment switch for testing\n\n\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    } // turn file:/../foo into file:../foo\n\n\n    if (/^\\/\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\//, 'file:');\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`);\n      specUrl = new url.URL(rawSpec);\n      rawNoPrefix = rawSpec.replace(/^file:/, '');\n    } // XXX end 8909 violation backwards compatibility section\n\n  } // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n\n\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`;\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl\n    });\n  } // turn /C:/blah into just C:/blah on windows\n\n\n  let specPath = decodeURIComponent(specUrl.pathname);\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname);\n\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1');\n  } // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n\n\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`;\n    resolvedPath = path.resolve(homedir(), specPath.substr(3));\n  } else if (!path.isAbsolute(rawNoPrefix)) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`;\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`;\n  }\n\n  res.fetchSpec = path.resolve(where, resolvedPath);\n  return res;\n}\n\nfunction fromHostedGit(res, hosted) {\n  res.type = 'git';\n  res.hosted = hosted;\n  res.saveSpec = hosted.toString({\n    noGitPlus: false,\n    noCommittish: false\n  });\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();\n  return setGitCommittish(res, hosted.committish);\n}\n\nfunction unsupportedURLType(protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`);\n  err.code = 'EUNSUPPORTEDPROTOCOL';\n  return err;\n}\n\nfunction matchGitScp(spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i);\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2]\n  };\n}\n\nfunction fromURL(res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec);\n  res.saveSpec = res.rawSpec; // check the protocol, and then see if it's git or not\n\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:':\n      {\n        res.type = 'git';\n        const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec) : null;\n\n        if (match) {\n          setGitCommittish(res, match.gitCommittish);\n          res.fetchSpec = match.fetchSpec;\n        } else {\n          setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '');\n          urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '');\n\n          if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n            // keep the drive letter : on windows file paths\n            urlparse.host += ':';\n            urlparse.hostname += ':';\n          }\n\n          delete urlparse.hash;\n          res.fetchSpec = url.format(urlparse);\n        }\n\n        break;\n      }\n\n    case 'http:':\n    case 'https:':\n      res.type = 'remote';\n      res.fetchSpec = res.saveSpec;\n      break;\n\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec);\n  }\n\n  return res;\n}\n\nfunction fromAlias(res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where);\n\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported');\n  }\n\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps');\n  }\n\n  res.subSpec = subSpec;\n  res.registry = true;\n  res.type = 'alias';\n  res.saveSpec = null;\n  res.fetchSpec = null;\n  return res;\n}\n\nfunction fromRegistry(res) {\n  res.registry = true;\n  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec.trim(); // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n\n  res.saveSpec = null;\n  res.fetchSpec = spec;\n  const version = semver.valid(spec, true);\n  const range = semver.validRange(spec, true);\n\n  if (version) {\n    res.type = 'version';\n  } else if (range) {\n    res.type = 'range';\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw);\n    }\n\n    res.type = 'tag';\n  }\n\n  return res;\n}","map":{"version":3,"names":["module","exports","npa","resolve","Result","url","require","HostedGit","semver","path","global","FAKE_WINDOWS","win32","validatePackageName","homedir","log","isWindows","process","platform","hasSlashes","isURL","isGit","isFilename","arg","where","name","spec","rawSpec","raw","nameEndsAt","slice","indexOf","namePart","test","valid","validForOldPackages","isFilespec","res","fromArgument","setName","fromFile","fromAlias","hosted","fromUrl","noGitPlus","noCommittish","fromHostedGit","fromURL","fromRegistry","invalidPackageName","err","Error","errors","join","code","invalidTagName","opts","type","registry","undefined","escapedName","scope","saveSpec","fetchSpec","gitRange","gitCommittish","gitSubdir","prototype","replace","toString","full","push","length","toJSON","result","Object","assign","setGitCommittish","committish","part","split","includes","value","decodeURIComponent","warn","cwd","specUrl","resolvedUrl","prefix","rawWithPrefix","rawNoPrefix","URL","originalError","er","env","NPM_PACKAGE_ARG_8909_STRICT","host","msg","parsed","specPath","pathname","resolvedPath","substr","isAbsolute","relative","getDefaultRepresentation","unsupportedURLType","protocol","matchGitScp","matched","match","urlparse","parse","hash","hostname","format","subSpec","trim","version","range","validRange","encodeURIComponent"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/npm-package-arg/lib/npa.js"],"sourcesContent":["'use strict'\nmodule.exports = npa\nmodule.exports.resolve = resolve\nmodule.exports.Result = Result\n\nconst url = require('url')\nconst HostedGit = require('hosted-git-info')\nconst semver = require('semver')\nconst path = global.FAKE_WINDOWS ? require('path').win32 : require('path')\nconst validatePackageName = require('validate-npm-package-name')\nconst { homedir } = require('os')\nconst log = require('proc-log')\n\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/\nconst isURL = /^(?:git[+])?[a-z]+:/i\nconst isGit = /^[^@]+@[^:.]+\\.[^:]+:.+$/i\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i\n\nfunction npa (arg, where) {\n  let name\n  let spec\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)\n    } else {\n      return npa(arg.raw, where || arg.where)\n    }\n  }\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@')\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg\n  if (isURL.test(arg)) {\n    spec = arg\n  } else if (isGit.test(arg)) {\n    spec = `git+ssh://${arg}`\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg\n  } else if (nameEndsAt > 0) {\n    name = namePart\n    spec = arg.slice(nameEndsAt + 1)\n  } else {\n    const valid = validatePackageName(arg)\n    if (valid.validForOldPackages) {\n      name = arg\n    } else {\n      spec = arg\n    }\n  }\n  return resolve(name, spec, where, arg)\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/\n\nfunction resolve (name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null,\n  })\n\n  if (name) {\n    res.setName(name)\n  }\n\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where)\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where)\n  }\n\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true,\n  })\n  if (hosted) {\n    return fromHostedGit(res, hosted)\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res)\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where)\n  } else {\n    return fromRegistry(res)\n  }\n}\n\nfunction invalidPackageName (name, valid, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid package name \"${name}\" of package \"${raw}\": ${valid.errors.join('; ')}.`)\n  err.code = 'EINVALIDPACKAGENAME'\n  return err\n}\n\nfunction invalidTagName (name, raw) {\n  // eslint-disable-next-line max-len\n  const err = new Error(`Invalid tag name \"${name}\" of package \"${raw}\": Tags may not have any characters that encodeURIComponent encodes.`)\n  err.code = 'EINVALIDTAGNAME'\n  return err\n}\n\nfunction Result (opts) {\n  this.type = opts.type\n  this.registry = opts.registry\n  this.where = opts.where\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec\n  } else {\n    this.raw = opts.raw\n  }\n\n  this.name = undefined\n  this.escapedName = undefined\n  this.scope = undefined\n  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec\n  this.saveSpec = opts.saveSpec\n  this.fetchSpec = opts.fetchSpec\n  if (opts.name) {\n    this.setName(opts.name)\n  }\n  this.gitRange = opts.gitRange\n  this.gitCommittish = opts.gitCommittish\n  this.gitSubdir = opts.gitSubdir\n  this.hosted = opts.hosted\n}\n\nResult.prototype.setName = function (name) {\n  const valid = validatePackageName(name)\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid, this.raw)\n  }\n\n  this.name = name\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined\n  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n  this.escapedName = name.replace('/', '%2f')\n  return this\n}\n\nResult.prototype.toString = function () {\n  const full = []\n  if (this.name != null && this.name !== '') {\n    full.push(this.name)\n  }\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec\n  if (spec != null && spec !== '') {\n    full.push(spec)\n  }\n  return full.length ? full.join('@') : this.raw\n}\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this)\n  delete result.hosted\n  return result\n}\n\nfunction setGitCommittish (res, committish) {\n  if (!committish) {\n    res.gitCommittish = null\n    return res\n  }\n\n  // for each :: separated item:\n  for (const part of committish.split('::')) {\n    // if the item has no : the n it is a commit-ish\n    if (!part.includes(':')) {\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a committish')\n      }\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a second committish')\n      }\n      res.gitCommittish = part\n      continue\n    }\n    // split on name:value\n    const [name, value] = part.split(':')\n    // if name is semver do semver lookup of ref or tag\n    if (name === 'semver') {\n      if (res.gitCommittish) {\n        throw new Error('cannot override existing committish with a semver range')\n      }\n      if (res.gitRange) {\n        throw new Error('cannot override existing semver range with a second semver range')\n      }\n      res.gitRange = decodeURIComponent(value)\n      continue\n    }\n    if (name === 'path') {\n      if (res.gitSubdir) {\n        throw new Error('cannot override existing path with a second path')\n      }\n      res.gitSubdir = `/${value}`\n      continue\n    }\n    log.warn('npm-package-arg', `ignoring unknown key \"${name}\"`)\n  }\n\n  return res\n}\n\nfunction fromFile (res, where) {\n  if (!where) {\n    where = process.cwd()\n  }\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory'\n  res.where = where\n\n  // always put the '/' on where when resolving urls, or else\n  // file:foo from /path/to/bar goes to /path/to/foo, when we want\n  // it to be /path/to/bar/foo\n\n  let specUrl\n  let resolvedUrl\n  const prefix = (!/^file:/.test(res.rawSpec) ? 'file:' : '')\n  const rawWithPrefix = prefix + res.rawSpec\n  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '')\n  try {\n    resolvedUrl = new url.URL(rawWithPrefix, `file://${path.resolve(where)}/`)\n    specUrl = new url.URL(rawWithPrefix)\n  } catch (originalError) {\n    const er = new Error('Invalid file: URL, must comply with RFC 8909')\n    throw Object.assign(er, {\n      raw: res.rawSpec,\n      spec: res,\n      where,\n      originalError,\n    })\n  }\n\n  // environment switch for testing\n  if (process.env.NPM_PACKAGE_ARG_8909_STRICT !== '1') {\n    // XXX backwards compatibility lack of compliance with 8909\n    // Remove when we want a breaking change to come into RFC compliance.\n    if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n      const rawSpec = res.rawSpec.replace(/^file:\\/\\//, 'file:///')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // turn file:/../foo into file:../foo\n    if (/^\\/\\.\\.?(\\/|$)/.test(rawNoPrefix)) {\n      const rawSpec = res.rawSpec.replace(/^file:\\//, 'file:')\n      resolvedUrl = new url.URL(rawSpec, `file://${path.resolve(where)}/`)\n      specUrl = new url.URL(rawSpec)\n      rawNoPrefix = rawSpec.replace(/^file:/, '')\n    }\n    // XXX end 8909 violation backwards compatibility section\n  }\n\n  // file:foo - relative url to ./foo\n  // file:/foo - absolute path /foo\n  // file:///foo - absolute path to /foo, no authority host\n  // file://localhost/foo - absolute path to /foo, on localhost\n  // file://foo - absolute path to / on foo host (error!)\n  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {\n    const msg = `Invalid file: URL, must be absolute if // present`\n    throw Object.assign(new Error(msg), {\n      raw: res.rawSpec,\n      parsed: resolvedUrl,\n    })\n  }\n\n  // turn /C:/blah into just C:/blah on windows\n  let specPath = decodeURIComponent(specUrl.pathname)\n  let resolvedPath = decodeURIComponent(resolvedUrl.pathname)\n  if (isWindows) {\n    specPath = specPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n    resolvedPath = resolvedPath.replace(/^\\/+([a-z]:\\/)/i, '$1')\n  }\n\n  // replace ~ with homedir, but keep the ~ in the saveSpec\n  // otherwise, make it relative to where param\n  if (/^\\/~(\\/|$)/.test(specPath)) {\n    res.saveSpec = `file:${specPath.substr(1)}`\n    resolvedPath = path.resolve(homedir(), specPath.substr(3))\n  } else if (!path.isAbsolute(rawNoPrefix)) {\n    res.saveSpec = `file:${path.relative(where, resolvedPath)}`\n  } else {\n    res.saveSpec = `file:${path.resolve(resolvedPath)}`\n  }\n\n  res.fetchSpec = path.resolve(where, resolvedPath)\n  return res\n}\n\nfunction fromHostedGit (res, hosted) {\n  res.type = 'git'\n  res.hosted = hosted\n  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false })\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString()\n  return setGitCommittish(res, hosted.committish)\n}\n\nfunction unsupportedURLType (protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`)\n  err.code = 'EUNSUPPORTEDPROTOCOL'\n  return err\n}\n\nfunction matchGitScp (spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i)\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2],\n  }\n}\n\nfunction fromURL (res) {\n  // eslint-disable-next-line node/no-deprecated-api\n  const urlparse = url.parse(res.rawSpec)\n  res.saveSpec = res.rawSpec\n  // check the protocol, and then see if it's git or not\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:': {\n      res.type = 'git'\n      const match = urlparse.protocol === 'git+ssh:' ? matchGitScp(res.rawSpec)\n        : null\n      if (match) {\n        setGitCommittish(res, match.gitCommittish)\n        res.fetchSpec = match.fetchSpec\n      } else {\n        setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '')\n        urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '')\n        if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n          // keep the drive letter : on windows file paths\n          urlparse.host += ':'\n          urlparse.hostname += ':'\n        }\n        delete urlparse.hash\n        res.fetchSpec = url.format(urlparse)\n      }\n      break\n    }\n    case 'http:':\n    case 'https:':\n      res.type = 'remote'\n      res.fetchSpec = res.saveSpec\n      break\n\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec)\n  }\n\n  return res\n}\n\nfunction fromAlias (res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where)\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported')\n  }\n\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps')\n  }\n\n  res.subSpec = subSpec\n  res.registry = true\n  res.type = 'alias'\n  res.saveSpec = null\n  res.fetchSpec = null\n  return res\n}\n\nfunction fromRegistry (res) {\n  res.registry = true\n  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec.trim()\n  // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n  res.saveSpec = null\n  res.fetchSpec = spec\n  const version = semver.valid(spec, true)\n  const range = semver.validRange(spec, true)\n  if (version) {\n    res.type = 'version'\n  } else if (range) {\n    res.type = 'range'\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec, res.raw)\n    }\n    res.type = 'tag'\n  }\n  return res\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}