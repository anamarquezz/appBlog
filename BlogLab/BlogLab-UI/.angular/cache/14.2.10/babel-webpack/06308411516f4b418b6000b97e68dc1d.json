{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeJsonWorkspace = void 0;\n\nconst jsonc_parser_1 = require(\"jsonc-parser\");\n\nconst metadata_1 = require(\"./metadata\");\n\nfunction writeJsonWorkspace(_x, _x2, _x3) {\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nfunction _writeJsonWorkspace() {\n  _writeJsonWorkspace = _asyncToGenerator(function* (workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n\n    if (metadata) {\n      if (!metadata.hasChanges) {\n        return;\n      } // update existing JSON workspace\n\n\n      const data = updateJsonWorkspace(metadata);\n      return host.writeFile(path !== null && path !== void 0 ? path : metadata.filePath, data);\n    } else {\n      // serialize directly\n      if (!path) {\n        throw new Error('path option is required');\n      }\n\n      const obj = convertJsonWorkspace(workspace, options.schema);\n      const data = JSON.stringify(obj, null, 2);\n      return host.writeFile(path, data);\n    }\n  });\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nexports.writeJsonWorkspace = writeJsonWorkspace;\n\nfunction convertJsonWorkspace(workspace, schema) {\n  const obj = {\n    $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n    version: 1,\n    ...workspace.extensions,\n    ...(isEmpty(workspace.projects) ? {} : {\n      projects: convertJsonProjectCollection(workspace.projects)\n    })\n  };\n  return obj;\n}\n\nfunction convertJsonProjectCollection(collection) {\n  const projects = Object.create(null);\n\n  for (const [projectName, project] of collection) {\n    projects[projectName] = convertJsonProject(project);\n  }\n\n  return projects;\n}\n\nfunction convertJsonProject(project) {\n  let targets;\n\n  if (project.targets.size > 0) {\n    targets = Object.create(null);\n\n    for (const [targetName, target] of project.targets) {\n      targets[targetName] = convertJsonTarget(target);\n    }\n  }\n\n  const obj = { ...project.extensions,\n    root: project.root,\n    ...(project.sourceRoot === undefined ? {} : {\n      sourceRoot: project.sourceRoot\n    }),\n    ...(project.prefix === undefined ? {} : {\n      prefix: project.prefix\n    }),\n    ...(targets === undefined ? {} : {\n      architect: targets\n    })\n  };\n  return obj;\n}\n\nfunction isEmpty(obj) {\n  return obj === undefined || Object.keys(obj).length === 0;\n}\n\nfunction convertJsonTarget(target) {\n  return {\n    builder: target.builder,\n    ...(isEmpty(target.options) ? {} : {\n      options: target.options\n    }),\n    ...(isEmpty(target.configurations) ? {} : {\n      configurations: target.configurations\n    }),\n    ...(target.defaultConfiguration === undefined ? {} : {\n      defaultConfiguration: target.defaultConfiguration\n    })\n  };\n}\n\nfunction convertJsonTargetCollection(collection) {\n  const targets = Object.create(null);\n\n  for (const [projectName, target] of collection) {\n    targets[projectName] = convertJsonTarget(target);\n  }\n\n  return targets;\n}\n\nfunction normalizeValue(value, type) {\n  if (value === undefined) {\n    return undefined;\n  }\n\n  switch (type) {\n    case 'project':\n      return convertJsonProject(value);\n\n    case 'projectcollection':\n      const projects = convertJsonProjectCollection(value);\n      return isEmpty(projects) ? undefined : projects;\n\n    case 'target':\n      return convertJsonTarget(value);\n\n    case 'targetcollection':\n      const targets = convertJsonTargetCollection(value);\n      return isEmpty(targets) ? undefined : targets;\n\n    default:\n      return value;\n  }\n}\n\nfunction updateJsonWorkspace(metadata) {\n  let {\n    raw: content\n  } = metadata;\n  const {\n    changes,\n    hasLegacyTargetsName\n  } = metadata;\n\n  for (const {\n    jsonPath,\n    value,\n    type\n  } of changes.values()) {\n    // Determine which key to use if (architect or targets)\n    if (hasLegacyTargetsName && jsonPath[2] === 'targets') {\n      jsonPath[2] = 'architect';\n    } // modify\n\n\n    const newJsonPath = jsonPath.map(v => isFinite(+v) ? +v : v); // TODO: `modify` re-parses the content every time.\n    // See: https://github.com/microsoft/node-jsonc-parser/blob/35d94cd71bd48f9784453b2439262c938e21d49b/src/impl/edit.ts#L18\n    // Ideally this should accept a string or an AST to avoid the potentially expensive repeat parsing operation.\n\n    const edits = (0, jsonc_parser_1.modify)(content, newJsonPath, normalizeValue(value, type), {\n      formattingOptions: {\n        insertSpaces: true,\n        tabSize: 2\n      }\n    });\n    content = (0, jsonc_parser_1.applyEdits)(content, edits);\n  }\n\n  return content;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","writeJsonWorkspace","jsonc_parser_1","require","metadata_1","workspace","host","path","options","metadata","JsonWorkspaceSymbol","hasChanges","data","updateJsonWorkspace","writeFile","filePath","Error","obj","convertJsonWorkspace","schema","JSON","stringify","$schema","version","extensions","isEmpty","projects","convertJsonProjectCollection","collection","create","projectName","project","convertJsonProject","targets","size","targetName","target","convertJsonTarget","root","sourceRoot","undefined","prefix","architect","keys","length","builder","configurations","defaultConfiguration","convertJsonTargetCollection","normalizeValue","type","raw","content","changes","hasLegacyTargetsName","jsonPath","values","newJsonPath","map","v","isFinite","edits","modify","formattingOptions","insertSpaces","tabSize","applyEdits"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/workspace/json/writer.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst metadata_1 = require(\"./metadata\");\nasync function writeJsonWorkspace(workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n    if (metadata) {\n        if (!metadata.hasChanges) {\n            return;\n        }\n        // update existing JSON workspace\n        const data = updateJsonWorkspace(metadata);\n        return host.writeFile(path !== null && path !== void 0 ? path : metadata.filePath, data);\n    }\n    else {\n        // serialize directly\n        if (!path) {\n            throw new Error('path option is required');\n        }\n        const obj = convertJsonWorkspace(workspace, options.schema);\n        const data = JSON.stringify(obj, null, 2);\n        return host.writeFile(path, data);\n    }\n}\nexports.writeJsonWorkspace = writeJsonWorkspace;\nfunction convertJsonWorkspace(workspace, schema) {\n    const obj = {\n        $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n        version: 1,\n        ...workspace.extensions,\n        ...(isEmpty(workspace.projects)\n            ? {}\n            : { projects: convertJsonProjectCollection(workspace.projects) }),\n    };\n    return obj;\n}\nfunction convertJsonProjectCollection(collection) {\n    const projects = Object.create(null);\n    for (const [projectName, project] of collection) {\n        projects[projectName] = convertJsonProject(project);\n    }\n    return projects;\n}\nfunction convertJsonProject(project) {\n    let targets;\n    if (project.targets.size > 0) {\n        targets = Object.create(null);\n        for (const [targetName, target] of project.targets) {\n            targets[targetName] = convertJsonTarget(target);\n        }\n    }\n    const obj = {\n        ...project.extensions,\n        root: project.root,\n        ...(project.sourceRoot === undefined ? {} : { sourceRoot: project.sourceRoot }),\n        ...(project.prefix === undefined ? {} : { prefix: project.prefix }),\n        ...(targets === undefined ? {} : { architect: targets }),\n    };\n    return obj;\n}\nfunction isEmpty(obj) {\n    return obj === undefined || Object.keys(obj).length === 0;\n}\nfunction convertJsonTarget(target) {\n    return {\n        builder: target.builder,\n        ...(isEmpty(target.options) ? {} : { options: target.options }),\n        ...(isEmpty(target.configurations)\n            ? {}\n            : { configurations: target.configurations }),\n        ...(target.defaultConfiguration === undefined\n            ? {}\n            : { defaultConfiguration: target.defaultConfiguration }),\n    };\n}\nfunction convertJsonTargetCollection(collection) {\n    const targets = Object.create(null);\n    for (const [projectName, target] of collection) {\n        targets[projectName] = convertJsonTarget(target);\n    }\n    return targets;\n}\nfunction normalizeValue(value, type) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch (type) {\n        case 'project':\n            return convertJsonProject(value);\n        case 'projectcollection':\n            const projects = convertJsonProjectCollection(value);\n            return isEmpty(projects) ? undefined : projects;\n        case 'target':\n            return convertJsonTarget(value);\n        case 'targetcollection':\n            const targets = convertJsonTargetCollection(value);\n            return isEmpty(targets) ? undefined : targets;\n        default:\n            return value;\n    }\n}\nfunction updateJsonWorkspace(metadata) {\n    let { raw: content } = metadata;\n    const { changes, hasLegacyTargetsName } = metadata;\n    for (const { jsonPath, value, type } of changes.values()) {\n        // Determine which key to use if (architect or targets)\n        if (hasLegacyTargetsName && jsonPath[2] === 'targets') {\n            jsonPath[2] = 'architect';\n        }\n        // modify\n        const newJsonPath = jsonPath.map((v) => (isFinite(+v) ? +v : v));\n        // TODO: `modify` re-parses the content every time.\n        // See: https://github.com/microsoft/node-jsonc-parser/blob/35d94cd71bd48f9784453b2439262c938e21d49b/src/impl/edit.ts#L18\n        // Ideally this should accept a string or an AST to avoid the potentially expensive repeat parsing operation.\n        const edits = (0, jsonc_parser_1.modify)(content, newJsonPath, normalizeValue(value, type), {\n            formattingOptions: {\n                insertSpaces: true,\n                tabSize: 2,\n            },\n        });\n        content = (0, jsonc_parser_1.applyEdits)(content, edits);\n    }\n    return content;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}