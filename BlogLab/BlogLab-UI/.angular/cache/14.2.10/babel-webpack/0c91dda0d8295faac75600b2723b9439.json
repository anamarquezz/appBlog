{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst events = require('events');\n\nconst util = require('util');\n\nconst contentPath = require('./path');\n\nconst fixOwner = require('../util/fix-owner');\n\nconst fs = require('@npmcli/fs');\n\nconst moveFile = require('../util/move-file');\n\nconst Minipass = require('minipass');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst Flush = require('minipass-flush');\n\nconst path = require('path');\n\nconst rimraf = util.promisify(require('rimraf'));\n\nconst ssri = require('ssri');\n\nconst uniqueFilename = require('unique-filename');\n\nconst fsm = require('fs-minipass');\n\nmodule.exports = write;\n\nfunction write(_x, _x2) {\n  return _write.apply(this, arguments);\n}\n\nfunction _write() {\n  _write = _asyncToGenerator(function* (cache, data, opts = {}) {\n    const {\n      algorithms,\n      size,\n      integrity\n    } = opts;\n\n    if (algorithms && algorithms.length > 1) {\n      throw new Error('opts.algorithms only supports a single algorithm for now');\n    }\n\n    if (typeof size === 'number' && data.length !== size) {\n      throw sizeError(size, data.length);\n    }\n\n    const sri = ssri.fromData(data, algorithms ? {\n      algorithms\n    } : {});\n\n    if (integrity && !ssri.checkData(data, integrity, opts)) {\n      throw checksumError(integrity, sri);\n    }\n\n    const tmp = yield makeTmp(cache, opts);\n\n    try {\n      yield fs.writeFile(tmp.target, data, {\n        flag: 'wx'\n      });\n      yield moveToDestination(tmp, cache, sri, opts);\n      return {\n        integrity: sri,\n        size: data.length\n      };\n    } finally {\n      if (!tmp.moved) {\n        yield rimraf(tmp.target);\n      }\n    }\n  });\n  return _write.apply(this, arguments);\n}\n\nmodule.exports.stream = writeStream; // writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\n\nclass CacacheWriteStream extends Flush {\n  constructor(cache, opts) {\n    super();\n    this.opts = opts;\n    this.cache = cache;\n    this.inputStream = new Minipass();\n    this.inputStream.on('error', er => this.emit('error', er));\n    this.inputStream.on('drain', () => this.emit('drain'));\n    this.handleContentP = null;\n  }\n\n  write(chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);\n    }\n\n    return this.inputStream.write(chunk, encoding, cb);\n  }\n\n  flush(cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty');\n        e.code = 'ENODATA'; // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n\n        return Promise.reject(e).catch(cb);\n      } // eslint-disable-next-line promise/catch-or-return\n\n\n      this.handleContentP.then(res => {\n        res.integrity && this.emit('integrity', res.integrity); // eslint-disable-next-line promise/always-return\n\n        res.size !== null && this.emit('size', res.size);\n        cb();\n      }, er => cb(er));\n    });\n  }\n\n}\n\nfunction writeStream(cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts);\n}\n\nfunction handleContent(_x3, _x4, _x5) {\n  return _handleContent.apply(this, arguments);\n}\n\nfunction _handleContent() {\n  _handleContent = _asyncToGenerator(function* (inputStream, cache, opts) {\n    const tmp = yield makeTmp(cache, opts);\n\n    try {\n      const res = yield pipeToTmp(inputStream, cache, tmp.target, opts);\n      yield moveToDestination(tmp, cache, res.integrity, opts);\n      return res;\n    } finally {\n      if (!tmp.moved) {\n        yield rimraf(tmp.target);\n      }\n    }\n  });\n  return _handleContent.apply(this, arguments);\n}\n\nfunction pipeToTmp(_x6, _x7, _x8, _x9) {\n  return _pipeToTmp.apply(this, arguments);\n}\n\nfunction _pipeToTmp() {\n  _pipeToTmp = _asyncToGenerator(function* (inputStream, cache, tmpTarget, opts) {\n    const outStream = new fsm.WriteStream(tmpTarget, {\n      flags: 'wx'\n    });\n\n    if (opts.integrityEmitter) {\n      // we need to create these all simultaneously since they can fire in any order\n      const [integrity, size] = yield Promise.all([events.once(opts.integrityEmitter, 'integrity').then(res => res[0]), events.once(opts.integrityEmitter, 'size').then(res => res[0]), new Pipeline(inputStream, outStream).promise()]);\n      return {\n        integrity,\n        size\n      };\n    }\n\n    let integrity;\n    let size;\n    const hashStream = ssri.integrityStream({\n      integrity: opts.integrity,\n      algorithms: opts.algorithms,\n      size: opts.size\n    });\n    hashStream.on('integrity', i => {\n      integrity = i;\n    });\n    hashStream.on('size', s => {\n      size = s;\n    });\n    const pipeline = new Pipeline(inputStream, hashStream, outStream);\n    yield pipeline.promise();\n    return {\n      integrity,\n      size\n    };\n  });\n  return _pipeToTmp.apply(this, arguments);\n}\n\nfunction makeTmp(_x10, _x11) {\n  return _makeTmp.apply(this, arguments);\n}\n\nfunction _makeTmp() {\n  _makeTmp = _asyncToGenerator(function* (cache, opts) {\n    const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n    yield fixOwner.mkdirfix(cache, path.dirname(tmpTarget));\n    return {\n      target: tmpTarget,\n      moved: false\n    };\n  });\n  return _makeTmp.apply(this, arguments);\n}\n\nfunction moveToDestination(_x12, _x13, _x14, _x15) {\n  return _moveToDestination.apply(this, arguments);\n}\n\nfunction _moveToDestination() {\n  _moveToDestination = _asyncToGenerator(function* (tmp, cache, sri, opts) {\n    const destination = contentPath(cache, sri);\n    const destDir = path.dirname(destination);\n    yield fixOwner.mkdirfix(cache, destDir);\n    yield moveFile(tmp.target, destination);\n    tmp.moved = true;\n    yield fixOwner.chownr(cache, destination);\n  });\n  return _moveToDestination.apply(this, arguments);\n}\n\nfunction sizeError(expected, found) {\n  /* eslint-disable-next-line max-len */\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);\n  err.expected = expected;\n  err.found = found;\n  err.code = 'EBADSIZE';\n  return err;\n}\n\nfunction checksumError(expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`);\n  err.code = 'EINTEGRITY';\n  err.expected = expected;\n  err.found = found;\n  return err;\n}","map":{"version":3,"names":["events","require","util","contentPath","fixOwner","fs","moveFile","Minipass","Pipeline","Flush","path","rimraf","promisify","ssri","uniqueFilename","fsm","module","exports","write","cache","data","opts","algorithms","size","integrity","length","Error","sizeError","sri","fromData","checkData","checksumError","tmp","makeTmp","writeFile","target","flag","moveToDestination","moved","stream","writeStream","CacacheWriteStream","constructor","inputStream","on","er","emit","handleContentP","chunk","encoding","cb","handleContent","flush","end","e","code","Promise","reject","catch","then","res","pipeToTmp","tmpTarget","outStream","WriteStream","flags","integrityEmitter","all","once","promise","hashStream","integrityStream","i","s","pipeline","join","tmpPrefix","mkdirfix","dirname","destination","destDir","chownr","expected","found","err"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/cacache/lib/content/write.js"],"sourcesContent":["'use strict'\n\nconst events = require('events')\nconst util = require('util')\n\nconst contentPath = require('./path')\nconst fixOwner = require('../util/fix-owner')\nconst fs = require('@npmcli/fs')\nconst moveFile = require('../util/move-file')\nconst Minipass = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst Flush = require('minipass-flush')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\nconst uniqueFilename = require('unique-filename')\nconst fsm = require('fs-minipass')\n\nmodule.exports = write\n\nasync function write (cache, data, opts = {}) {\n  const { algorithms, size, integrity } = opts\n  if (algorithms && algorithms.length > 1) {\n    throw new Error('opts.algorithms only supports a single algorithm for now')\n  }\n\n  if (typeof size === 'number' && data.length !== size) {\n    throw sizeError(size, data.length)\n  }\n\n  const sri = ssri.fromData(data, algorithms ? { algorithms } : {})\n  if (integrity && !ssri.checkData(data, integrity, opts)) {\n    throw checksumError(integrity, sri)\n  }\n\n  const tmp = await makeTmp(cache, opts)\n  try {\n    await fs.writeFile(tmp.target, data, { flag: 'wx' })\n    await moveToDestination(tmp, cache, sri, opts)\n    return { integrity: sri, size: data.length }\n  } finally {\n    if (!tmp.moved) {\n      await rimraf(tmp.target)\n    }\n  }\n}\n\nmodule.exports.stream = writeStream\n\n// writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\nclass CacacheWriteStream extends Flush {\n  constructor (cache, opts) {\n    super()\n    this.opts = opts\n    this.cache = cache\n    this.inputStream = new Minipass()\n    this.inputStream.on('error', er => this.emit('error', er))\n    this.inputStream.on('drain', () => this.emit('drain'))\n    this.handleContentP = null\n  }\n\n  write (chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(\n        this.inputStream,\n        this.cache,\n        this.opts\n      )\n    }\n    return this.inputStream.write(chunk, encoding, cb)\n  }\n\n  flush (cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty')\n        e.code = 'ENODATA'\n        // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n        return Promise.reject(e).catch(cb)\n      }\n      // eslint-disable-next-line promise/catch-or-return\n      this.handleContentP.then(\n        (res) => {\n          res.integrity && this.emit('integrity', res.integrity)\n          // eslint-disable-next-line promise/always-return\n          res.size !== null && this.emit('size', res.size)\n          cb()\n        },\n        (er) => cb(er)\n      )\n    })\n  }\n}\n\nfunction writeStream (cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts)\n}\n\nasync function handleContent (inputStream, cache, opts) {\n  const tmp = await makeTmp(cache, opts)\n  try {\n    const res = await pipeToTmp(inputStream, cache, tmp.target, opts)\n    await moveToDestination(\n      tmp,\n      cache,\n      res.integrity,\n      opts\n    )\n    return res\n  } finally {\n    if (!tmp.moved) {\n      await rimraf(tmp.target)\n    }\n  }\n}\n\nasync function pipeToTmp (inputStream, cache, tmpTarget, opts) {\n  const outStream = new fsm.WriteStream(tmpTarget, {\n    flags: 'wx',\n  })\n\n  if (opts.integrityEmitter) {\n    // we need to create these all simultaneously since they can fire in any order\n    const [integrity, size] = await Promise.all([\n      events.once(opts.integrityEmitter, 'integrity').then(res => res[0]),\n      events.once(opts.integrityEmitter, 'size').then(res => res[0]),\n      new Pipeline(inputStream, outStream).promise(),\n    ])\n    return { integrity, size }\n  }\n\n  let integrity\n  let size\n  const hashStream = ssri.integrityStream({\n    integrity: opts.integrity,\n    algorithms: opts.algorithms,\n    size: opts.size,\n  })\n  hashStream.on('integrity', i => {\n    integrity = i\n  })\n  hashStream.on('size', s => {\n    size = s\n  })\n\n  const pipeline = new Pipeline(inputStream, hashStream, outStream)\n  await pipeline.promise()\n  return { integrity, size }\n}\n\nasync function makeTmp (cache, opts) {\n  const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix)\n  await fixOwner.mkdirfix(cache, path.dirname(tmpTarget))\n  return {\n    target: tmpTarget,\n    moved: false,\n  }\n}\n\nasync function moveToDestination (tmp, cache, sri, opts) {\n  const destination = contentPath(cache, sri)\n  const destDir = path.dirname(destination)\n\n  await fixOwner.mkdirfix(cache, destDir)\n  await moveFile(tmp.target, destination)\n  tmp.moved = true\n  await fixOwner.chownr(cache, destination)\n}\n\nfunction sizeError (expected, found) {\n  /* eslint-disable-next-line max-len */\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`)\n  err.expected = expected\n  err.found = found\n  err.code = 'EBADSIZE'\n  return err\n}\n\nfunction checksumError (expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`)\n  err.code = 'EINTEGRITY'\n  err.expected = expected\n  err.found = found\n  return err\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}