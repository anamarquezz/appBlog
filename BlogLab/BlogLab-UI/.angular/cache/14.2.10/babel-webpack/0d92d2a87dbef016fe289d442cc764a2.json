{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  FetchError,\n  Request,\n  isRedirect\n} = require('minipass-fetch');\n\nconst url = require('url');\n\nconst CachePolicy = require('./cache/policy.js');\n\nconst cache = require('./cache/index.js');\n\nconst remote = require('./remote.js'); // given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\n\n\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status)) {\n    return false;\n  }\n\n  if (options.redirect === 'manual') {\n    return false;\n  }\n\n  if (options.redirect === 'error') {\n    throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', {\n      code: 'ENOREDIRECT'\n    });\n  }\n\n  if (!response.headers.has('location')) {\n    throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', {\n      code: 'EINVALIDREDIRECT'\n    });\n  }\n\n  if (request.counter >= request.follow) {\n    throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', {\n      code: 'EMAXREDIRECT'\n    });\n  }\n\n  return true;\n}; // given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\n\n\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options\n  };\n  const location = response.headers.get('location');\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url); // Comment below is used under the following license:\n\n  /**\n   * @license\n   * Copyright (c) 2010-2012 Mikeal Rogers\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   * http://www.apache.org/licenses/LICENSE-2.0\n   * Unless required by applicable law or agreed to in writing,\n   * software distributed under the License is distributed on an \"AS\n   * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n   * express or implied. See the License for the specific language\n   * governing permissions and limitations under the License.\n   */\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) {\n    request.headers.delete('authorization');\n    request.headers.delete('cookie');\n  } // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n\n\n  if (response.status === 303 || request.method === 'POST' && [301, 302].includes(response.status)) {\n    _opts.method = 'GET';\n    _opts.body = null;\n    request.headers.delete('content-length');\n  }\n\n  _opts.headers = {};\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value;\n  });\n  _opts.counter = ++request.counter;\n  const redirectReq = new Request(url.format(redirectUrl), _opts);\n  return {\n    request: redirectReq,\n    options: _opts\n  };\n};\n\nconst fetch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (request, options) {\n    const response = CachePolicy.storable(request, options) ? yield cache(request, options) : yield remote(request, options); // if the request wasn't a GET or HEAD, and the response\n    // status is between 200 and 399 inclusive, invalidate the\n    // request url\n\n    if (!['GET', 'HEAD'].includes(request.method) && response.status >= 200 && response.status <= 399) {\n      yield cache.invalidate(request, options);\n    }\n\n    if (!canFollowRedirect(request, response, options)) {\n      return response;\n    }\n\n    const redirect = getRedirect(request, response, options);\n    return fetch(redirect.request, redirect.options);\n  });\n\n  return function fetch(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = fetch;","map":{"version":3,"names":["FetchError","Request","isRedirect","require","url","CachePolicy","cache","remote","canFollowRedirect","request","response","options","status","redirect","code","headers","has","counter","follow","getRedirect","_opts","location","get","redirectUrl","URL","test","undefined","hostname","delete","method","includes","body","forEach","value","key","redirectReq","format","fetch","storable","invalidate","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/make-fetch-happen/lib/fetch.js"],"sourcesContent":["'use strict'\n\nconst { FetchError, Request, isRedirect } = require('minipass-fetch')\nconst url = require('url')\n\nconst CachePolicy = require('./cache/policy.js')\nconst cache = require('./cache/index.js')\nconst remote = require('./remote.js')\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status)) {\n    return false\n  }\n\n  if (options.redirect === 'manual') {\n    return false\n  }\n\n  if (options.redirect === 'error') {\n    throw new FetchError(`redirect mode is set to error: ${request.url}`,\n      'no-redirect', { code: 'ENOREDIRECT' })\n  }\n\n  if (!response.headers.has('location')) {\n    throw new FetchError(`redirect location header missing for: ${request.url}`,\n      'no-location', { code: 'EINVALIDREDIRECT' })\n  }\n\n  if (request.counter >= request.follow) {\n    throw new FetchError(`maximum redirect reached at: ${request.url}`,\n      'max-redirect', { code: 'EMAXREDIRECT' })\n  }\n\n  return true\n}\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options }\n  const location = response.headers.get('location')\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url)\n  // Comment below is used under the following license:\n  /**\n   * @license\n   * Copyright (c) 2010-2012 Mikeal Rogers\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   * http://www.apache.org/licenses/LICENSE-2.0\n   * Unless required by applicable law or agreed to in writing,\n   * software distributed under the License is distributed on an \"AS\n   * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n   * express or implied. See the License for the specific language\n   * governing permissions and limitations under the License.\n   */\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) {\n    request.headers.delete('authorization')\n    request.headers.delete('cookie')\n  }\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (\n    response.status === 303 ||\n    (request.method === 'POST' && [301, 302].includes(response.status))\n  ) {\n    _opts.method = 'GET'\n    _opts.body = null\n    request.headers.delete('content-length')\n  }\n\n  _opts.headers = {}\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value\n  })\n\n  _opts.counter = ++request.counter\n  const redirectReq = new Request(url.format(redirectUrl), _opts)\n  return {\n    request: redirectReq,\n    options: _opts,\n  }\n}\n\nconst fetch = async (request, options) => {\n  const response = CachePolicy.storable(request, options)\n    ? await cache(request, options)\n    : await remote(request, options)\n\n  // if the request wasn't a GET or HEAD, and the response\n  // status is between 200 and 399 inclusive, invalidate the\n  // request url\n  if (!['GET', 'HEAD'].includes(request.method) &&\n      response.status >= 200 &&\n      response.status <= 399) {\n    await cache.invalidate(request, options)\n  }\n\n  if (!canFollowRedirect(request, response, options)) {\n    return response\n  }\n\n  const redirect = getRedirect(request, response, options)\n  return fetch(redirect.request, redirect.options)\n}\n\nmodule.exports = fetch\n"],"mappings":"AAAA;;;;AAEA,MAAM;EAAEA,UAAF;EAAcC,OAAd;EAAuBC;AAAvB,IAAsCC,OAAO,CAAC,gBAAD,CAAnD;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,KAAD,CAAnB;;AAEA,MAAME,WAAW,GAAGF,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,kBAAD,CAArB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,aAAD,CAAtB,C,CAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,iBAAiB,GAAG,CAACC,OAAD,EAAUC,QAAV,EAAoBC,OAApB,KAAgC;EACxD,IAAI,CAACT,UAAU,CAACQ,QAAQ,CAACE,MAAV,CAAf,EAAkC;IAChC,OAAO,KAAP;EACD;;EAED,IAAID,OAAO,CAACE,QAAR,KAAqB,QAAzB,EAAmC;IACjC,OAAO,KAAP;EACD;;EAED,IAAIF,OAAO,CAACE,QAAR,KAAqB,OAAzB,EAAkC;IAChC,MAAM,IAAIb,UAAJ,CAAgB,kCAAiCS,OAAO,CAACL,GAAI,EAA7D,EACJ,aADI,EACW;MAAEU,IAAI,EAAE;IAAR,CADX,CAAN;EAED;;EAED,IAAI,CAACJ,QAAQ,CAACK,OAAT,CAAiBC,GAAjB,CAAqB,UAArB,CAAL,EAAuC;IACrC,MAAM,IAAIhB,UAAJ,CAAgB,yCAAwCS,OAAO,CAACL,GAAI,EAApE,EACJ,aADI,EACW;MAAEU,IAAI,EAAE;IAAR,CADX,CAAN;EAED;;EAED,IAAIL,OAAO,CAACQ,OAAR,IAAmBR,OAAO,CAACS,MAA/B,EAAuC;IACrC,MAAM,IAAIlB,UAAJ,CAAgB,gCAA+BS,OAAO,CAACL,GAAI,EAA3D,EACJ,cADI,EACY;MAAEU,IAAI,EAAE;IAAR,CADZ,CAAN;EAED;;EAED,OAAO,IAAP;AACD,CAzBD,C,CA2BA;AACA;AACA;;;AACA,MAAMK,WAAW,GAAG,CAACV,OAAD,EAAUC,QAAV,EAAoBC,OAApB,KAAgC;EAClD,MAAMS,KAAK,GAAG,EAAE,GAAGT;EAAL,CAAd;EACA,MAAMU,QAAQ,GAAGX,QAAQ,CAACK,OAAT,CAAiBO,GAAjB,CAAqB,UAArB,CAAjB;EACA,MAAMC,WAAW,GAAG,IAAInB,GAAG,CAACoB,GAAR,CAAYH,QAAZ,EAAsB,WAAWI,IAAX,CAAgBJ,QAAhB,IAA4BK,SAA5B,GAAwCjB,OAAO,CAACL,GAAtE,CAApB,CAHkD,CAIlD;;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE;EACA;EACA;;EACA,IAAI,IAAIA,GAAG,CAACoB,GAAR,CAAYf,OAAO,CAACL,GAApB,EAAyBuB,QAAzB,KAAsCJ,WAAW,CAACI,QAAtD,EAAgE;IAC9DlB,OAAO,CAACM,OAAR,CAAgBa,MAAhB,CAAuB,eAAvB;IACAnB,OAAO,CAACM,OAAR,CAAgBa,MAAhB,CAAuB,QAAvB;EACD,CAzBiD,CA2BlD;EACA;;;EACA,IACElB,QAAQ,CAACE,MAAT,KAAoB,GAApB,IACCH,OAAO,CAACoB,MAAR,KAAmB,MAAnB,IAA6B,CAAC,GAAD,EAAM,GAAN,EAAWC,QAAX,CAAoBpB,QAAQ,CAACE,MAA7B,CAFhC,EAGE;IACAQ,KAAK,CAACS,MAAN,GAAe,KAAf;IACAT,KAAK,CAACW,IAAN,GAAa,IAAb;IACAtB,OAAO,CAACM,OAAR,CAAgBa,MAAhB,CAAuB,gBAAvB;EACD;;EAEDR,KAAK,CAACL,OAAN,GAAgB,EAAhB;EACAN,OAAO,CAACM,OAAR,CAAgBiB,OAAhB,CAAwB,CAACC,KAAD,EAAQC,GAAR,KAAgB;IACtCd,KAAK,CAACL,OAAN,CAAcmB,GAAd,IAAqBD,KAArB;EACD,CAFD;EAIAb,KAAK,CAACH,OAAN,GAAgB,EAAER,OAAO,CAACQ,OAA1B;EACA,MAAMkB,WAAW,GAAG,IAAIlC,OAAJ,CAAYG,GAAG,CAACgC,MAAJ,CAAWb,WAAX,CAAZ,EAAqCH,KAArC,CAApB;EACA,OAAO;IACLX,OAAO,EAAE0B,WADJ;IAELxB,OAAO,EAAES;EAFJ,CAAP;AAID,CAjDD;;AAmDA,MAAMiB,KAAK;EAAA,6BAAG,WAAO5B,OAAP,EAAgBE,OAAhB,EAA4B;IACxC,MAAMD,QAAQ,GAAGL,WAAW,CAACiC,QAAZ,CAAqB7B,OAArB,EAA8BE,OAA9B,UACPL,KAAK,CAACG,OAAD,EAAUE,OAAV,CADE,SAEPJ,MAAM,CAACE,OAAD,EAAUE,OAAV,CAFhB,CADwC,CAKxC;IACA;IACA;;IACA,IAAI,CAAC,CAAC,KAAD,EAAQ,MAAR,EAAgBmB,QAAhB,CAAyBrB,OAAO,CAACoB,MAAjC,CAAD,IACAnB,QAAQ,CAACE,MAAT,IAAmB,GADnB,IAEAF,QAAQ,CAACE,MAAT,IAAmB,GAFvB,EAE4B;MAC1B,MAAMN,KAAK,CAACiC,UAAN,CAAiB9B,OAAjB,EAA0BE,OAA1B,CAAN;IACD;;IAED,IAAI,CAACH,iBAAiB,CAACC,OAAD,EAAUC,QAAV,EAAoBC,OAApB,CAAtB,EAAoD;MAClD,OAAOD,QAAP;IACD;;IAED,MAAMG,QAAQ,GAAGM,WAAW,CAACV,OAAD,EAAUC,QAAV,EAAoBC,OAApB,CAA5B;IACA,OAAO0B,KAAK,CAACxB,QAAQ,CAACJ,OAAV,EAAmBI,QAAQ,CAACF,OAA5B,CAAZ;EACD,CApBU;;EAAA,gBAAL0B,KAAK;IAAA;EAAA;AAAA,GAAX;;AAsBAG,MAAM,CAACC,OAAP,GAAiBJ,KAAjB"},"metadata":{},"sourceType":"script"}