{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readJsonWorkspace = void 0;\n\nconst jsonc_parser_1 = require(\"jsonc-parser\");\n\nconst utils_1 = require(\"../../json/utils\");\n\nconst definitions_1 = require(\"../definitions\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst utilities_1 = require(\"./utilities\");\n\nconst ANGULAR_WORKSPACE_EXTENSIONS = Object.freeze(['cli', 'defaultProject', 'newProjectRoot', 'schematics']);\nconst ANGULAR_PROJECT_EXTENSIONS = Object.freeze(['cli', 'schematics', 'projectType', 'i18n']);\n\nfunction readJsonWorkspace(_x, _x2) {\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nfunction _readJsonWorkspace() {\n  _readJsonWorkspace = _asyncToGenerator(function* (path, host, options = {}) {\n    var _a, _b;\n\n    const raw = yield host.readFile(path);\n\n    if (raw === undefined) {\n      throw new Error('Unable to read workspace file.');\n    }\n\n    const ast = (0, jsonc_parser_1.parseTree)(raw, undefined, {\n      allowTrailingComma: true,\n      disallowComments: false\n    });\n\n    if ((ast === null || ast === void 0 ? void 0 : ast.type) !== 'object' || !ast.children) {\n      throw new Error('Invalid workspace file - expected JSON object.');\n    } // Version check\n\n\n    const versionNode = (0, jsonc_parser_1.findNodeAtLocation)(ast, ['version']);\n\n    if (!versionNode) {\n      throw new Error('Unknown format - version specifier not found.');\n    }\n\n    const version = versionNode.value;\n\n    if (version !== 1) {\n      throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${version} ]`);\n    }\n\n    const context = {\n      host,\n      metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n      trackChanges: true,\n      unprefixedWorkspaceExtensions: new Set([...ANGULAR_WORKSPACE_EXTENSIONS, ...((_a = options.allowedWorkspaceExtensions) !== null && _a !== void 0 ? _a : [])]),\n      unprefixedProjectExtensions: new Set([...ANGULAR_PROJECT_EXTENSIONS, ...((_b = options.allowedProjectExtensions) !== null && _b !== void 0 ? _b : [])]),\n\n      error(message, _node) {\n        // TODO: Diagnostic reporting support\n        throw new Error(message);\n      },\n\n      warn(message, _node) {\n        // TODO: Diagnostic reporting support\n        // eslint-disable-next-line no-console\n        console.warn(message);\n      }\n\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n  });\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nexports.readJsonWorkspace = readJsonWorkspace;\n\nfunction parseWorkspace(workspaceNode, context) {\n  const jsonMetadata = context.metadata;\n  let projects;\n  let extensions;\n\n  if (!context.trackChanges) {\n    extensions = Object.create(null);\n  } // TODO: `getNodeValue` - looks potentially expensive since it walks the whole tree and instantiates the full object structure each time.\n  // Might be something to look at moving forward to optimize.\n\n\n  const workspaceNodeValue = (0, jsonc_parser_1.getNodeValue)(workspaceNode);\n\n  for (const [name, value] of Object.entries(workspaceNodeValue)) {\n    if (name === '$schema' || name === 'version') {// skip\n    } else if (name === 'projects') {\n      const nodes = (0, jsonc_parser_1.findNodeAtLocation)(workspaceNode, ['projects']);\n\n      if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n        context.error('Invalid \"projects\" field found; expected an object.', value);\n        continue;\n      }\n\n      projects = parseProjectsObject(nodes, context);\n    } else {\n      if (!context.unprefixedWorkspaceExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n        context.warn(`Workspace extension with invalid name (${name}) found.`, name);\n      }\n\n      if (extensions) {\n        extensions[name] = value;\n      }\n    }\n  }\n\n  let collectionListener;\n\n  if (context.trackChanges) {\n    collectionListener = (name, newValue) => {\n      jsonMetadata.addChange(['projects', name], newValue, 'project');\n    };\n  }\n\n  const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n  return {\n    [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n    projects: projectCollection,\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(workspaceNodeValue, {\n      exclude: ['$schema', 'version', 'projects'],\n\n      listener(path, value) {\n        jsonMetadata.addChange(path, value);\n      }\n\n    })\n  };\n}\n\nfunction parseProjectsObject(projectsNode, context) {\n  const projects = Object.create(null);\n\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(projectsNode))) {\n    const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectsNode, [name]);\n\n    if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n      context.warn('Skipping invalid project value; expected an object.', value);\n      continue;\n    }\n\n    projects[name] = parseProject(name, nodes, context);\n  }\n\n  return projects;\n}\n\nfunction parseProject(projectName, projectNode, context) {\n  const jsonMetadata = context.metadata;\n  let targets;\n  let hasTargets = false;\n  let extensions;\n  let properties;\n\n  if (!context.trackChanges) {\n    // If not tracking changes, the parser will store the values directly in standard objects\n    extensions = Object.create(null);\n    properties = Object.create(null);\n  }\n\n  const projectNodeValue = (0, jsonc_parser_1.getNodeValue)(projectNode);\n\n  if (!('root' in projectNodeValue)) {\n    // TODO(alan-agius4): change this to error in v15.\n    context.warn(`Project \"${projectName}\" is missing a required property \"root\". This will become an error in the next major version.`, projectNodeValue);\n  }\n\n  for (const [name, value] of Object.entries(projectNodeValue)) {\n    switch (name) {\n      case 'targets':\n      case 'architect':\n        const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectNode, [name]);\n\n        if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n          context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n          break;\n        }\n\n        hasTargets = true;\n        targets = parseTargetsObject(projectName, nodes, context);\n        jsonMetadata.hasLegacyTargetsName = name === 'architect';\n        break;\n\n      case 'prefix':\n      case 'root':\n      case 'sourceRoot':\n        if (typeof value !== 'string') {\n          context.warn(`Project property \"${name}\" should be a string.`, value);\n        }\n\n        if (properties) {\n          properties[name] = value;\n        }\n\n        break;\n\n      default:\n        if (!context.unprefixedProjectExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n          context.warn(`Project '${projectName}' contains extension with invalid name (${name}).`, name);\n        }\n\n        if (extensions) {\n          extensions[name] = value;\n        }\n\n        break;\n    }\n  }\n\n  let collectionListener;\n\n  if (context.trackChanges) {\n    collectionListener = (name, newValue, collection) => {\n      if (hasTargets) {\n        jsonMetadata.addChange(['projects', projectName, 'targets', name], newValue, 'target');\n      } else {\n        jsonMetadata.addChange(['projects', projectName, 'targets'], collection, 'targetcollection');\n      }\n    };\n  }\n\n  const base = {\n    targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n      exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n\n      listener(path, value) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n\n    })\n  };\n  const baseKeys = new Set(Object.keys(base));\n  const project = properties !== null && properties !== void 0 ? properties : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n    include: ['prefix', 'root', 'sourceRoot', ...baseKeys],\n\n    listener(path, value) {\n      if (!baseKeys.has(path[0])) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n    }\n\n  });\n  return Object.assign(project, base);\n}\n\nfunction parseTargetsObject(projectName, targetsNode, context) {\n  const jsonMetadata = context.metadata;\n  const targets = Object.create(null);\n\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(targetsNode))) {\n    if (!(0, utils_1.isJsonObject)(value)) {\n      context.warn('Skipping invalid target value; expected an object.', value);\n      continue;\n    }\n\n    if (context.trackChanges) {\n      targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n        include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n\n        listener(path, value) {\n          jsonMetadata.addChange(['projects', projectName, 'targets', name, ...path], value);\n        }\n\n      });\n    } else {\n      targets[name] = value;\n    }\n  }\n\n  return targets;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","readJsonWorkspace","jsonc_parser_1","require","utils_1","definitions_1","metadata_1","utilities_1","ANGULAR_WORKSPACE_EXTENSIONS","freeze","ANGULAR_PROJECT_EXTENSIONS","path","host","options","_a","_b","raw","readFile","undefined","Error","ast","parseTree","allowTrailingComma","disallowComments","type","children","versionNode","findNodeAtLocation","version","context","metadata","JsonWorkspaceMetadata","trackChanges","unprefixedWorkspaceExtensions","Set","allowedWorkspaceExtensions","unprefixedProjectExtensions","allowedProjectExtensions","error","message","_node","warn","console","workspace","parseWorkspace","workspaceNode","jsonMetadata","projects","extensions","create","workspaceNodeValue","getNodeValue","name","entries","nodes","isJsonObject","parseProjectsObject","has","test","collectionListener","newValue","addChange","projectCollection","ProjectDefinitionCollection","JsonWorkspaceSymbol","createVirtualAstObject","exclude","listener","projectsNode","parseProject","projectName","projectNode","targets","hasTargets","properties","projectNodeValue","parseTargetsObject","hasLegacyTargetsName","collection","base","TargetDefinitionCollection","baseKeys","keys","project","include","assign","targetsNode"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/workspace/json/reader.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst utils_1 = require(\"../../json/utils\");\nconst definitions_1 = require(\"../definitions\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nconst ANGULAR_WORKSPACE_EXTENSIONS = Object.freeze([\n    'cli',\n    'defaultProject',\n    'newProjectRoot',\n    'schematics',\n]);\nconst ANGULAR_PROJECT_EXTENSIONS = Object.freeze(['cli', 'schematics', 'projectType', 'i18n']);\nasync function readJsonWorkspace(path, host, options = {}) {\n    var _a, _b;\n    const raw = await host.readFile(path);\n    if (raw === undefined) {\n        throw new Error('Unable to read workspace file.');\n    }\n    const ast = (0, jsonc_parser_1.parseTree)(raw, undefined, { allowTrailingComma: true, disallowComments: false });\n    if ((ast === null || ast === void 0 ? void 0 : ast.type) !== 'object' || !ast.children) {\n        throw new Error('Invalid workspace file - expected JSON object.');\n    }\n    // Version check\n    const versionNode = (0, jsonc_parser_1.findNodeAtLocation)(ast, ['version']);\n    if (!versionNode) {\n        throw new Error('Unknown format - version specifier not found.');\n    }\n    const version = versionNode.value;\n    if (version !== 1) {\n        throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${version} ]`);\n    }\n    const context = {\n        host,\n        metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n        trackChanges: true,\n        unprefixedWorkspaceExtensions: new Set([\n            ...ANGULAR_WORKSPACE_EXTENSIONS,\n            ...((_a = options.allowedWorkspaceExtensions) !== null && _a !== void 0 ? _a : []),\n        ]),\n        unprefixedProjectExtensions: new Set([\n            ...ANGULAR_PROJECT_EXTENSIONS,\n            ...((_b = options.allowedProjectExtensions) !== null && _b !== void 0 ? _b : []),\n        ]),\n        error(message, _node) {\n            // TODO: Diagnostic reporting support\n            throw new Error(message);\n        },\n        warn(message, _node) {\n            // TODO: Diagnostic reporting support\n            // eslint-disable-next-line no-console\n            console.warn(message);\n        },\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n}\nexports.readJsonWorkspace = readJsonWorkspace;\nfunction parseWorkspace(workspaceNode, context) {\n    const jsonMetadata = context.metadata;\n    let projects;\n    let extensions;\n    if (!context.trackChanges) {\n        extensions = Object.create(null);\n    }\n    // TODO: `getNodeValue` - looks potentially expensive since it walks the whole tree and instantiates the full object structure each time.\n    // Might be something to look at moving forward to optimize.\n    const workspaceNodeValue = (0, jsonc_parser_1.getNodeValue)(workspaceNode);\n    for (const [name, value] of Object.entries(workspaceNodeValue)) {\n        if (name === '$schema' || name === 'version') {\n            // skip\n        }\n        else if (name === 'projects') {\n            const nodes = (0, jsonc_parser_1.findNodeAtLocation)(workspaceNode, ['projects']);\n            if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n                context.error('Invalid \"projects\" field found; expected an object.', value);\n                continue;\n            }\n            projects = parseProjectsObject(nodes, context);\n        }\n        else {\n            if (!context.unprefixedWorkspaceExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                context.warn(`Workspace extension with invalid name (${name}) found.`, name);\n            }\n            if (extensions) {\n                extensions[name] = value;\n            }\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        collectionListener = (name, newValue) => {\n            jsonMetadata.addChange(['projects', name], newValue, 'project');\n        };\n    }\n    const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n    return {\n        [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n        projects: projectCollection,\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(workspaceNodeValue, {\n            exclude: ['$schema', 'version', 'projects'],\n            listener(path, value) {\n                jsonMetadata.addChange(path, value);\n            },\n        }),\n    };\n}\nfunction parseProjectsObject(projectsNode, context) {\n    const projects = Object.create(null);\n    for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(projectsNode))) {\n        const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectsNode, [name]);\n        if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n            context.warn('Skipping invalid project value; expected an object.', value);\n            continue;\n        }\n        projects[name] = parseProject(name, nodes, context);\n    }\n    return projects;\n}\nfunction parseProject(projectName, projectNode, context) {\n    const jsonMetadata = context.metadata;\n    let targets;\n    let hasTargets = false;\n    let extensions;\n    let properties;\n    if (!context.trackChanges) {\n        // If not tracking changes, the parser will store the values directly in standard objects\n        extensions = Object.create(null);\n        properties = Object.create(null);\n    }\n    const projectNodeValue = (0, jsonc_parser_1.getNodeValue)(projectNode);\n    if (!('root' in projectNodeValue)) {\n        // TODO(alan-agius4): change this to error in v15.\n        context.warn(`Project \"${projectName}\" is missing a required property \"root\". This will become an error in the next major version.`, projectNodeValue);\n    }\n    for (const [name, value] of Object.entries(projectNodeValue)) {\n        switch (name) {\n            case 'targets':\n            case 'architect':\n                const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectNode, [name]);\n                if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n                    context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n                    break;\n                }\n                hasTargets = true;\n                targets = parseTargetsObject(projectName, nodes, context);\n                jsonMetadata.hasLegacyTargetsName = name === 'architect';\n                break;\n            case 'prefix':\n            case 'root':\n            case 'sourceRoot':\n                if (typeof value !== 'string') {\n                    context.warn(`Project property \"${name}\" should be a string.`, value);\n                }\n                if (properties) {\n                    properties[name] = value;\n                }\n                break;\n            default:\n                if (!context.unprefixedProjectExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                    context.warn(`Project '${projectName}' contains extension with invalid name (${name}).`, name);\n                }\n                if (extensions) {\n                    extensions[name] = value;\n                }\n                break;\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        collectionListener = (name, newValue, collection) => {\n            if (hasTargets) {\n                jsonMetadata.addChange(['projects', projectName, 'targets', name], newValue, 'target');\n            }\n            else {\n                jsonMetadata.addChange(['projects', projectName, 'targets'], collection, 'targetcollection');\n            }\n        };\n    }\n    const base = {\n        targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n            exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n            listener(path, value) {\n                jsonMetadata.addChange(['projects', projectName, ...path], value);\n            },\n        }),\n    };\n    const baseKeys = new Set(Object.keys(base));\n    const project = properties !== null && properties !== void 0 ? properties : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n        include: ['prefix', 'root', 'sourceRoot', ...baseKeys],\n        listener(path, value) {\n            if (!baseKeys.has(path[0])) {\n                jsonMetadata.addChange(['projects', projectName, ...path], value);\n            }\n        },\n    });\n    return Object.assign(project, base);\n}\nfunction parseTargetsObject(projectName, targetsNode, context) {\n    const jsonMetadata = context.metadata;\n    const targets = Object.create(null);\n    for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(targetsNode))) {\n        if (!(0, utils_1.isJsonObject)(value)) {\n            context.warn('Skipping invalid target value; expected an object.', value);\n            continue;\n        }\n        if (context.trackChanges) {\n            targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n                include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n                listener(path, value) {\n                    jsonMetadata.addChange(['projects', projectName, 'targets', name, ...path], value);\n                },\n            });\n        }\n        else {\n            targets[name] = value;\n        }\n    }\n    return targets;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,iBAAR,GAA4B,KAAK,CAAjC;;AACA,MAAMC,cAAc,GAAGC,OAAO,CAAC,cAAD,CAA9B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMK,4BAA4B,GAAGX,MAAM,CAACY,MAAP,CAAc,CAC/C,KAD+C,EAE/C,gBAF+C,EAG/C,gBAH+C,EAI/C,YAJ+C,CAAd,CAArC;AAMA,MAAMC,0BAA0B,GAAGb,MAAM,CAACY,MAAP,CAAc,CAAC,KAAD,EAAQ,YAAR,EAAsB,aAAtB,EAAqC,MAArC,CAAd,CAAnC;;SACeR,iB;;;;;yCAAf,WAAiCU,IAAjC,EAAuCC,IAAvC,EAA6CC,OAAO,GAAG,EAAvD,EAA2D;IACvD,IAAIC,EAAJ,EAAQC,EAAR;;IACA,MAAMC,GAAG,SAASJ,IAAI,CAACK,QAAL,CAAcN,IAAd,CAAlB;;IACA,IAAIK,GAAG,KAAKE,SAAZ,EAAuB;MACnB,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;IACH;;IACD,MAAMC,GAAG,GAAG,CAAC,GAAGlB,cAAc,CAACmB,SAAnB,EAA8BL,GAA9B,EAAmCE,SAAnC,EAA8C;MAAEI,kBAAkB,EAAE,IAAtB;MAA4BC,gBAAgB,EAAE;IAA9C,CAA9C,CAAZ;;IACA,IAAI,CAACH,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,KAAK,CAA7B,GAAiC,KAAK,CAAtC,GAA0CA,GAAG,CAACI,IAA/C,MAAyD,QAAzD,IAAqE,CAACJ,GAAG,CAACK,QAA9E,EAAwF;MACpF,MAAM,IAAIN,KAAJ,CAAU,gDAAV,CAAN;IACH,CATsD,CAUvD;;;IACA,MAAMO,WAAW,GAAG,CAAC,GAAGxB,cAAc,CAACyB,kBAAnB,EAAuCP,GAAvC,EAA4C,CAAC,SAAD,CAA5C,CAApB;;IACA,IAAI,CAACM,WAAL,EAAkB;MACd,MAAM,IAAIP,KAAJ,CAAU,+CAAV,CAAN;IACH;;IACD,MAAMS,OAAO,GAAGF,WAAW,CAAC1B,KAA5B;;IACA,IAAI4B,OAAO,KAAK,CAAhB,EAAmB;MACf,MAAM,IAAIT,KAAJ,CAAW,6DAA4DS,OAAQ,IAA/E,CAAN;IACH;;IACD,MAAMC,OAAO,GAAG;MACZjB,IADY;MAEZkB,QAAQ,EAAE,IAAIxB,UAAU,CAACyB,qBAAf,CAAqCpB,IAArC,EAA2CS,GAA3C,EAAgDJ,GAAhD,CAFE;MAGZgB,YAAY,EAAE,IAHF;MAIZC,6BAA6B,EAAE,IAAIC,GAAJ,CAAQ,CACnC,GAAG1B,4BADgC,EAEnC,IAAI,CAACM,EAAE,GAAGD,OAAO,CAACsB,0BAAd,MAA8C,IAA9C,IAAsDrB,EAAE,KAAK,KAAK,CAAlE,GAAsEA,EAAtE,GAA2E,EAA/E,CAFmC,CAAR,CAJnB;MAQZsB,2BAA2B,EAAE,IAAIF,GAAJ,CAAQ,CACjC,GAAGxB,0BAD8B,EAEjC,IAAI,CAACK,EAAE,GAAGF,OAAO,CAACwB,wBAAd,MAA4C,IAA5C,IAAoDtB,EAAE,KAAK,KAAK,CAAhE,GAAoEA,EAApE,GAAyE,EAA7E,CAFiC,CAAR,CARjB;;MAYZuB,KAAK,CAACC,OAAD,EAAUC,KAAV,EAAiB;QAClB;QACA,MAAM,IAAIrB,KAAJ,CAAUoB,OAAV,CAAN;MACH,CAfW;;MAgBZE,IAAI,CAACF,OAAD,EAAUC,KAAV,EAAiB;QACjB;QACA;QACAE,OAAO,CAACD,IAAR,CAAaF,OAAb;MACH;;IApBW,CAAhB;IAsBA,MAAMI,SAAS,GAAGC,cAAc,CAACxB,GAAD,EAAMS,OAAN,CAAhC;IACA,OAAOc,SAAP;EACH,C;;;;AACD5C,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B;;AACA,SAAS2C,cAAT,CAAwBC,aAAxB,EAAuChB,OAAvC,EAAgD;EAC5C,MAAMiB,YAAY,GAAGjB,OAAO,CAACC,QAA7B;EACA,IAAIiB,QAAJ;EACA,IAAIC,UAAJ;;EACA,IAAI,CAACnB,OAAO,CAACG,YAAb,EAA2B;IACvBgB,UAAU,GAAGnD,MAAM,CAACoD,MAAP,CAAc,IAAd,CAAb;EACH,CAN2C,CAO5C;EACA;;;EACA,MAAMC,kBAAkB,GAAG,CAAC,GAAGhD,cAAc,CAACiD,YAAnB,EAAiCN,aAAjC,CAA3B;;EACA,KAAK,MAAM,CAACO,IAAD,EAAOpD,KAAP,CAAX,IAA4BH,MAAM,CAACwD,OAAP,CAAeH,kBAAf,CAA5B,EAAgE;IAC5D,IAAIE,IAAI,KAAK,SAAT,IAAsBA,IAAI,KAAK,SAAnC,EAA8C,CAC1C;IACH,CAFD,MAGK,IAAIA,IAAI,KAAK,UAAb,EAAyB;MAC1B,MAAME,KAAK,GAAG,CAAC,GAAGpD,cAAc,CAACyB,kBAAnB,EAAuCkB,aAAvC,EAAsD,CAAC,UAAD,CAAtD,CAAd;;MACA,IAAI,CAAC,CAAC,GAAGzC,OAAO,CAACmD,YAAZ,EAA0BvD,KAA1B,CAAD,IAAqC,CAACsD,KAA1C,EAAiD;QAC7CzB,OAAO,CAACS,KAAR,CAAc,qDAAd,EAAqEtC,KAArE;QACA;MACH;;MACD+C,QAAQ,GAAGS,mBAAmB,CAACF,KAAD,EAAQzB,OAAR,CAA9B;IACH,CAPI,MAQA;MACD,IAAI,CAACA,OAAO,CAACI,6BAAR,CAAsCwB,GAAtC,CAA0CL,IAA1C,CAAD,IAAoD,CAAC,iBAAiBM,IAAjB,CAAsBN,IAAtB,CAAzD,EAAsF;QAClFvB,OAAO,CAACY,IAAR,CAAc,0CAAyCW,IAAK,UAA5D,EAAuEA,IAAvE;MACH;;MACD,IAAIJ,UAAJ,EAAgB;QACZA,UAAU,CAACI,IAAD,CAAV,GAAmBpD,KAAnB;MACH;IACJ;EACJ;;EACD,IAAI2D,kBAAJ;;EACA,IAAI9B,OAAO,CAACG,YAAZ,EAA0B;IACtB2B,kBAAkB,GAAG,CAACP,IAAD,EAAOQ,QAAP,KAAoB;MACrCd,YAAY,CAACe,SAAb,CAAuB,CAAC,UAAD,EAAaT,IAAb,CAAvB,EAA2CQ,QAA3C,EAAqD,SAArD;IACH,CAFD;EAGH;;EACD,MAAME,iBAAiB,GAAG,IAAIzD,aAAa,CAAC0D,2BAAlB,CAA8ChB,QAA9C,EAAwDY,kBAAxD,CAA1B;EACA,OAAO;IACH,CAACrD,UAAU,CAAC0D,mBAAZ,GAAkClB,YAD/B;IAEHC,QAAQ,EAAEe,iBAFP;IAGH;IACA;IACAd,UAAU,EAAEA,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+CA,UAA/C,GAA4D,CAAC,GAAGzC,WAAW,CAAC0D,sBAAhB,EAAwCf,kBAAxC,EAA4D;MAChIgB,OAAO,EAAE,CAAC,SAAD,EAAY,SAAZ,EAAuB,UAAvB,CADuH;;MAEhIC,QAAQ,CAACxD,IAAD,EAAOX,KAAP,EAAc;QAClB8C,YAAY,CAACe,SAAb,CAAuBlD,IAAvB,EAA6BX,KAA7B;MACH;;IAJ+H,CAA5D;EALrE,CAAP;AAYH;;AACD,SAASwD,mBAAT,CAA6BY,YAA7B,EAA2CvC,OAA3C,EAAoD;EAChD,MAAMkB,QAAQ,GAAGlD,MAAM,CAACoD,MAAP,CAAc,IAAd,CAAjB;;EACA,KAAK,MAAM,CAACG,IAAD,EAAOpD,KAAP,CAAX,IAA4BH,MAAM,CAACwD,OAAP,CAAe,CAAC,GAAGnD,cAAc,CAACiD,YAAnB,EAAiCiB,YAAjC,CAAf,CAA5B,EAA4F;IACxF,MAAMd,KAAK,GAAG,CAAC,GAAGpD,cAAc,CAACyB,kBAAnB,EAAuCyC,YAAvC,EAAqD,CAAChB,IAAD,CAArD,CAAd;;IACA,IAAI,CAAC,CAAC,GAAGhD,OAAO,CAACmD,YAAZ,EAA0BvD,KAA1B,CAAD,IAAqC,CAACsD,KAA1C,EAAiD;MAC7CzB,OAAO,CAACY,IAAR,CAAa,qDAAb,EAAoEzC,KAApE;MACA;IACH;;IACD+C,QAAQ,CAACK,IAAD,CAAR,GAAiBiB,YAAY,CAACjB,IAAD,EAAOE,KAAP,EAAczB,OAAd,CAA7B;EACH;;EACD,OAAOkB,QAAP;AACH;;AACD,SAASsB,YAAT,CAAsBC,WAAtB,EAAmCC,WAAnC,EAAgD1C,OAAhD,EAAyD;EACrD,MAAMiB,YAAY,GAAGjB,OAAO,CAACC,QAA7B;EACA,IAAI0C,OAAJ;EACA,IAAIC,UAAU,GAAG,KAAjB;EACA,IAAIzB,UAAJ;EACA,IAAI0B,UAAJ;;EACA,IAAI,CAAC7C,OAAO,CAACG,YAAb,EAA2B;IACvB;IACAgB,UAAU,GAAGnD,MAAM,CAACoD,MAAP,CAAc,IAAd,CAAb;IACAyB,UAAU,GAAG7E,MAAM,CAACoD,MAAP,CAAc,IAAd,CAAb;EACH;;EACD,MAAM0B,gBAAgB,GAAG,CAAC,GAAGzE,cAAc,CAACiD,YAAnB,EAAiCoB,WAAjC,CAAzB;;EACA,IAAI,EAAE,UAAUI,gBAAZ,CAAJ,EAAmC;IAC/B;IACA9C,OAAO,CAACY,IAAR,CAAc,YAAW6B,WAAY,+FAArC,EAAqIK,gBAArI;EACH;;EACD,KAAK,MAAM,CAACvB,IAAD,EAAOpD,KAAP,CAAX,IAA4BH,MAAM,CAACwD,OAAP,CAAesB,gBAAf,CAA5B,EAA8D;IAC1D,QAAQvB,IAAR;MACI,KAAK,SAAL;MACA,KAAK,WAAL;QACI,MAAME,KAAK,GAAG,CAAC,GAAGpD,cAAc,CAACyB,kBAAnB,EAAuC4C,WAAvC,EAAoD,CAACnB,IAAD,CAApD,CAAd;;QACA,IAAI,CAAC,CAAC,GAAGhD,OAAO,CAACmD,YAAZ,EAA0BvD,KAA1B,CAAD,IAAqC,CAACsD,KAA1C,EAAiD;UAC7CzB,OAAO,CAACS,KAAR,CAAe,YAAWc,IAAK,oCAA/B,EAAoEpD,KAApE;UACA;QACH;;QACDyE,UAAU,GAAG,IAAb;QACAD,OAAO,GAAGI,kBAAkB,CAACN,WAAD,EAAchB,KAAd,EAAqBzB,OAArB,CAA5B;QACAiB,YAAY,CAAC+B,oBAAb,GAAoCzB,IAAI,KAAK,WAA7C;QACA;;MACJ,KAAK,QAAL;MACA,KAAK,MAAL;MACA,KAAK,YAAL;QACI,IAAI,OAAOpD,KAAP,KAAiB,QAArB,EAA+B;UAC3B6B,OAAO,CAACY,IAAR,CAAc,qBAAoBW,IAAK,uBAAvC,EAA+DpD,KAA/D;QACH;;QACD,IAAI0E,UAAJ,EAAgB;UACZA,UAAU,CAACtB,IAAD,CAAV,GAAmBpD,KAAnB;QACH;;QACD;;MACJ;QACI,IAAI,CAAC6B,OAAO,CAACO,2BAAR,CAAoCqB,GAApC,CAAwCL,IAAxC,CAAD,IAAkD,CAAC,iBAAiBM,IAAjB,CAAsBN,IAAtB,CAAvD,EAAoF;UAChFvB,OAAO,CAACY,IAAR,CAAc,YAAW6B,WAAY,2CAA0ClB,IAAK,IAApF,EAAyFA,IAAzF;QACH;;QACD,IAAIJ,UAAJ,EAAgB;UACZA,UAAU,CAACI,IAAD,CAAV,GAAmBpD,KAAnB;QACH;;QACD;IA7BR;EA+BH;;EACD,IAAI2D,kBAAJ;;EACA,IAAI9B,OAAO,CAACG,YAAZ,EAA0B;IACtB2B,kBAAkB,GAAG,CAACP,IAAD,EAAOQ,QAAP,EAAiBkB,UAAjB,KAAgC;MACjD,IAAIL,UAAJ,EAAgB;QACZ3B,YAAY,CAACe,SAAb,CAAuB,CAAC,UAAD,EAAaS,WAAb,EAA0B,SAA1B,EAAqClB,IAArC,CAAvB,EAAmEQ,QAAnE,EAA6E,QAA7E;MACH,CAFD,MAGK;QACDd,YAAY,CAACe,SAAb,CAAuB,CAAC,UAAD,EAAaS,WAAb,EAA0B,SAA1B,CAAvB,EAA6DQ,UAA7D,EAAyE,kBAAzE;MACH;IACJ,CAPD;EAQH;;EACD,MAAMC,IAAI,GAAG;IACTP,OAAO,EAAE,IAAInE,aAAa,CAAC2E,0BAAlB,CAA6CR,OAA7C,EAAsDb,kBAAtD,CADA;IAET;IACA;IACAX,UAAU,EAAEA,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+CA,UAA/C,GAA4D,CAAC,GAAGzC,WAAW,CAAC0D,sBAAhB,EAAwCU,gBAAxC,EAA0D;MAC9HT,OAAO,EAAE,CAAC,WAAD,EAAc,QAAd,EAAwB,MAAxB,EAAgC,YAAhC,EAA8C,SAA9C,CADqH;;MAE9HC,QAAQ,CAACxD,IAAD,EAAOX,KAAP,EAAc;QAClB8C,YAAY,CAACe,SAAb,CAAuB,CAAC,UAAD,EAAaS,WAAb,EAA0B,GAAG3D,IAA7B,CAAvB,EAA2DX,KAA3D;MACH;;IAJ6H,CAA1D;EAJ/D,CAAb;EAWA,MAAMiF,QAAQ,GAAG,IAAI/C,GAAJ,CAAQrC,MAAM,CAACqF,IAAP,CAAYH,IAAZ,CAAR,CAAjB;EACA,MAAMI,OAAO,GAAGT,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+CA,UAA/C,GAA4D,CAAC,GAAGnE,WAAW,CAAC0D,sBAAhB,EAAwCU,gBAAxC,EAA0D;IAClIS,OAAO,EAAE,CAAC,QAAD,EAAW,MAAX,EAAmB,YAAnB,EAAiC,GAAGH,QAApC,CADyH;;IAElId,QAAQ,CAACxD,IAAD,EAAOX,KAAP,EAAc;MAClB,IAAI,CAACiF,QAAQ,CAACxB,GAAT,CAAa9C,IAAI,CAAC,CAAD,CAAjB,CAAL,EAA4B;QACxBmC,YAAY,CAACe,SAAb,CAAuB,CAAC,UAAD,EAAaS,WAAb,EAA0B,GAAG3D,IAA7B,CAAvB,EAA2DX,KAA3D;MACH;IACJ;;EANiI,CAA1D,CAA5E;EAQA,OAAOH,MAAM,CAACwF,MAAP,CAAcF,OAAd,EAAuBJ,IAAvB,CAAP;AACH;;AACD,SAASH,kBAAT,CAA4BN,WAA5B,EAAyCgB,WAAzC,EAAsDzD,OAAtD,EAA+D;EAC3D,MAAMiB,YAAY,GAAGjB,OAAO,CAACC,QAA7B;EACA,MAAM0C,OAAO,GAAG3E,MAAM,CAACoD,MAAP,CAAc,IAAd,CAAhB;;EACA,KAAK,MAAM,CAACG,IAAD,EAAOpD,KAAP,CAAX,IAA4BH,MAAM,CAACwD,OAAP,CAAe,CAAC,GAAGnD,cAAc,CAACiD,YAAnB,EAAiCmC,WAAjC,CAAf,CAA5B,EAA2F;IACvF,IAAI,CAAC,CAAC,GAAGlF,OAAO,CAACmD,YAAZ,EAA0BvD,KAA1B,CAAL,EAAuC;MACnC6B,OAAO,CAACY,IAAR,CAAa,oDAAb,EAAmEzC,KAAnE;MACA;IACH;;IACD,IAAI6B,OAAO,CAACG,YAAZ,EAA0B;MACtBwC,OAAO,CAACpB,IAAD,CAAP,GAAgB,CAAC,GAAG7C,WAAW,CAAC0D,sBAAhB,EAAwCjE,KAAxC,EAA+C;QAC3DoF,OAAO,EAAE,CAAC,SAAD,EAAY,SAAZ,EAAuB,gBAAvB,EAAyC,sBAAzC,CADkD;;QAE3DjB,QAAQ,CAACxD,IAAD,EAAOX,KAAP,EAAc;UAClB8C,YAAY,CAACe,SAAb,CAAuB,CAAC,UAAD,EAAaS,WAAb,EAA0B,SAA1B,EAAqClB,IAArC,EAA2C,GAAGzC,IAA9C,CAAvB,EAA4EX,KAA5E;QACH;;MAJ0D,CAA/C,CAAhB;IAMH,CAPD,MAQK;MACDwE,OAAO,CAACpB,IAAD,CAAP,GAAgBpD,KAAhB;IACH;EACJ;;EACD,OAAOwE,OAAP;AACH"},"metadata":{},"sourceType":"script"}