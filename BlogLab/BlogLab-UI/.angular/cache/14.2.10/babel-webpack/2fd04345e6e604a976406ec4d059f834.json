{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpdateBuffer2 = exports.UpdateBuffer = exports.UpdateBufferBase = exports.Chunk = exports.ContentCannotBeRemovedException = exports.IndexOutOfBoundException = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\n\nconst environment_options_1 = require(\"./environment-options\");\n\nconst linked_list_1 = require(\"./linked-list\");\n\nclass IndexOutOfBoundException extends core_1.BaseException {\n  constructor(index, min, max = Infinity) {\n    super(`Index ${index} outside of range [${min}, ${max}].`);\n  }\n\n}\n\nexports.IndexOutOfBoundException = IndexOutOfBoundException;\n/** @deprecated Since v13.0 */\n\nclass ContentCannotBeRemovedException extends core_1.BaseException {\n  constructor() {\n    super(`User tried to remove content that was marked essential.`);\n  }\n\n}\n\nexports.ContentCannotBeRemovedException = ContentCannotBeRemovedException;\n/**\n * A Chunk description, including left/right content that has been inserted.\n * If _left/_right is null, this means that content was deleted. If the _content is null,\n * it means the content itself was deleted.\n *\n * @see UpdateBuffer\n * @deprecated Since v13.0\n */\n\nclass Chunk {\n  constructor(start, end, originalContent) {\n    this.start = start;\n    this.end = end;\n    this.originalContent = originalContent;\n    this._left = Buffer.alloc(0);\n    this._right = Buffer.alloc(0);\n    this._assertLeft = false;\n    this._assertRight = false;\n    this.next = null;\n    this._content = originalContent.slice(start, end);\n  }\n\n  get length() {\n    return (this._left ? this._left.length : 0) + (this._content ? this._content.length : 0) + (this._right ? this._right.length : 0);\n  }\n\n  toString(encoding = 'utf-8') {\n    return (this._left ? this._left.toString(encoding) : '') + (this._content ? this._content.toString(encoding) : '') + (this._right ? this._right.toString(encoding) : '');\n  }\n\n  slice(start) {\n    if (start < this.start || start > this.end) {\n      throw new IndexOutOfBoundException(start, this.start, this.end);\n    } // Update _content to the new indices.\n\n\n    const newChunk = new Chunk(start, this.end, this.originalContent); // If this chunk has _content, reslice the original _content. We move the _right so we are not\n    // losing any data here. If this chunk has been deleted, the next chunk should also be deleted.\n\n    if (this._content) {\n      this._content = this.originalContent.slice(this.start, start);\n    } else {\n      newChunk._content = this._content;\n\n      if (this._right === null) {\n        newChunk._left = null;\n      }\n    }\n\n    this.end = start; // Move _right to the new chunk.\n\n    newChunk._right = this._right;\n    this._right = this._right && Buffer.alloc(0); // Update essentials.\n\n    if (this._assertRight) {\n      newChunk._assertRight = true;\n      this._assertRight = false;\n    } // Update the linked list.\n\n\n    newChunk.next = this.next;\n    this.next = newChunk;\n    return newChunk;\n  }\n\n  append(buffer, essential) {\n    if (!this._right) {\n      if (essential) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      return;\n    }\n\n    const outro = this._right;\n    this._right = Buffer.alloc(outro.length + buffer.length);\n    outro.copy(this._right, 0);\n    buffer.copy(this._right, outro.length);\n\n    if (essential) {\n      this._assertRight = true;\n    }\n  }\n\n  prepend(buffer, essential) {\n    if (!this._left) {\n      if (essential) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      return;\n    }\n\n    const intro = this._left;\n    this._left = Buffer.alloc(intro.length + buffer.length);\n    intro.copy(this._left, 0);\n    buffer.copy(this._left, intro.length);\n\n    if (essential) {\n      this._assertLeft = true;\n    }\n  }\n\n  assert(left, _content, right) {\n    if (left && this._assertLeft) {\n      throw new ContentCannotBeRemovedException();\n    }\n\n    if (right && this._assertRight) {\n      throw new ContentCannotBeRemovedException();\n    }\n  }\n\n  remove(left, content, right) {\n    if (left) {\n      if (this._assertLeft) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      this._left = null;\n    }\n\n    if (content) {\n      this._content = null;\n    }\n\n    if (right) {\n      if (this._assertRight) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      this._right = null;\n    }\n  }\n\n  copy(target, start) {\n    if (this._left) {\n      this._left.copy(target, start);\n\n      start += this._left.length;\n    }\n\n    if (this._content) {\n      this._content.copy(target, start);\n\n      start += this._content.length;\n    }\n\n    if (this._right) {\n      this._right.copy(target, start);\n\n      start += this._right.length;\n    }\n\n    return start;\n  }\n\n}\n\nexports.Chunk = Chunk;\n/**\n * Base class for an update buffer implementation that allows buffers to be inserted to the _right\n * or _left, or deleted, while keeping indices to the original buffer.\n */\n\nclass UpdateBufferBase {\n  constructor(_originalContent) {\n    this._originalContent = _originalContent;\n  }\n  /**\n   * Creates an UpdateBufferBase instance. Depending on the NG_UPDATE_BUFFER_V2\n   * environment variable, will either create an UpdateBuffer or an UpdateBuffer2\n   * instance.\n   *\n   * See: https://github.com/angular/angular-cli/issues/21110\n   *\n   * @param originalContent The original content of the update buffer instance.\n   * @returns An UpdateBufferBase instance.\n   */\n\n\n  static create(originalContent) {\n    return environment_options_1.updateBufferV2Enabled ? new UpdateBuffer2(originalContent) : new UpdateBuffer(originalContent);\n  }\n\n}\n\nexports.UpdateBufferBase = UpdateBufferBase;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n *\n * The constructor takes an original buffer, and keeps it into a linked list of chunks, smaller\n * buffers that keep track of _content inserted to the _right or _left of it.\n *\n * Since the Node Buffer structure is non-destructive when slicing, we try to use slicing to create\n * new chunks, and always keep chunks pointing to the original content.\n *\n * @deprecated Since v13.0\n */\n\nclass UpdateBuffer extends UpdateBufferBase {\n  constructor(originalContent) {\n    super(originalContent);\n    this._linkedList = new linked_list_1.LinkedList(new Chunk(0, originalContent.length, originalContent));\n  }\n\n  _assertIndex(index) {\n    if (index < 0 || index > this._originalContent.length) {\n      throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n    }\n  }\n\n  _slice(start) {\n    let index;\n\n    if (start >= this._originalContent.length) {\n      index = start;\n    } else if (start < 0) {\n      index = this._originalContent.length + start;\n    } else {\n      index = this._getTextPosition(start);\n    }\n\n    this._assertIndex(index); // Find the chunk by going through the list.\n\n\n    const h = this._linkedList.find(chunk => index <= chunk.end);\n\n    if (!h) {\n      throw Error('Chunk cannot be found.');\n    }\n\n    if (index == h.end && h.next !== null) {\n      return [h, h.next];\n    }\n\n    return [h, h.slice(index)];\n  }\n  /**\n   * Gets the position in the content based on the position in the string.\n   * Some characters might be wider than one byte, thus we have to determine the position using\n   * string functions.\n   */\n\n\n  _getTextPosition(index) {\n    return Buffer.from(this._originalContent.toString().substring(0, index)).length;\n  }\n\n  get length() {\n    return this._linkedList.reduce((acc, chunk) => acc + chunk.length, 0);\n  }\n\n  get original() {\n    return this._originalContent;\n  }\n\n  toString(encoding = 'utf-8') {\n    return this._linkedList.reduce((acc, chunk) => acc + chunk.toString(encoding), '');\n  }\n\n  generate() {\n    const result = Buffer.allocUnsafe(this.length);\n    let i = 0;\n\n    this._linkedList.forEach(chunk => {\n      chunk.copy(result, i);\n      i += chunk.length;\n    });\n\n    return result;\n  }\n\n  insertLeft(index, content, assert = false) {\n    this._slice(index)[0].append(content, assert);\n  }\n\n  insertRight(index, content, assert = false) {\n    this._slice(index)[1].prepend(content, assert);\n  }\n\n  remove(index, length) {\n    if (length === 0) {\n      return;\n    }\n\n    const end = index + length;\n\n    const first = this._slice(index)[1];\n\n    const last = this._slice(end)[1];\n\n    let curr;\n\n    for (curr = first; curr && curr !== last; curr = curr.next) {\n      curr.assert(curr !== first, curr !== last, curr === first);\n    }\n\n    for (curr = first; curr && curr !== last; curr = curr.next) {\n      curr.remove(curr !== first, curr !== last, curr === first);\n    }\n\n    if (curr) {\n      curr.remove(true, false, false);\n    }\n  }\n\n}\n\nexports.UpdateBuffer = UpdateBuffer;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n */\n\nclass UpdateBuffer2 extends UpdateBufferBase {\n  constructor() {\n    super(...arguments);\n    this._mutatableContent = new magic_string_1.default(this._originalContent.toString());\n  }\n\n  _assertIndex(index) {\n    if (index < 0 || index > this._originalContent.length) {\n      throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n    }\n  }\n\n  get length() {\n    return this._mutatableContent.length();\n  }\n\n  get original() {\n    return this._originalContent;\n  }\n\n  toString() {\n    return this._mutatableContent.toString();\n  }\n\n  generate() {\n    return Buffer.from(this.toString());\n  }\n\n  insertLeft(index, content) {\n    this._assertIndex(index);\n\n    this._mutatableContent.appendLeft(index, content.toString());\n  }\n\n  insertRight(index, content) {\n    this._assertIndex(index);\n\n    this._mutatableContent.appendRight(index, content.toString());\n  }\n\n  remove(index, length) {\n    this._assertIndex(index);\n\n    this._mutatableContent.remove(index, index + length);\n  }\n\n}\n\nexports.UpdateBuffer2 = UpdateBuffer2;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","UpdateBuffer2","UpdateBuffer","UpdateBufferBase","Chunk","ContentCannotBeRemovedException","IndexOutOfBoundException","core_1","require","magic_string_1","environment_options_1","linked_list_1","BaseException","constructor","index","min","max","Infinity","start","end","originalContent","_left","Buffer","alloc","_right","_assertLeft","_assertRight","next","_content","slice","length","toString","encoding","newChunk","append","buffer","essential","outro","copy","prepend","intro","assert","left","right","remove","content","target","_originalContent","create","updateBufferV2Enabled","_linkedList","LinkedList","_assertIndex","_slice","_getTextPosition","h","find","chunk","Error","from","substring","reduce","acc","original","generate","result","allocUnsafe","i","forEach","insertLeft","insertRight","first","last","curr","arguments","_mutatableContent","default","appendLeft","appendRight"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/schematics/src/utility/update-buffer.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdateBuffer2 = exports.UpdateBuffer = exports.UpdateBufferBase = exports.Chunk = exports.ContentCannotBeRemovedException = exports.IndexOutOfBoundException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\nconst environment_options_1 = require(\"./environment-options\");\nconst linked_list_1 = require(\"./linked-list\");\nclass IndexOutOfBoundException extends core_1.BaseException {\n    constructor(index, min, max = Infinity) {\n        super(`Index ${index} outside of range [${min}, ${max}].`);\n    }\n}\nexports.IndexOutOfBoundException = IndexOutOfBoundException;\n/** @deprecated Since v13.0 */\nclass ContentCannotBeRemovedException extends core_1.BaseException {\n    constructor() {\n        super(`User tried to remove content that was marked essential.`);\n    }\n}\nexports.ContentCannotBeRemovedException = ContentCannotBeRemovedException;\n/**\n * A Chunk description, including left/right content that has been inserted.\n * If _left/_right is null, this means that content was deleted. If the _content is null,\n * it means the content itself was deleted.\n *\n * @see UpdateBuffer\n * @deprecated Since v13.0\n */\nclass Chunk {\n    constructor(start, end, originalContent) {\n        this.start = start;\n        this.end = end;\n        this.originalContent = originalContent;\n        this._left = Buffer.alloc(0);\n        this._right = Buffer.alloc(0);\n        this._assertLeft = false;\n        this._assertRight = false;\n        this.next = null;\n        this._content = originalContent.slice(start, end);\n    }\n    get length() {\n        return ((this._left ? this._left.length : 0) +\n            (this._content ? this._content.length : 0) +\n            (this._right ? this._right.length : 0));\n    }\n    toString(encoding = 'utf-8') {\n        return ((this._left ? this._left.toString(encoding) : '') +\n            (this._content ? this._content.toString(encoding) : '') +\n            (this._right ? this._right.toString(encoding) : ''));\n    }\n    slice(start) {\n        if (start < this.start || start > this.end) {\n            throw new IndexOutOfBoundException(start, this.start, this.end);\n        }\n        // Update _content to the new indices.\n        const newChunk = new Chunk(start, this.end, this.originalContent);\n        // If this chunk has _content, reslice the original _content. We move the _right so we are not\n        // losing any data here. If this chunk has been deleted, the next chunk should also be deleted.\n        if (this._content) {\n            this._content = this.originalContent.slice(this.start, start);\n        }\n        else {\n            newChunk._content = this._content;\n            if (this._right === null) {\n                newChunk._left = null;\n            }\n        }\n        this.end = start;\n        // Move _right to the new chunk.\n        newChunk._right = this._right;\n        this._right = this._right && Buffer.alloc(0);\n        // Update essentials.\n        if (this._assertRight) {\n            newChunk._assertRight = true;\n            this._assertRight = false;\n        }\n        // Update the linked list.\n        newChunk.next = this.next;\n        this.next = newChunk;\n        return newChunk;\n    }\n    append(buffer, essential) {\n        if (!this._right) {\n            if (essential) {\n                throw new ContentCannotBeRemovedException();\n            }\n            return;\n        }\n        const outro = this._right;\n        this._right = Buffer.alloc(outro.length + buffer.length);\n        outro.copy(this._right, 0);\n        buffer.copy(this._right, outro.length);\n        if (essential) {\n            this._assertRight = true;\n        }\n    }\n    prepend(buffer, essential) {\n        if (!this._left) {\n            if (essential) {\n                throw new ContentCannotBeRemovedException();\n            }\n            return;\n        }\n        const intro = this._left;\n        this._left = Buffer.alloc(intro.length + buffer.length);\n        intro.copy(this._left, 0);\n        buffer.copy(this._left, intro.length);\n        if (essential) {\n            this._assertLeft = true;\n        }\n    }\n    assert(left, _content, right) {\n        if (left && this._assertLeft) {\n            throw new ContentCannotBeRemovedException();\n        }\n        if (right && this._assertRight) {\n            throw new ContentCannotBeRemovedException();\n        }\n    }\n    remove(left, content, right) {\n        if (left) {\n            if (this._assertLeft) {\n                throw new ContentCannotBeRemovedException();\n            }\n            this._left = null;\n        }\n        if (content) {\n            this._content = null;\n        }\n        if (right) {\n            if (this._assertRight) {\n                throw new ContentCannotBeRemovedException();\n            }\n            this._right = null;\n        }\n    }\n    copy(target, start) {\n        if (this._left) {\n            this._left.copy(target, start);\n            start += this._left.length;\n        }\n        if (this._content) {\n            this._content.copy(target, start);\n            start += this._content.length;\n        }\n        if (this._right) {\n            this._right.copy(target, start);\n            start += this._right.length;\n        }\n        return start;\n    }\n}\nexports.Chunk = Chunk;\n/**\n * Base class for an update buffer implementation that allows buffers to be inserted to the _right\n * or _left, or deleted, while keeping indices to the original buffer.\n */\nclass UpdateBufferBase {\n    constructor(_originalContent) {\n        this._originalContent = _originalContent;\n    }\n    /**\n     * Creates an UpdateBufferBase instance. Depending on the NG_UPDATE_BUFFER_V2\n     * environment variable, will either create an UpdateBuffer or an UpdateBuffer2\n     * instance.\n     *\n     * See: https://github.com/angular/angular-cli/issues/21110\n     *\n     * @param originalContent The original content of the update buffer instance.\n     * @returns An UpdateBufferBase instance.\n     */\n    static create(originalContent) {\n        return environment_options_1.updateBufferV2Enabled\n            ? new UpdateBuffer2(originalContent)\n            : new UpdateBuffer(originalContent);\n    }\n}\nexports.UpdateBufferBase = UpdateBufferBase;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n *\n * The constructor takes an original buffer, and keeps it into a linked list of chunks, smaller\n * buffers that keep track of _content inserted to the _right or _left of it.\n *\n * Since the Node Buffer structure is non-destructive when slicing, we try to use slicing to create\n * new chunks, and always keep chunks pointing to the original content.\n *\n * @deprecated Since v13.0\n */\nclass UpdateBuffer extends UpdateBufferBase {\n    constructor(originalContent) {\n        super(originalContent);\n        this._linkedList = new linked_list_1.LinkedList(new Chunk(0, originalContent.length, originalContent));\n    }\n    _assertIndex(index) {\n        if (index < 0 || index > this._originalContent.length) {\n            throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n        }\n    }\n    _slice(start) {\n        let index;\n        if (start >= this._originalContent.length) {\n            index = start;\n        }\n        else if (start < 0) {\n            index = this._originalContent.length + start;\n        }\n        else {\n            index = this._getTextPosition(start);\n        }\n        this._assertIndex(index);\n        // Find the chunk by going through the list.\n        const h = this._linkedList.find((chunk) => index <= chunk.end);\n        if (!h) {\n            throw Error('Chunk cannot be found.');\n        }\n        if (index == h.end && h.next !== null) {\n            return [h, h.next];\n        }\n        return [h, h.slice(index)];\n    }\n    /**\n     * Gets the position in the content based on the position in the string.\n     * Some characters might be wider than one byte, thus we have to determine the position using\n     * string functions.\n     */\n    _getTextPosition(index) {\n        return Buffer.from(this._originalContent.toString().substring(0, index)).length;\n    }\n    get length() {\n        return this._linkedList.reduce((acc, chunk) => acc + chunk.length, 0);\n    }\n    get original() {\n        return this._originalContent;\n    }\n    toString(encoding = 'utf-8') {\n        return this._linkedList.reduce((acc, chunk) => acc + chunk.toString(encoding), '');\n    }\n    generate() {\n        const result = Buffer.allocUnsafe(this.length);\n        let i = 0;\n        this._linkedList.forEach((chunk) => {\n            chunk.copy(result, i);\n            i += chunk.length;\n        });\n        return result;\n    }\n    insertLeft(index, content, assert = false) {\n        this._slice(index)[0].append(content, assert);\n    }\n    insertRight(index, content, assert = false) {\n        this._slice(index)[1].prepend(content, assert);\n    }\n    remove(index, length) {\n        if (length === 0) {\n            return;\n        }\n        const end = index + length;\n        const first = this._slice(index)[1];\n        const last = this._slice(end)[1];\n        let curr;\n        for (curr = first; curr && curr !== last; curr = curr.next) {\n            curr.assert(curr !== first, curr !== last, curr === first);\n        }\n        for (curr = first; curr && curr !== last; curr = curr.next) {\n            curr.remove(curr !== first, curr !== last, curr === first);\n        }\n        if (curr) {\n            curr.remove(true, false, false);\n        }\n    }\n}\nexports.UpdateBuffer = UpdateBuffer;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n */\nclass UpdateBuffer2 extends UpdateBufferBase {\n    constructor() {\n        super(...arguments);\n        this._mutatableContent = new magic_string_1.default(this._originalContent.toString());\n    }\n    _assertIndex(index) {\n        if (index < 0 || index > this._originalContent.length) {\n            throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n        }\n    }\n    get length() {\n        return this._mutatableContent.length();\n    }\n    get original() {\n        return this._originalContent;\n    }\n    toString() {\n        return this._mutatableContent.toString();\n    }\n    generate() {\n        return Buffer.from(this.toString());\n    }\n    insertLeft(index, content) {\n        this._assertIndex(index);\n        this._mutatableContent.appendLeft(index, content.toString());\n    }\n    insertRight(index, content) {\n        this._assertIndex(index);\n        this._mutatableContent.appendRight(index, content.toString());\n    }\n    remove(index, length) {\n        this._assertIndex(index);\n        this._mutatableContent.remove(index, index + length);\n    }\n}\nexports.UpdateBuffer2 = UpdateBuffer2;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}