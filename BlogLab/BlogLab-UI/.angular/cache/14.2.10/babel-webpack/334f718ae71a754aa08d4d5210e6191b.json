{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst util = require('util');\n\nconst chownr = util.promisify(require('chownr'));\n\nconst mkdirp = require('mkdirp');\n\nconst inflight = require('promise-inflight');\n\nconst inferOwner = require('infer-owner'); // Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\n\n\nconst self = {\n  uid: null,\n  gid: null\n};\n\nconst getSelf = () => {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid();\n    const setuid = process.setuid;\n\n    process.setuid = uid => {\n      self.uid = null;\n      process.setuid = setuid;\n      return process.setuid(uid);\n    };\n  }\n\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid();\n    const setgid = process.setgid;\n\n    process.setgid = gid => {\n      self.gid = null;\n      process.setgid = setgid;\n      return process.setgid(gid);\n    };\n  }\n};\n\nmodule.exports.chownr = fixOwner;\n\nfunction fixOwner(_x, _x2) {\n  return _fixOwner.apply(this, arguments);\n}\n\nfunction _fixOwner() {\n  _fixOwner = _asyncToGenerator(function* (cache, filepath) {\n    if (!process.getuid) {\n      // This platform doesn't need ownership fixing\n      return;\n    }\n\n    getSelf();\n\n    if (self.uid !== 0) {\n      // almost certainly can't chown anyway\n      return;\n    }\n\n    const {\n      uid,\n      gid\n    } = yield inferOwner(cache); // No need to override if it's already what we used.\n\n    if (self.uid === uid && self.gid === gid) {\n      return;\n    }\n\n    return inflight('fixOwner: fixing ownership on ' + filepath, () => chownr(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid).catch(err => {\n      if (err.code === 'ENOENT') {\n        return null;\n      }\n\n      throw err;\n    }));\n  });\n  return _fixOwner.apply(this, arguments);\n}\n\nmodule.exports.chownr.sync = fixOwnerSync;\n\nfunction fixOwnerSync(cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return;\n  }\n\n  const {\n    uid,\n    gid\n  } = inferOwner.sync(cache);\n  getSelf();\n\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return;\n  }\n\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return;\n  }\n\n  try {\n    chownr.sync(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid);\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') {\n      return null;\n    }\n\n    throw err;\n  }\n}\n\nmodule.exports.mkdirfix = mkdirfix;\n\nfunction mkdirfix(_x3, _x4, _x5) {\n  return _mkdirfix.apply(this, arguments);\n}\n\nfunction _mkdirfix() {\n  _mkdirfix = _asyncToGenerator(function* (cache, p, cb) {\n    // we have to infer the owner _before_ making the directory, even though\n    // we aren't going to use the results, since the cache itself might not\n    // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n    // to be correct if it creates the cache folder in the process.\n    yield inferOwner(cache);\n\n    try {\n      const made = yield mkdirp(p);\n\n      if (made) {\n        yield fixOwner(cache, made);\n        return made;\n      }\n    } catch (err) {\n      if (err.code === 'EEXIST') {\n        yield fixOwner(cache, p);\n        return null;\n      }\n\n      throw err;\n    }\n  });\n  return _mkdirfix.apply(this, arguments);\n}\n\nmodule.exports.mkdirfix.sync = mkdirfixSync;\n\nfunction mkdirfixSync(cache, p) {\n  try {\n    inferOwner.sync(cache);\n    const made = mkdirp.sync(p);\n\n    if (made) {\n      fixOwnerSync(cache, made);\n      return made;\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p);\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"names":["util","require","chownr","promisify","mkdirp","inflight","inferOwner","self","uid","gid","getSelf","process","getuid","setuid","getgid","setgid","module","exports","fixOwner","cache","filepath","catch","err","code","sync","fixOwnerSync","mkdirfix","p","cb","made","mkdirfixSync"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/cacache/lib/util/fix-owner.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst chownr = util.promisify(require('chownr'))\nconst mkdirp = require('mkdirp')\nconst inflight = require('promise-inflight')\nconst inferOwner = require('infer-owner')\n\n// Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\nconst self = { uid: null, gid: null }\nconst getSelf = () => {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid()\n    const setuid = process.setuid\n    process.setuid = (uid) => {\n      self.uid = null\n      process.setuid = setuid\n      return process.setuid(uid)\n    }\n  }\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid()\n    const setgid = process.setgid\n    process.setgid = (gid) => {\n      self.gid = null\n      process.setgid = setgid\n      return process.setgid(gid)\n    }\n  }\n}\n\nmodule.exports.chownr = fixOwner\n\nasync function fixOwner (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return\n  }\n\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return\n  }\n\n  const { uid, gid } = await inferOwner(cache)\n\n  // No need to override if it's already what we used.\n  if (self.uid === uid && self.gid === gid) {\n    return\n  }\n\n  return inflight('fixOwner: fixing ownership on ' + filepath, () =>\n    chownr(\n      filepath,\n      typeof uid === 'number' ? uid : self.uid,\n      typeof gid === 'number' ? gid : self.gid\n    ).catch((err) => {\n      if (err.code === 'ENOENT') {\n        return null\n      }\n\n      throw err\n    })\n  )\n}\n\nmodule.exports.chownr.sync = fixOwnerSync\n\nfunction fixOwnerSync (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return\n  }\n  const { uid, gid } = inferOwner.sync(cache)\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return\n  }\n\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return\n  }\n  try {\n    chownr.sync(\n      filepath,\n      typeof uid === 'number' ? uid : self.uid,\n      typeof gid === 'number' ? gid : self.gid\n    )\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') {\n      return null\n    }\n\n    throw err\n  }\n}\n\nmodule.exports.mkdirfix = mkdirfix\n\nasync function mkdirfix (cache, p, cb) {\n  // we have to infer the owner _before_ making the directory, even though\n  // we aren't going to use the results, since the cache itself might not\n  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n  // to be correct if it creates the cache folder in the process.\n  await inferOwner(cache)\n  try {\n    const made = await mkdirp(p)\n    if (made) {\n      await fixOwner(cache, made)\n      return made\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      await fixOwner(cache, p)\n      return null\n    }\n    throw err\n  }\n}\n\nmodule.exports.mkdirfix.sync = mkdirfixSync\n\nfunction mkdirfixSync (cache, p) {\n  try {\n    inferOwner.sync(cache)\n    const made = mkdirp.sync(p)\n    if (made) {\n      fixOwnerSync(cache, made)\n      return made\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p)\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}