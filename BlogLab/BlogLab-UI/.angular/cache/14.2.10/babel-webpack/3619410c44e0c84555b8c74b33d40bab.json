{"ast":null,"code":"var _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst makeSpawnArgs = require('./make-spawn-args.js');\n\nconst promiseSpawn = require('@npmcli/promise-spawn');\n\nconst packageEnvs = require('./package-envs.js');\n\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript\n} = require('@npmcli/node-gyp');\n\nconst signalManager = require('./signal-manager.js');\n\nconst isServerPackage = require('./is-server-package.js'); // you wouldn't like me when I'm angry...\n\n\nconst bruce = (id, event, cmd, args) => {\n  let banner = id ? `\\n> ${id} ${event}\\n` : `\\n> ${event}\\n`;\n  banner += `> ${cmd.trim().replace(/\\n/g, '\\n> ')}`;\n\n  if (args.length) {\n    banner += ` ${args.join(' ')}`;\n  }\n\n  banner += '\\n';\n  return banner;\n};\n\nconst runScriptPkg = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (options) {\n    const {\n      event,\n      path,\n      scriptShell,\n      binPaths = false,\n      env = {},\n      stdio = 'pipe',\n      pkg,\n      args = [],\n      stdioString = false,\n      // note: only used when stdio:inherit\n      banner = true,\n      // how long to wait for a process.kill signal\n      // only exposed here so that we can make the test go a bit faster.\n      signalTimeout = 500\n    } = options;\n    const {\n      scripts = {},\n      gypfile\n    } = pkg;\n    let cmd = null;\n\n    if (options.cmd) {\n      cmd = options.cmd;\n    } else if (pkg.scripts && pkg.scripts[event]) {\n      cmd = pkg.scripts[event];\n    } else if ( // If there is no preinstall or install script, default to rebuilding node-gyp packages.\n    event === 'install' && !scripts.install && !scripts.preinstall && gypfile !== false && (yield isNodeGypPackage(path))) {\n      cmd = defaultGypInstallScript;\n    } else if (event === 'start' && (yield isServerPackage(path))) {\n      cmd = 'node server.js';\n    }\n\n    if (!cmd) {\n      return {\n        code: 0,\n        signal: null\n      };\n    }\n\n    if (stdio === 'inherit' && banner !== false) {\n      // we're dumping to the parent's stdout, so print the banner\n      console.log(bruce(pkg._id, event, cmd, args));\n    }\n\n    const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({\n      event,\n      path,\n      scriptShell,\n      binPaths,\n      env: packageEnvs(env, pkg),\n      stdio,\n      cmd,\n      args,\n      stdioString\n    });\n    const p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {\n      event,\n      script: cmd,\n      pkgid: pkg._id,\n      path\n    });\n\n    if (stdio === 'inherit') {\n      signalManager.add(p.process);\n    }\n\n    if (p.stdin) {\n      p.stdin.end();\n    }\n\n    return p.catch(er => {\n      const {\n        signal\n      } = er;\n\n      if (stdio === 'inherit' && signal) {\n        process.kill(process.pid, signal); // just in case we don't die, reject after 500ms\n        // this also keeps the node process open long enough to actually\n        // get the signal, rather than terminating gracefully.\n\n        return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout));\n      } else {\n        throw er;\n      }\n    });\n  });\n\n  return function runScriptPkg(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = runScriptPkg;","map":{"version":3,"names":["makeSpawnArgs","require","promiseSpawn","packageEnvs","isNodeGypPackage","defaultGypInstallScript","signalManager","isServerPackage","bruce","id","event","cmd","args","banner","trim","replace","length","join","runScriptPkg","options","path","scriptShell","binPaths","env","stdio","pkg","stdioString","signalTimeout","scripts","gypfile","install","preinstall","code","signal","console","log","_id","spawnShell","spawnArgs","spawnOpts","p","script","pkgid","add","process","stdin","end","catch","er","kill","pid","Promise","res","rej","setTimeout","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@npmcli/run-script/lib/run-script-pkg.js"],"sourcesContent":["const makeSpawnArgs = require('./make-spawn-args.js')\nconst promiseSpawn = require('@npmcli/promise-spawn')\nconst packageEnvs = require('./package-envs.js')\nconst { isNodeGypPackage, defaultGypInstallScript } = require('@npmcli/node-gyp')\nconst signalManager = require('./signal-manager.js')\nconst isServerPackage = require('./is-server-package.js')\n\n// you wouldn't like me when I'm angry...\nconst bruce = (id, event, cmd, args) => {\n  let banner = id\n    ? `\\n> ${id} ${event}\\n`\n    : `\\n> ${event}\\n`\n  banner += `> ${cmd.trim().replace(/\\n/g, '\\n> ')}`\n  if (args.length) {\n    banner += ` ${args.join(' ')}`\n  }\n  banner += '\\n'\n  return banner\n}\n\nconst runScriptPkg = async options => {\n  const {\n    event,\n    path,\n    scriptShell,\n    binPaths = false,\n    env = {},\n    stdio = 'pipe',\n    pkg,\n    args = [],\n    stdioString = false,\n    // note: only used when stdio:inherit\n    banner = true,\n    // how long to wait for a process.kill signal\n    // only exposed here so that we can make the test go a bit faster.\n    signalTimeout = 500,\n  } = options\n\n  const { scripts = {}, gypfile } = pkg\n  let cmd = null\n  if (options.cmd) {\n    cmd = options.cmd\n  } else if (pkg.scripts && pkg.scripts[event]) {\n    cmd = pkg.scripts[event]\n  } else if (\n    // If there is no preinstall or install script, default to rebuilding node-gyp packages.\n    event === 'install' &&\n    !scripts.install &&\n    !scripts.preinstall &&\n    gypfile !== false &&\n    await isNodeGypPackage(path)\n  ) {\n    cmd = defaultGypInstallScript\n  } else if (event === 'start' && await isServerPackage(path)) {\n    cmd = 'node server.js'\n  }\n\n  if (!cmd) {\n    return { code: 0, signal: null }\n  }\n\n  if (stdio === 'inherit' && banner !== false) {\n    // we're dumping to the parent's stdout, so print the banner\n    console.log(bruce(pkg._id, event, cmd, args))\n  }\n\n  const [spawnShell, spawnArgs, spawnOpts] = makeSpawnArgs({\n    event,\n    path,\n    scriptShell,\n    binPaths,\n    env: packageEnvs(env, pkg),\n    stdio,\n    cmd,\n    args,\n    stdioString,\n  })\n\n  const p = promiseSpawn(spawnShell, spawnArgs, spawnOpts, {\n    event,\n    script: cmd,\n    pkgid: pkg._id,\n    path,\n  })\n\n  if (stdio === 'inherit') {\n    signalManager.add(p.process)\n  }\n\n  if (p.stdin) {\n    p.stdin.end()\n  }\n\n  return p.catch(er => {\n    const { signal } = er\n    if (stdio === 'inherit' && signal) {\n      process.kill(process.pid, signal)\n      // just in case we don't die, reject after 500ms\n      // this also keeps the node process open long enough to actually\n      // get the signal, rather than terminating gracefully.\n      return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout))\n    } else {\n      throw er\n    }\n  })\n}\n\nmodule.exports = runScriptPkg\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}