{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst EE = require('events').EventEmitter;\n\nconst Minimatch = require('minimatch').Minimatch;\n\nclass Walker extends EE {\n  constructor(opts) {\n    opts = opts || {};\n    super(opts); // set to true if this.path is a symlink, whether follow is true or not\n\n    this.isSymbolicLink = opts.isSymbolicLink;\n    this.path = opts.path || process.cwd();\n    this.basename = path.basename(this.path);\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    this.ignoreRules = {};\n    this.parent = opts.parent || null;\n    this.includeEmpty = !!opts.includeEmpty;\n    this.root = this.parent ? this.parent.root : this.path;\n    this.follow = !!opts.follow;\n    this.result = this.parent ? this.parent.result : new Set();\n    this.entries = null;\n    this.sawError = false;\n  }\n\n  sort(a, b) {\n    return a.localeCompare(b, 'en');\n  }\n\n  emit(ev, data) {\n    let ret = false;\n\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true;\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data).map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort);\n        this.result = data;\n      }\n\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data);\n      } else {\n        ret = super.emit(ev, data);\n      }\n    }\n\n    return ret;\n  }\n\n  start() {\n    fs.readdir(this.path, (er, entries) => er ? this.emit('error', er) : this.onReaddir(entries));\n    return this;\n  }\n\n  isIgnoreFile(e) {\n    return e !== '.' && e !== '..' && this.ignoreFiles.indexOf(e) !== -1;\n  }\n\n  onReaddir(entries) {\n    this.entries = entries;\n\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.slice(this.root.length + 1));\n      }\n\n      this.emit('done', this.result);\n    } else {\n      const hasIg = this.entries.some(e => this.isIgnoreFile(e));\n\n      if (hasIg) {\n        this.addIgnoreFiles();\n      } else {\n        this.filterEntries();\n      }\n    }\n  }\n\n  addIgnoreFiles() {\n    const newIg = this.entries.filter(e => this.isIgnoreFile(e));\n    let igCount = newIg.length;\n\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries();\n      }\n    };\n\n    newIg.forEach(e => this.addIgnoreFile(e, then));\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    fs.readFile(ig, 'utf8', (er, data) => er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then));\n  }\n\n  onReadIgnoreFile(file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    };\n    const rules = data.split(/\\r?\\n/).filter(line => !/^#|^$/.test(line.trim())).map(rule => {\n      return new Minimatch(rule.trim(), mmopt);\n    });\n    this.ignoreRules[file] = rules;\n    then();\n  }\n\n  filterEntries() {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry);\n      const passDir = this.filterEntry(entry, true);\n      return passFile || passDir ? [entry, passFile, passDir] : false;\n    }).filter(e => e); // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n\n    let entryCount = filtered.length;\n\n    if (entryCount === 0) {\n      this.emit('done', this.result);\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result);\n        }\n      };\n\n      filtered.forEach(filt => {\n        const entry = filt[0];\n        const file = filt[1];\n        const dir = filt[2];\n        this.stat({\n          entry,\n          file,\n          dir\n        }, then);\n      });\n    }\n  }\n\n  onstat({\n    st,\n    entry,\n    file,\n    dir,\n    isSymbolicLink\n  }, then) {\n    const abs = this.path + '/' + entry;\n\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.slice(this.root.length + 1));\n      }\n\n      then();\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, {\n          isSymbolicLink\n        }, then);\n      } else {\n        then();\n      }\n    }\n  }\n\n  stat({\n    entry,\n    file,\n    dir\n  }, then) {\n    const abs = this.path + '/' + entry;\n    fs.lstat(abs, (lstatErr, lstatResult) => {\n      if (lstatErr) {\n        this.emit('error', lstatErr);\n      } else {\n        const isSymbolicLink = lstatResult.isSymbolicLink();\n\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (statErr, statResult) => {\n            if (statErr) {\n              this.emit('error', statErr);\n            } else {\n              this.onstat({\n                st: statResult,\n                entry,\n                file,\n                dir,\n                isSymbolicLink\n              }, then);\n            }\n          });\n        } else {\n          this.onstat({\n            st: lstatResult,\n            entry,\n            file,\n            dir,\n            isSymbolicLink\n          }, then);\n        }\n      }\n    });\n  }\n\n  walkerOpt(entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts\n    };\n  }\n\n  walker(entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start();\n  }\n\n  filterEntry(entry, partial) {\n    let included = true; // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + '/' + entry;\n      included = this.parent.filterEntry(pt, partial);\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/')) || !!partial && rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true));\n\n            if (match) {\n              included = rule.negate;\n            }\n          }\n        });\n      }\n    });\n    return included;\n  }\n\n}\n\nclass WalkerSync extends Walker {\n  start() {\n    this.onReaddir(fs.readdirSync(this.path));\n    return this;\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n  }\n\n  stat({\n    entry,\n    file,\n    dir\n  }, then) {\n    const abs = this.path + '/' + entry;\n    let st = fs.lstatSync(abs);\n    const isSymbolicLink = st.isSymbolicLink();\n\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs);\n    } // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n\n\n    this.onstat({\n      st,\n      entry,\n      file,\n      dir,\n      isSymbolicLink\n    }, then);\n  }\n\n  walker(entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start();\n    then();\n  }\n\n}\n\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = opts => new WalkerSync(opts).start().result;\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":{"version":3,"names":["fs","require","path","EE","EventEmitter","Minimatch","Walker","constructor","opts","isSymbolicLink","process","cwd","basename","ignoreFiles","ignoreRules","parent","includeEmpty","root","follow","result","Set","entries","sawError","sort","a","b","localeCompare","emit","ev","data","ret","Array","from","map","e","test","start","readdir","er","onReaddir","isIgnoreFile","indexOf","length","add","slice","hasIg","some","addIgnoreFiles","filterEntries","newIg","filter","igCount","then","_","forEach","addIgnoreFile","file","ig","resolve","readFile","onReadIgnoreFile","mmopt","matchBase","dot","flipNegate","nocase","rules","split","line","trim","rule","filtered","entry","passFile","filterEntry","passDir","entryCount","filt","dir","stat","onstat","st","abs","isDirectory","walker","lstat","lstatErr","lstatResult","statErr","statResult","walkerOpt","on","partial","included","pt","f","negate","match","WalkerSync","readdirSync","readFileSync","lstatSync","statSync","walk","callback","p","Promise","reject","res","walkSync","module","exports","sync"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/ignore-walk/lib/index.js"],"sourcesContent":["'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst EE = require('events').EventEmitter\nconst Minimatch = require('minimatch').Minimatch\n\nclass Walker extends EE {\n  constructor (opts) {\n    opts = opts || {}\n    super(opts)\n    // set to true if this.path is a symlink, whether follow is true or not\n    this.isSymbolicLink = opts.isSymbolicLink\n    this.path = opts.path || process.cwd()\n    this.basename = path.basename(this.path)\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore']\n    this.ignoreRules = {}\n    this.parent = opts.parent || null\n    this.includeEmpty = !!opts.includeEmpty\n    this.root = this.parent ? this.parent.root : this.path\n    this.follow = !!opts.follow\n    this.result = this.parent ? this.parent.result : new Set()\n    this.entries = null\n    this.sawError = false\n  }\n\n  sort (a, b) {\n    return a.localeCompare(b, 'en')\n  }\n\n  emit (ev, data) {\n    let ret = false\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data)\n          .map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort)\n        this.result = data\n      }\n\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data)\n      } else {\n        ret = super.emit(ev, data)\n      }\n    }\n    return ret\n  }\n\n  start () {\n    fs.readdir(this.path, (er, entries) =>\n      er ? this.emit('error', er) : this.onReaddir(entries))\n    return this\n  }\n\n  isIgnoreFile (e) {\n    return e !== '.' &&\n      e !== '..' &&\n      this.ignoreFiles.indexOf(e) !== -1\n  }\n\n  onReaddir (entries) {\n    this.entries = entries\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.slice(this.root.length + 1))\n      }\n      this.emit('done', this.result)\n    } else {\n      const hasIg = this.entries.some(e =>\n        this.isIgnoreFile(e))\n\n      if (hasIg) {\n        this.addIgnoreFiles()\n      } else {\n        this.filterEntries()\n      }\n    }\n  }\n\n  addIgnoreFiles () {\n    const newIg = this.entries\n      .filter(e => this.isIgnoreFile(e))\n\n    let igCount = newIg.length\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries()\n      }\n    }\n\n    newIg.forEach(e => this.addIgnoreFile(e, then))\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    fs.readFile(ig, 'utf8', (er, data) =>\n      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true,\n    }\n    const rules = data.split(/\\r?\\n/)\n      .filter(line => !/^#|^$/.test(line.trim()))\n      .map(rule => {\n        return new Minimatch(rule.trim(), mmopt)\n      })\n\n    this.ignoreRules[file] = rules\n\n    then()\n  }\n\n  filterEntries () {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry)\n      const passDir = this.filterEntry(entry, true)\n      return (passFile || passDir) ? [entry, passFile, passDir] : false\n    }).filter(e => e)\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length\n    if (entryCount === 0) {\n      this.emit('done', this.result)\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result)\n        }\n      }\n      filtered.forEach(filt => {\n        const entry = filt[0]\n        const file = filt[1]\n        const dir = filt[2]\n        this.stat({ entry, file, dir }, then)\n      })\n    }\n  }\n\n  onstat ({ st, entry, file, dir, isSymbolicLink }, then) {\n    const abs = this.path + '/' + entry\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.slice(this.root.length + 1))\n      }\n      then()\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, { isSymbolicLink }, then)\n      } else {\n        then()\n      }\n    }\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    fs.lstat(abs, (lstatErr, lstatResult) => {\n      if (lstatErr) {\n        this.emit('error', lstatErr)\n      } else {\n        const isSymbolicLink = lstatResult.isSymbolicLink()\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (statErr, statResult) => {\n            if (statErr) {\n              this.emit('error', statErr)\n            } else {\n              this.onstat({ st: statResult, entry, file, dir, isSymbolicLink }, then)\n            }\n          })\n        } else {\n          this.onstat({ st: lstatResult, entry, file, dir, isSymbolicLink }, then)\n        }\n      }\n    })\n  }\n\n  walkerOpt (entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts,\n    }\n  }\n\n  walker (entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start()\n  }\n\n  filterEntry (entry, partial) {\n    let included = true\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + '/' + entry\n      included = this.parent.filterEntry(pt, partial)\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) ||\n              rule.match(entry) ||\n              (!!partial && (\n                rule.match('/' + entry + '/') ||\n                rule.match(entry + '/'))) ||\n              (!!partial && rule.negate && (\n                rule.match('/' + entry, true) ||\n                rule.match(entry, true)))\n\n            if (match) {\n              included = rule.negate\n            }\n          }\n        })\n      }\n    })\n\n    return included\n  }\n}\n\nclass WalkerSync extends Walker {\n  start () {\n    this.onReaddir(fs.readdirSync(this.path))\n    return this\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    let st = fs.lstatSync(abs)\n    const isSymbolicLink = st.isSymbolicLink()\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs)\n    }\n\n    // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n    this.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n  }\n\n  walker (entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start()\n    then()\n  }\n}\n\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = opts => new WalkerSync(opts).start().result\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,QAAD,CAAP,CAAkBG,YAA7B;;AACA,MAAMC,SAAS,GAAGJ,OAAO,CAAC,WAAD,CAAP,CAAqBI,SAAvC;;AAEA,MAAMC,MAAN,SAAqBH,EAArB,CAAwB;EACtBI,WAAW,CAAEC,IAAF,EAAQ;IACjBA,IAAI,GAAGA,IAAI,IAAI,EAAf;IACA,MAAMA,IAAN,EAFiB,CAGjB;;IACA,KAAKC,cAAL,GAAsBD,IAAI,CAACC,cAA3B;IACA,KAAKP,IAAL,GAAYM,IAAI,CAACN,IAAL,IAAaQ,OAAO,CAACC,GAAR,EAAzB;IACA,KAAKC,QAAL,GAAgBV,IAAI,CAACU,QAAL,CAAc,KAAKV,IAAnB,CAAhB;IACA,KAAKW,WAAL,GAAmBL,IAAI,CAACK,WAAL,IAAoB,CAAC,SAAD,CAAvC;IACA,KAAKC,WAAL,GAAmB,EAAnB;IACA,KAAKC,MAAL,GAAcP,IAAI,CAACO,MAAL,IAAe,IAA7B;IACA,KAAKC,YAAL,GAAoB,CAAC,CAACR,IAAI,CAACQ,YAA3B;IACA,KAAKC,IAAL,GAAY,KAAKF,MAAL,GAAc,KAAKA,MAAL,CAAYE,IAA1B,GAAiC,KAAKf,IAAlD;IACA,KAAKgB,MAAL,GAAc,CAAC,CAACV,IAAI,CAACU,MAArB;IACA,KAAKC,MAAL,GAAc,KAAKJ,MAAL,GAAc,KAAKA,MAAL,CAAYI,MAA1B,GAAmC,IAAIC,GAAJ,EAAjD;IACA,KAAKC,OAAL,GAAe,IAAf;IACA,KAAKC,QAAL,GAAgB,KAAhB;EACD;;EAEDC,IAAI,CAAEC,CAAF,EAAKC,CAAL,EAAQ;IACV,OAAOD,CAAC,CAACE,aAAF,CAAgBD,CAAhB,EAAmB,IAAnB,CAAP;EACD;;EAEDE,IAAI,CAAEC,EAAF,EAAMC,IAAN,EAAY;IACd,IAAIC,GAAG,GAAG,KAAV;;IACA,IAAI,EAAE,KAAKR,QAAL,IAAiBM,EAAE,KAAK,OAA1B,CAAJ,EAAwC;MACtC,IAAIA,EAAE,KAAK,OAAX,EAAoB;QAClB,KAAKN,QAAL,GAAgB,IAAhB;MACD,CAFD,MAEO,IAAIM,EAAE,KAAK,MAAP,IAAiB,CAAC,KAAKb,MAA3B,EAAmC;QACxCc,IAAI,GAAGE,KAAK,CAACC,IAAN,CAAWH,IAAX,EACJI,GADI,CACAC,CAAC,IAAI,KAAKC,IAAL,CAAUD,CAAV,IAAgB,KAAIA,CAAE,EAAtB,GAA0BA,CAD/B,EACkCX,IADlC,CACuC,KAAKA,IAD5C,CAAP;QAEA,KAAKJ,MAAL,GAAcU,IAAd;MACD;;MAED,IAAID,EAAE,KAAK,OAAP,IAAkB,KAAKb,MAA3B,EAAmC;QACjCe,GAAG,GAAG,KAAKf,MAAL,CAAYY,IAAZ,CAAiB,OAAjB,EAA0BE,IAA1B,CAAN;MACD,CAFD,MAEO;QACLC,GAAG,GAAG,MAAMH,IAAN,CAAWC,EAAX,EAAeC,IAAf,CAAN;MACD;IACF;;IACD,OAAOC,GAAP;EACD;;EAEDM,KAAK,GAAI;IACPpC,EAAE,CAACqC,OAAH,CAAW,KAAKnC,IAAhB,EAAsB,CAACoC,EAAD,EAAKjB,OAAL,KACpBiB,EAAE,GAAG,KAAKX,IAAL,CAAU,OAAV,EAAmBW,EAAnB,CAAH,GAA4B,KAAKC,SAAL,CAAelB,OAAf,CADhC;IAEA,OAAO,IAAP;EACD;;EAEDmB,YAAY,CAAEN,CAAF,EAAK;IACf,OAAOA,CAAC,KAAK,GAAN,IACLA,CAAC,KAAK,IADD,IAEL,KAAKrB,WAAL,CAAiB4B,OAAjB,CAAyBP,CAAzB,MAAgC,CAAC,CAFnC;EAGD;;EAEDK,SAAS,CAAElB,OAAF,EAAW;IAClB,KAAKA,OAAL,GAAeA,OAAf;;IACA,IAAIA,OAAO,CAACqB,MAAR,KAAmB,CAAvB,EAA0B;MACxB,IAAI,KAAK1B,YAAT,EAAuB;QACrB,KAAKG,MAAL,CAAYwB,GAAZ,CAAgB,KAAKzC,IAAL,CAAU0C,KAAV,CAAgB,KAAK3B,IAAL,CAAUyB,MAAV,GAAmB,CAAnC,CAAhB;MACD;;MACD,KAAKf,IAAL,CAAU,MAAV,EAAkB,KAAKR,MAAvB;IACD,CALD,MAKO;MACL,MAAM0B,KAAK,GAAG,KAAKxB,OAAL,CAAayB,IAAb,CAAkBZ,CAAC,IAC/B,KAAKM,YAAL,CAAkBN,CAAlB,CADY,CAAd;;MAGA,IAAIW,KAAJ,EAAW;QACT,KAAKE,cAAL;MACD,CAFD,MAEO;QACL,KAAKC,aAAL;MACD;IACF;EACF;;EAEDD,cAAc,GAAI;IAChB,MAAME,KAAK,GAAG,KAAK5B,OAAL,CACX6B,MADW,CACJhB,CAAC,IAAI,KAAKM,YAAL,CAAkBN,CAAlB,CADD,CAAd;IAGA,IAAIiB,OAAO,GAAGF,KAAK,CAACP,MAApB;;IACA,MAAMU,IAAI,GAAGC,CAAC,IAAI;MAChB,IAAI,EAAEF,OAAF,KAAc,CAAlB,EAAqB;QACnB,KAAKH,aAAL;MACD;IACF,CAJD;;IAMAC,KAAK,CAACK,OAAN,CAAcpB,CAAC,IAAI,KAAKqB,aAAL,CAAmBrB,CAAnB,EAAsBkB,IAAtB,CAAnB;EACD;;EAEDG,aAAa,CAAEC,IAAF,EAAQJ,IAAR,EAAc;IACzB,MAAMK,EAAE,GAAGvD,IAAI,CAACwD,OAAL,CAAa,KAAKxD,IAAlB,EAAwBsD,IAAxB,CAAX;IACAxD,EAAE,CAAC2D,QAAH,CAAYF,EAAZ,EAAgB,MAAhB,EAAwB,CAACnB,EAAD,EAAKT,IAAL,KACtBS,EAAE,GAAG,KAAKX,IAAL,CAAU,OAAV,EAAmBW,EAAnB,CAAH,GAA4B,KAAKsB,gBAAL,CAAsBJ,IAAtB,EAA4B3B,IAA5B,EAAkCuB,IAAlC,CADhC;EAED;;EAEDQ,gBAAgB,CAAEJ,IAAF,EAAQ3B,IAAR,EAAcuB,IAAd,EAAoB;IAClC,MAAMS,KAAK,GAAG;MACZC,SAAS,EAAE,IADC;MAEZC,GAAG,EAAE,IAFO;MAGZC,UAAU,EAAE,IAHA;MAIZC,MAAM,EAAE;IAJI,CAAd;IAMA,MAAMC,KAAK,GAAGrC,IAAI,CAACsC,KAAL,CAAW,OAAX,EACXjB,MADW,CACJkB,IAAI,IAAI,CAAC,QAAQjC,IAAR,CAAaiC,IAAI,CAACC,IAAL,EAAb,CADL,EAEXpC,GAFW,CAEPqC,IAAI,IAAI;MACX,OAAO,IAAIjE,SAAJ,CAAciE,IAAI,CAACD,IAAL,EAAd,EAA2BR,KAA3B,CAAP;IACD,CAJW,CAAd;IAMA,KAAK/C,WAAL,CAAiB0C,IAAjB,IAAyBU,KAAzB;IAEAd,IAAI;EACL;;EAEDJ,aAAa,GAAI;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMuB,QAAQ,GAAG,KAAKlD,OAAL,CAAaY,GAAb,CAAiBuC,KAAK,IAAI;MACzC;MACA,MAAMC,QAAQ,GAAG,KAAKC,WAAL,CAAiBF,KAAjB,CAAjB;MACA,MAAMG,OAAO,GAAG,KAAKD,WAAL,CAAiBF,KAAjB,EAAwB,IAAxB,CAAhB;MACA,OAAQC,QAAQ,IAAIE,OAAb,GAAwB,CAACH,KAAD,EAAQC,QAAR,EAAkBE,OAAlB,CAAxB,GAAqD,KAA5D;IACD,CALgB,EAKdzB,MALc,CAKPhB,CAAC,IAAIA,CALE,CAAjB,CATe,CAgBf;IACA;IACA;;IACA,IAAI0C,UAAU,GAAGL,QAAQ,CAAC7B,MAA1B;;IACA,IAAIkC,UAAU,KAAK,CAAnB,EAAsB;MACpB,KAAKjD,IAAL,CAAU,MAAV,EAAkB,KAAKR,MAAvB;IACD,CAFD,MAEO;MACL,MAAMiC,IAAI,GAAGC,CAAC,IAAI;QAChB,IAAI,EAAEuB,UAAF,KAAiB,CAArB,EAAwB;UACtB,KAAKjD,IAAL,CAAU,MAAV,EAAkB,KAAKR,MAAvB;QACD;MACF,CAJD;;MAKAoD,QAAQ,CAACjB,OAAT,CAAiBuB,IAAI,IAAI;QACvB,MAAML,KAAK,GAAGK,IAAI,CAAC,CAAD,CAAlB;QACA,MAAMrB,IAAI,GAAGqB,IAAI,CAAC,CAAD,CAAjB;QACA,MAAMC,GAAG,GAAGD,IAAI,CAAC,CAAD,CAAhB;QACA,KAAKE,IAAL,CAAU;UAAEP,KAAF;UAAShB,IAAT;UAAesB;QAAf,CAAV,EAAgC1B,IAAhC;MACD,CALD;IAMD;EACF;;EAED4B,MAAM,CAAE;IAAEC,EAAF;IAAMT,KAAN;IAAahB,IAAb;IAAmBsB,GAAnB;IAAwBrE;EAAxB,CAAF,EAA4C2C,IAA5C,EAAkD;IACtD,MAAM8B,GAAG,GAAG,KAAKhF,IAAL,GAAY,GAAZ,GAAkBsE,KAA9B;;IACA,IAAI,CAACS,EAAE,CAACE,WAAH,EAAL,EAAuB;MACrB,IAAI3B,IAAJ,EAAU;QACR,KAAKrC,MAAL,CAAYwB,GAAZ,CAAgBuC,GAAG,CAACtC,KAAJ,CAAU,KAAK3B,IAAL,CAAUyB,MAAV,GAAmB,CAA7B,CAAhB;MACD;;MACDU,IAAI;IACL,CALD,MAKO;MACL;MACA,IAAI0B,GAAJ,EAAS;QACP,KAAKM,MAAL,CAAYZ,KAAZ,EAAmB;UAAE/D;QAAF,CAAnB,EAAuC2C,IAAvC;MACD,CAFD,MAEO;QACLA,IAAI;MACL;IACF;EACF;;EAED2B,IAAI,CAAE;IAAEP,KAAF;IAAShB,IAAT;IAAesB;EAAf,CAAF,EAAwB1B,IAAxB,EAA8B;IAChC,MAAM8B,GAAG,GAAG,KAAKhF,IAAL,GAAY,GAAZ,GAAkBsE,KAA9B;IACAxE,EAAE,CAACqF,KAAH,CAASH,GAAT,EAAc,CAACI,QAAD,EAAWC,WAAX,KAA2B;MACvC,IAAID,QAAJ,EAAc;QACZ,KAAK3D,IAAL,CAAU,OAAV,EAAmB2D,QAAnB;MACD,CAFD,MAEO;QACL,MAAM7E,cAAc,GAAG8E,WAAW,CAAC9E,cAAZ,EAAvB;;QACA,IAAI,KAAKS,MAAL,IAAeT,cAAnB,EAAmC;UACjCT,EAAE,CAAC+E,IAAH,CAAQG,GAAR,EAAa,CAACM,OAAD,EAAUC,UAAV,KAAyB;YACpC,IAAID,OAAJ,EAAa;cACX,KAAK7D,IAAL,CAAU,OAAV,EAAmB6D,OAAnB;YACD,CAFD,MAEO;cACL,KAAKR,MAAL,CAAY;gBAAEC,EAAE,EAAEQ,UAAN;gBAAkBjB,KAAlB;gBAAyBhB,IAAzB;gBAA+BsB,GAA/B;gBAAoCrE;cAApC,CAAZ,EAAkE2C,IAAlE;YACD;UACF,CAND;QAOD,CARD,MAQO;UACL,KAAK4B,MAAL,CAAY;YAAEC,EAAE,EAAEM,WAAN;YAAmBf,KAAnB;YAA0BhB,IAA1B;YAAgCsB,GAAhC;YAAqCrE;UAArC,CAAZ,EAAmE2C,IAAnE;QACD;MACF;IACF,CAjBD;EAkBD;;EAEDsC,SAAS,CAAElB,KAAF,EAAShE,IAAT,EAAe;IACtB,OAAO;MACLN,IAAI,EAAE,KAAKA,IAAL,GAAY,GAAZ,GAAkBsE,KADnB;MAELzD,MAAM,EAAE,IAFH;MAGLF,WAAW,EAAE,KAAKA,WAHb;MAILK,MAAM,EAAE,KAAKA,MAJR;MAKLF,YAAY,EAAE,KAAKA,YALd;MAML,GAAGR;IANE,CAAP;EAQD;;EAED4E,MAAM,CAAEZ,KAAF,EAAShE,IAAT,EAAe4C,IAAf,EAAqB;IACzB,IAAI9C,MAAJ,CAAW,KAAKoF,SAAL,CAAelB,KAAf,EAAsBhE,IAAtB,CAAX,EAAwCmF,EAAxC,CAA2C,MAA3C,EAAmDvC,IAAnD,EAAyDhB,KAAzD;EACD;;EAEDsC,WAAW,CAAEF,KAAF,EAASoB,OAAT,EAAkB;IAC3B,IAAIC,QAAQ,GAAG,IAAf,CAD2B,CAG3B;IACA;IACA;;IACA,IAAI,KAAK9E,MAAL,IAAe,KAAKA,MAAL,CAAY2D,WAA/B,EAA4C;MAC1C,IAAIoB,EAAE,GAAG,KAAKlF,QAAL,GAAgB,GAAhB,GAAsB4D,KAA/B;MACAqB,QAAQ,GAAG,KAAK9E,MAAL,CAAY2D,WAAZ,CAAwBoB,EAAxB,EAA4BF,OAA5B,CAAX;IACD;;IAED,KAAK/E,WAAL,CAAiByC,OAAjB,CAAyByC,CAAC,IAAI;MAC5B,IAAI,KAAKjF,WAAL,CAAiBiF,CAAjB,CAAJ,EAAyB;QACvB,KAAKjF,WAAL,CAAiBiF,CAAjB,EAAoBzC,OAApB,CAA4BgB,IAAI,IAAI;UAClC;UACA;UACA;UACA,IAAIA,IAAI,CAAC0B,MAAL,KAAgBH,QAApB,EAA8B;YAC5B;YACA;YACA;YACA,MAAMI,KAAK,GAAG3B,IAAI,CAAC2B,KAAL,CAAW,MAAMzB,KAAjB,KACZF,IAAI,CAAC2B,KAAL,CAAWzB,KAAX,CADY,IAEX,CAAC,CAACoB,OAAF,KACCtB,IAAI,CAAC2B,KAAL,CAAW,MAAMzB,KAAN,GAAc,GAAzB,KACAF,IAAI,CAAC2B,KAAL,CAAWzB,KAAK,GAAG,GAAnB,CAFD,CAFW,IAKX,CAAC,CAACoB,OAAF,IAAatB,IAAI,CAAC0B,MAAlB,KACC1B,IAAI,CAAC2B,KAAL,CAAW,MAAMzB,KAAjB,EAAwB,IAAxB,KACAF,IAAI,CAAC2B,KAAL,CAAWzB,KAAX,EAAkB,IAAlB,CAFD,CALH;;YASA,IAAIyB,KAAJ,EAAW;cACTJ,QAAQ,GAAGvB,IAAI,CAAC0B,MAAhB;YACD;UACF;QACF,CArBD;MAsBD;IACF,CAzBD;IA2BA,OAAOH,QAAP;EACD;;AAlPqB;;AAqPxB,MAAMK,UAAN,SAAyB5F,MAAzB,CAAgC;EAC9B8B,KAAK,GAAI;IACP,KAAKG,SAAL,CAAevC,EAAE,CAACmG,WAAH,CAAe,KAAKjG,IAApB,CAAf;IACA,OAAO,IAAP;EACD;;EAEDqD,aAAa,CAAEC,IAAF,EAAQJ,IAAR,EAAc;IACzB,MAAMK,EAAE,GAAGvD,IAAI,CAACwD,OAAL,CAAa,KAAKxD,IAAlB,EAAwBsD,IAAxB,CAAX;IACA,KAAKI,gBAAL,CAAsBJ,IAAtB,EAA4BxD,EAAE,CAACoG,YAAH,CAAgB3C,EAAhB,EAAoB,MAApB,CAA5B,EAAyDL,IAAzD;EACD;;EAED2B,IAAI,CAAE;IAAEP,KAAF;IAAShB,IAAT;IAAesB;EAAf,CAAF,EAAwB1B,IAAxB,EAA8B;IAChC,MAAM8B,GAAG,GAAG,KAAKhF,IAAL,GAAY,GAAZ,GAAkBsE,KAA9B;IACA,IAAIS,EAAE,GAAGjF,EAAE,CAACqG,SAAH,CAAanB,GAAb,CAAT;IACA,MAAMzE,cAAc,GAAGwE,EAAE,CAACxE,cAAH,EAAvB;;IACA,IAAI,KAAKS,MAAL,IAAeT,cAAnB,EAAmC;MACjCwE,EAAE,GAAGjF,EAAE,CAACsG,QAAH,CAAYpB,GAAZ,CAAL;IACD,CAN+B,CAQhC;;;IACA,KAAKF,MAAL,CAAY;MAAEC,EAAF;MAAMT,KAAN;MAAahB,IAAb;MAAmBsB,GAAnB;MAAwBrE;IAAxB,CAAZ,EAAsD2C,IAAtD;EACD;;EAEDgC,MAAM,CAAEZ,KAAF,EAAShE,IAAT,EAAe4C,IAAf,EAAqB;IACzB,IAAI8C,UAAJ,CAAe,KAAKR,SAAL,CAAelB,KAAf,EAAsBhE,IAAtB,CAAf,EAA4C4B,KAA5C;IACAgB,IAAI;EACL;;AA1B6B;;AA6BhC,MAAMmD,IAAI,GAAG,CAAC/F,IAAD,EAAOgG,QAAP,KAAoB;EAC/B,MAAMC,CAAC,GAAG,IAAIC,OAAJ,CAAY,CAAChD,OAAD,EAAUiD,MAAV,KAAqB;IACzC,IAAIrG,MAAJ,CAAWE,IAAX,EAAiBmF,EAAjB,CAAoB,MAApB,EAA4BjC,OAA5B,EAAqCiC,EAArC,CAAwC,OAAxC,EAAiDgB,MAAjD,EAAyDvE,KAAzD;EACD,CAFS,CAAV;EAGA,OAAOoE,QAAQ,GAAGC,CAAC,CAACrD,IAAF,CAAOwD,GAAG,IAAIJ,QAAQ,CAAC,IAAD,EAAOI,GAAP,CAAtB,EAAmCJ,QAAnC,CAAH,GAAkDC,CAAjE;AACD,CALD;;AAOA,MAAMI,QAAQ,GAAGrG,IAAI,IAAI,IAAI0F,UAAJ,CAAe1F,IAAf,EAAqB4B,KAArB,GAA6BjB,MAAtD;;AAEA2F,MAAM,CAACC,OAAP,GAAiBR,IAAjB;AACAA,IAAI,CAACS,IAAL,GAAYH,QAAZ;AACAN,IAAI,CAACjG,MAAL,GAAcA,MAAd;AACAiG,IAAI,CAACL,UAAL,GAAkBA,UAAlB"},"metadata":{},"sourceType":"script"}