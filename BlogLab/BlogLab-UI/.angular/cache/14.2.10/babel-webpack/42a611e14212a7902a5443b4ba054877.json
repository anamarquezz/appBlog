{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst index = require('./entry-index');\n\nconst memo = require('./memoization');\n\nconst write = require('./content/write');\n\nconst Flush = require('minipass-flush');\n\nconst {\n  PassThrough\n} = require('minipass-collect');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst putOpts = opts => ({\n  algorithms: ['sha512'],\n  ...opts\n});\n\nmodule.exports = putData;\n\nfunction putData(_x, _x2, _x3) {\n  return _putData.apply(this, arguments);\n}\n\nfunction _putData() {\n  _putData = _asyncToGenerator(function* (cache, key, data, opts = {}) {\n    const {\n      memoize\n    } = opts;\n    opts = putOpts(opts);\n    const res = yield write(cache, data, opts);\n    const entry = yield index.insert(cache, key, res.integrity, { ...opts,\n      size: res.size\n    });\n\n    if (memoize) {\n      memo.put(cache, entry, data, opts);\n    }\n\n    return res.integrity;\n  });\n  return _putData.apply(this, arguments);\n}\n\nmodule.exports.stream = putStream;\n\nfunction putStream(cache, key, opts = {}) {\n  const {\n    memoize\n  } = opts;\n  opts = putOpts(opts);\n  let integrity;\n  let size;\n  let error;\n  let memoData;\n  const pipeline = new Pipeline(); // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n\n  if (memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data;\n    });\n    pipeline.push(memoizer);\n  } // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n\n\n  const contentStream = write.stream(cache, opts).on('integrity', int => {\n    integrity = int;\n  }).on('size', s => {\n    size = s;\n  }).on('error', err => {\n    error = err;\n  });\n  pipeline.push(contentStream); // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n\n  pipeline.push(new Flush({\n    flush() {\n      return _asyncToGenerator(function* () {\n        if (!error) {\n          const entry = yield index.insert(cache, key, integrity, { ...opts,\n            size\n          });\n\n          if (memoize && memoData) {\n            memo.put(cache, entry, memoData, opts);\n          }\n\n          pipeline.emit('integrity', integrity);\n          pipeline.emit('size', size);\n        }\n      })();\n    }\n\n  }));\n  return pipeline;\n}","map":{"version":3,"names":["index","require","memo","write","Flush","PassThrough","Pipeline","putOpts","opts","algorithms","module","exports","putData","cache","key","data","memoize","res","entry","insert","integrity","size","put","stream","putStream","error","memoData","pipeline","memoizer","on","push","contentStream","int","s","err","flush","emit"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/cacache/lib/put.js"],"sourcesContent":["'use strict'\n\nconst index = require('./entry-index')\nconst memo = require('./memoization')\nconst write = require('./content/write')\nconst Flush = require('minipass-flush')\nconst { PassThrough } = require('minipass-collect')\nconst Pipeline = require('minipass-pipeline')\n\nconst putOpts = (opts) => ({\n  algorithms: ['sha512'],\n  ...opts,\n})\n\nmodule.exports = putData\n\nasync function putData (cache, key, data, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  const res = await write(cache, data, opts)\n  const entry = await index.insert(cache, key, res.integrity, { ...opts, size: res.size })\n  if (memoize) {\n    memo.put(cache, entry, data, opts)\n  }\n\n  return res.integrity\n}\n\nmodule.exports.stream = putStream\n\nfunction putStream (cache, key, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  let integrity\n  let size\n  let error\n\n  let memoData\n  const pipeline = new Pipeline()\n  // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n  if (memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data\n    })\n    pipeline.push(memoizer)\n  }\n\n  // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n  const contentStream = write.stream(cache, opts)\n    .on('integrity', (int) => {\n      integrity = int\n    })\n    .on('size', (s) => {\n      size = s\n    })\n    .on('error', (err) => {\n      error = err\n    })\n\n  pipeline.push(contentStream)\n\n  // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n  pipeline.push(new Flush({\n    async flush () {\n      if (!error) {\n        const entry = await index.insert(cache, key, integrity, { ...opts, size })\n        if (memoize && memoData) {\n          memo.put(cache, entry, memoData, opts)\n        }\n        pipeline.emit('integrity', integrity)\n        pipeline.emit('size', size)\n      }\n    },\n  }))\n\n  return pipeline\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}