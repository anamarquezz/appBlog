{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst exception_1 = require(\"../../exception\");\n\nconst index_1 = require(\"../../utils/index\");\n\nconst api_1 = require(\"./api\");\n\nclass ChannelAlreadyExistException extends exception_1.BaseException {\n  constructor(name) {\n    super(`Channel ${JSON.stringify(name)} already exist.`);\n  }\n\n}\n\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\n\nfunction createJobHandler(fn, options = {}) {\n  const handler = (argument, context) => {\n    const description = context.description;\n    const inboundBus = context.inboundBus;\n    const inputChannel = new rxjs_1.Subject();\n    let subscription;\n    return new rxjs_1.Observable(subject => {\n      function complete() {\n        if (subscription) {\n          subscription.unsubscribe();\n        }\n\n        subject.next({\n          kind: api_1.JobOutboundMessageKind.End,\n          description\n        });\n        subject.complete();\n        inputChannel.complete();\n      } // Handle input.\n\n\n      const inboundSub = inboundBus.subscribe(message => {\n        switch (message.kind) {\n          case api_1.JobInboundMessageKind.Ping:\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.Pong,\n              description,\n              id: message.id\n            });\n            break;\n\n          case api_1.JobInboundMessageKind.Stop:\n            // There's no way to cancel a promise or a synchronous function, but we do cancel\n            // observables where possible.\n            complete();\n            break;\n\n          case api_1.JobInboundMessageKind.Input:\n            inputChannel.next(message.value);\n            break;\n        }\n      }); // Execute the function with the additional context.\n\n      const channels = new Map();\n      const newContext = { ...context,\n        input: inputChannel.asObservable(),\n\n        createChannel(name) {\n          if (channels.has(name)) {\n            throw new ChannelAlreadyExistException(name);\n          }\n\n          const channelSubject = new rxjs_1.Subject();\n          const channelSub = channelSubject.subscribe(message => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelMessage,\n              description,\n              name,\n              message\n            });\n          }, error => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelError,\n              description,\n              name,\n              error\n            }); // This can be reopened.\n\n            channels.delete(name);\n          }, () => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelComplete,\n              description,\n              name\n            }); // This can be reopened.\n\n            channels.delete(name);\n          });\n          channels.set(name, channelSubject);\n\n          if (subscription) {\n            subscription.add(channelSub);\n          }\n\n          return channelSubject;\n        }\n\n      };\n      subject.next({\n        kind: api_1.JobOutboundMessageKind.Start,\n        description\n      });\n      let result = fn(argument, newContext); // If the result is a promise, simply wait for it to complete before reporting the result.\n\n      if ((0, index_1.isPromise)(result)) {\n        result = (0, rxjs_1.from)(result);\n      } else if (!(0, rxjs_1.isObservable)(result)) {\n        result = (0, rxjs_1.of)(result);\n      }\n\n      subscription = result.subscribe(value => subject.next({\n        kind: api_1.JobOutboundMessageKind.Output,\n        description,\n        value\n      }), error => subject.error(error), () => complete());\n      subscription.add(inboundSub);\n      return subscription;\n    });\n  };\n\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\n\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\n\nfunction createJobFactory(loader, options = {}) {\n  const handler = (argument, context) => {\n    return (0, rxjs_1.from)(loader()).pipe((0, operators_1.switchMap)(fn => fn(argument, context)));\n  };\n\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\n\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\n\nfunction createLoggerJob(job, logger) {\n  const handler = (argument, context) => {\n    context.inboundBus.pipe((0, operators_1.tap)(message => logger.info(`Input: ${JSON.stringify(message)}`))).subscribe();\n    return job(argument, context).pipe((0, operators_1.tap)(message => logger.info(`Message: ${JSON.stringify(message)}`), error => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n  };\n\n  return Object.assign(handler, job);\n}\n\nexports.createLoggerJob = createLoggerJob;","map":{"version":3,"names":["Object","defineProperty","exports","value","createLoggerJob","createJobFactory","createJobHandler","ChannelAlreadyExistException","rxjs_1","require","operators_1","exception_1","index_1","api_1","BaseException","constructor","name","JSON","stringify","fn","options","handler","argument","context","description","inboundBus","inputChannel","Subject","subscription","Observable","subject","complete","unsubscribe","next","kind","JobOutboundMessageKind","End","inboundSub","subscribe","message","JobInboundMessageKind","Ping","Pong","id","Stop","Input","channels","Map","newContext","input","asObservable","createChannel","has","channelSubject","channelSub","ChannelMessage","error","ChannelError","delete","ChannelComplete","set","add","Start","result","isPromise","from","isObservable","of","Output","assign","jobDescription","loader","pipe","switchMap","job","logger","tap","info","warn"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/experimental/jobs/create-job-handler.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../../exception\");\nconst index_1 = require(\"../../utils/index\");\nconst api_1 = require(\"./api\");\nclass ChannelAlreadyExistException extends exception_1.BaseException {\n    constructor(name) {\n        super(`Channel ${JSON.stringify(name)} already exist.`);\n    }\n}\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\nfunction createJobHandler(fn, options = {}) {\n    const handler = (argument, context) => {\n        const description = context.description;\n        const inboundBus = context.inboundBus;\n        const inputChannel = new rxjs_1.Subject();\n        let subscription;\n        return new rxjs_1.Observable((subject) => {\n            function complete() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                }\n                subject.next({ kind: api_1.JobOutboundMessageKind.End, description });\n                subject.complete();\n                inputChannel.complete();\n            }\n            // Handle input.\n            const inboundSub = inboundBus.subscribe((message) => {\n                switch (message.kind) {\n                    case api_1.JobInboundMessageKind.Ping:\n                        subject.next({ kind: api_1.JobOutboundMessageKind.Pong, description, id: message.id });\n                        break;\n                    case api_1.JobInboundMessageKind.Stop:\n                        // There's no way to cancel a promise or a synchronous function, but we do cancel\n                        // observables where possible.\n                        complete();\n                        break;\n                    case api_1.JobInboundMessageKind.Input:\n                        inputChannel.next(message.value);\n                        break;\n                }\n            });\n            // Execute the function with the additional context.\n            const channels = new Map();\n            const newContext = {\n                ...context,\n                input: inputChannel.asObservable(),\n                createChannel(name) {\n                    if (channels.has(name)) {\n                        throw new ChannelAlreadyExistException(name);\n                    }\n                    const channelSubject = new rxjs_1.Subject();\n                    const channelSub = channelSubject.subscribe((message) => {\n                        subject.next({\n                            kind: api_1.JobOutboundMessageKind.ChannelMessage,\n                            description,\n                            name,\n                            message,\n                        });\n                    }, (error) => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelError, description, name, error });\n                        // This can be reopened.\n                        channels.delete(name);\n                    }, () => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelComplete, description, name });\n                        // This can be reopened.\n                        channels.delete(name);\n                    });\n                    channels.set(name, channelSubject);\n                    if (subscription) {\n                        subscription.add(channelSub);\n                    }\n                    return channelSubject;\n                },\n            };\n            subject.next({ kind: api_1.JobOutboundMessageKind.Start, description });\n            let result = fn(argument, newContext);\n            // If the result is a promise, simply wait for it to complete before reporting the result.\n            if ((0, index_1.isPromise)(result)) {\n                result = (0, rxjs_1.from)(result);\n            }\n            else if (!(0, rxjs_1.isObservable)(result)) {\n                result = (0, rxjs_1.of)(result);\n            }\n            subscription = result.subscribe((value) => subject.next({ kind: api_1.JobOutboundMessageKind.Output, description, value }), (error) => subject.error(error), () => complete());\n            subscription.add(inboundSub);\n            return subscription;\n        });\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\nfunction createJobFactory(loader, options = {}) {\n    const handler = (argument, context) => {\n        return (0, rxjs_1.from)(loader()).pipe((0, operators_1.switchMap)((fn) => fn(argument, context)));\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\nfunction createLoggerJob(job, logger) {\n    const handler = (argument, context) => {\n        context.inboundBus\n            .pipe((0, operators_1.tap)((message) => logger.info(`Input: ${JSON.stringify(message)}`)))\n            .subscribe();\n        return job(argument, context).pipe((0, operators_1.tap)((message) => logger.info(`Message: ${JSON.stringify(message)}`), (error) => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n    };\n    return Object.assign(handler, job);\n}\nexports.createLoggerJob = createLoggerJob;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}