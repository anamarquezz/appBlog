{"ast":null,"code":"const url = require('url');\n\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar);\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity);\n};\n\nconst safeUrl = u => {\n  try {\n    return new url.URL(u);\n  } catch {// this fn should never throw\n  }\n}; // accepts input like git:github.com:user/repo and inserts the // after the first :\n\n\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':');\n  const proto = arg.slice(0, firstColon + 1);\n\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg;\n  }\n\n  const firstAt = arg.indexOf('@');\n\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`;\n    } else {\n      return arg;\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//');\n\n  if (doubleSlash === firstColon + 1) {\n    return arg;\n  }\n\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;\n}; // attempt to correct an scp style url so that it will parse with `new URL()`\n\n\nconst correctUrl = giturl => {\n  // ignore @ that come after the first hash since the denotes the start\n  // of a committish which can contain @ characters\n  const firstAt = lastIndexOfBefore(giturl, '@', '#'); // ignore colons that come after the hash since that could include colons such as:\n  // git@github.com:user/package-2#semver:^1.0.0\n\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#');\n\n  if (lastColonBeforeHash > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1);\n  }\n\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    giturl = `git+ssh://${giturl}`;\n  }\n\n  return giturl;\n};\n\nmodule.exports = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));\n};","map":{"version":3,"names":["url","require","lastIndexOfBefore","str","char","beforeChar","startPosition","indexOf","lastIndexOf","Infinity","safeUrl","u","URL","correctProtocol","arg","protocols","firstColon","proto","slice","Object","prototype","hasOwnProperty","call","firstAt","doubleSlash","correctUrl","giturl","lastColonBeforeHash","module","exports","withProtocol"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/hosted-git-info/lib/parse-url.js"],"sourcesContent":["const url = require('url')\n\nconst lastIndexOfBefore = (str, char, beforeChar) => {\n  const startPosition = str.indexOf(beforeChar)\n  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)\n}\n\nconst safeUrl = (u) => {\n  try {\n    return new url.URL(u)\n  } catch {\n    // this fn should never throw\n  }\n}\n\n// accepts input like git:github.com:user/repo and inserts the // after the first :\nconst correctProtocol = (arg, protocols) => {\n  const firstColon = arg.indexOf(':')\n  const proto = arg.slice(0, firstColon + 1)\n  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {\n    return arg\n  }\n\n  const firstAt = arg.indexOf('@')\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`\n    } else {\n      return arg\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//')\n  if (doubleSlash === firstColon + 1) {\n    return arg\n  }\n\n  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`\n}\n\n// attempt to correct an scp style url so that it will parse with `new URL()`\nconst correctUrl = (giturl) => {\n  // ignore @ that come after the first hash since the denotes the start\n  // of a committish which can contain @ characters\n  const firstAt = lastIndexOfBefore(giturl, '@', '#')\n  // ignore colons that come after the hash since that could include colons such as:\n  // git@github.com:user/package-2#semver:^1.0.0\n  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#')\n\n  if (lastColonBeforeHash > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1)\n  }\n\n  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    giturl = `git+ssh://${giturl}`\n  }\n\n  return giturl\n}\n\nmodule.exports = (giturl, protocols) => {\n  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl\n  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}