{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyToSubtree = exports.composeFileOperators = exports.forEach = exports.partitionApplyMerge = exports.when = exports.branchAndMerge = exports.asSource = exports.filter = exports.noop = exports.mergeWith = exports.apply = exports.chain = exports.empty = exports.source = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst exception_1 = require(\"../exception/exception\");\n\nconst host_tree_1 = require(\"../tree/host-tree\");\n\nconst interface_1 = require(\"../tree/interface\");\n\nconst scoped_1 = require(\"../tree/scoped\");\n\nconst static_1 = require(\"../tree/static\");\n\nconst call_1 = require(\"./call\");\n/**\n * A Source that returns an tree as its single value.\n */\n\n\nfunction source(tree) {\n  return () => tree;\n}\n\nexports.source = source;\n/**\n * A source that returns an empty tree.\n */\n\nfunction empty() {\n  return () => (0, static_1.empty)();\n}\n\nexports.empty = empty;\n/**\n * Chain multiple rules into a single rule.\n */\n\nfunction chain(rules) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (initialTree, context) {\n      let intermediateTree;\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(rules), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const rule = _step.value;\n          intermediateTree = (0, call_1.callRule)(rule, intermediateTree !== null && intermediateTree !== void 0 ? intermediateTree : initialTree, context);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return () => intermediateTree;\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nexports.chain = chain;\n/**\n * Apply multiple rules to a source, and returns the source transformed.\n */\n\nfunction apply(source, rules) {\n  return context => (0, call_1.callRule)(chain(rules), (0, call_1.callSource)(source, context), context);\n}\n\nexports.apply = apply;\n/**\n * Merge an input tree with the source passed in.\n */\n\nfunction mergeWith(source, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callSource)(source, context).pipe((0, operators_1.map)(sourceTree => tree.merge(sourceTree, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n  };\n}\n\nexports.mergeWith = mergeWith;\n\nfunction noop() {\n  return () => {};\n}\n\nexports.noop = noop;\n\nfunction filter(predicate) {\n  return tree => {\n    if (host_tree_1.HostTree.isHostTree(tree)) {\n      return new host_tree_1.FilterHostTree(tree, predicate);\n    } else {\n      throw new exception_1.SchematicsException('Tree type is not supported.');\n    }\n  };\n}\n\nexports.filter = filter;\n\nfunction asSource(rule) {\n  return context => (0, call_1.callRule)(rule, (0, static_1.empty)(), context);\n}\n\nexports.asSource = asSource;\n\nfunction branchAndMerge(rule, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callRule)(rule, tree.branch(), context).pipe((0, operators_1.map)(branch => tree.merge(branch, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n  };\n}\n\nexports.branchAndMerge = branchAndMerge;\n\nfunction when(predicate, operator) {\n  return entry => {\n    if (predicate(entry.path, entry)) {\n      return operator(entry);\n    } else {\n      return entry;\n    }\n  };\n}\n\nexports.when = when;\n\nfunction partitionApplyMerge(predicate, ruleYes, ruleNo) {\n  return (tree, context) => {\n    const [yes, no] = (0, static_1.partition)(tree, predicate);\n    return (0, rxjs_1.concat)((0, call_1.callRule)(ruleYes, yes, context), (0, call_1.callRule)(ruleNo || noop(), no, context)).pipe((0, operators_1.toArray)(), (0, operators_1.map)(([yesTree, noTree]) => {\n      yesTree.merge(noTree, context.strategy);\n      return yesTree;\n    }));\n  };\n}\n\nexports.partitionApplyMerge = partitionApplyMerge;\n\nfunction forEach(operator) {\n  return tree => {\n    tree.visit((path, entry) => {\n      if (!entry) {\n        return;\n      }\n\n      const newEntry = operator(entry);\n\n      if (newEntry === entry) {\n        return;\n      }\n\n      if (newEntry === null) {\n        tree.delete(path);\n        return;\n      }\n\n      if (newEntry.path != path) {\n        tree.rename(path, newEntry.path);\n      }\n\n      if (!newEntry.content.equals(entry.content)) {\n        tree.overwrite(newEntry.path, newEntry.content);\n      }\n    });\n  };\n}\n\nexports.forEach = forEach;\n\nfunction composeFileOperators(operators) {\n  return entry => {\n    let current = entry;\n\n    for (const op of operators) {\n      current = op(current);\n\n      if (current === null) {\n        // Deleted, just return.\n        return null;\n      }\n    }\n\n    return current;\n  };\n}\n\nexports.composeFileOperators = composeFileOperators;\n\nfunction applyToSubtree(path, rules) {\n  return (tree, context) => {\n    const scoped = new scoped_1.ScopedTree(tree, path);\n    return (0, call_1.callRule)(chain(rules), scoped, context).pipe((0, operators_1.map)(result => {\n      if (result === scoped) {\n        return tree;\n      } else {\n        throw new exception_1.SchematicsException('Original tree must be returned from all rules when using \"applyToSubtree\".');\n      }\n    }));\n  };\n}\n\nexports.applyToSubtree = applyToSubtree;","map":{"version":3,"names":["Object","defineProperty","exports","value","applyToSubtree","composeFileOperators","forEach","partitionApplyMerge","when","branchAndMerge","asSource","filter","noop","mergeWith","apply","chain","empty","source","rxjs_1","require","operators_1","exception_1","host_tree_1","interface_1","scoped_1","static_1","call_1","tree","rules","initialTree","context","intermediateTree","rule","callRule","callSource","strategy","MergeStrategy","Default","pipe","map","sourceTree","merge","mapTo","predicate","HostTree","isHostTree","FilterHostTree","SchematicsException","branch","operator","entry","path","ruleYes","ruleNo","yes","no","partition","concat","toArray","yesTree","noTree","visit","newEntry","delete","rename","content","equals","overwrite","operators","current","op","scoped","ScopedTree","result"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/schematics/src/rules/base.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyToSubtree = exports.composeFileOperators = exports.forEach = exports.partitionApplyMerge = exports.when = exports.branchAndMerge = exports.asSource = exports.filter = exports.noop = exports.mergeWith = exports.apply = exports.chain = exports.empty = exports.source = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../exception/exception\");\nconst host_tree_1 = require(\"../tree/host-tree\");\nconst interface_1 = require(\"../tree/interface\");\nconst scoped_1 = require(\"../tree/scoped\");\nconst static_1 = require(\"../tree/static\");\nconst call_1 = require(\"./call\");\n/**\n * A Source that returns an tree as its single value.\n */\nfunction source(tree) {\n    return () => tree;\n}\nexports.source = source;\n/**\n * A source that returns an empty tree.\n */\nfunction empty() {\n    return () => (0, static_1.empty)();\n}\nexports.empty = empty;\n/**\n * Chain multiple rules into a single rule.\n */\nfunction chain(rules) {\n    return async (initialTree, context) => {\n        let intermediateTree;\n        for await (const rule of rules) {\n            intermediateTree = (0, call_1.callRule)(rule, intermediateTree !== null && intermediateTree !== void 0 ? intermediateTree : initialTree, context);\n        }\n        return () => intermediateTree;\n    };\n}\nexports.chain = chain;\n/**\n * Apply multiple rules to a source, and returns the source transformed.\n */\nfunction apply(source, rules) {\n    return (context) => (0, call_1.callRule)(chain(rules), (0, call_1.callSource)(source, context), context);\n}\nexports.apply = apply;\n/**\n * Merge an input tree with the source passed in.\n */\nfunction mergeWith(source, strategy = interface_1.MergeStrategy.Default) {\n    return (tree, context) => {\n        return (0, call_1.callSource)(source, context).pipe((0, operators_1.map)((sourceTree) => tree.merge(sourceTree, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n    };\n}\nexports.mergeWith = mergeWith;\nfunction noop() {\n    return () => { };\n}\nexports.noop = noop;\nfunction filter(predicate) {\n    return (tree) => {\n        if (host_tree_1.HostTree.isHostTree(tree)) {\n            return new host_tree_1.FilterHostTree(tree, predicate);\n        }\n        else {\n            throw new exception_1.SchematicsException('Tree type is not supported.');\n        }\n    };\n}\nexports.filter = filter;\nfunction asSource(rule) {\n    return (context) => (0, call_1.callRule)(rule, (0, static_1.empty)(), context);\n}\nexports.asSource = asSource;\nfunction branchAndMerge(rule, strategy = interface_1.MergeStrategy.Default) {\n    return (tree, context) => {\n        return (0, call_1.callRule)(rule, tree.branch(), context).pipe((0, operators_1.map)((branch) => tree.merge(branch, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n    };\n}\nexports.branchAndMerge = branchAndMerge;\nfunction when(predicate, operator) {\n    return (entry) => {\n        if (predicate(entry.path, entry)) {\n            return operator(entry);\n        }\n        else {\n            return entry;\n        }\n    };\n}\nexports.when = when;\nfunction partitionApplyMerge(predicate, ruleYes, ruleNo) {\n    return (tree, context) => {\n        const [yes, no] = (0, static_1.partition)(tree, predicate);\n        return (0, rxjs_1.concat)((0, call_1.callRule)(ruleYes, yes, context), (0, call_1.callRule)(ruleNo || noop(), no, context)).pipe((0, operators_1.toArray)(), (0, operators_1.map)(([yesTree, noTree]) => {\n            yesTree.merge(noTree, context.strategy);\n            return yesTree;\n        }));\n    };\n}\nexports.partitionApplyMerge = partitionApplyMerge;\nfunction forEach(operator) {\n    return (tree) => {\n        tree.visit((path, entry) => {\n            if (!entry) {\n                return;\n            }\n            const newEntry = operator(entry);\n            if (newEntry === entry) {\n                return;\n            }\n            if (newEntry === null) {\n                tree.delete(path);\n                return;\n            }\n            if (newEntry.path != path) {\n                tree.rename(path, newEntry.path);\n            }\n            if (!newEntry.content.equals(entry.content)) {\n                tree.overwrite(newEntry.path, newEntry.content);\n            }\n        });\n    };\n}\nexports.forEach = forEach;\nfunction composeFileOperators(operators) {\n    return (entry) => {\n        let current = entry;\n        for (const op of operators) {\n            current = op(current);\n            if (current === null) {\n                // Deleted, just return.\n                return null;\n            }\n        }\n        return current;\n    };\n}\nexports.composeFileOperators = composeFileOperators;\nfunction applyToSubtree(path, rules) {\n    return (tree, context) => {\n        const scoped = new scoped_1.ScopedTree(tree, path);\n        return (0, call_1.callRule)(chain(rules), scoped, context).pipe((0, operators_1.map)((result) => {\n            if (result === scoped) {\n                return tree;\n            }\n            else {\n                throw new exception_1.SchematicsException('Original tree must be returned from all rules when using \"applyToSubtree\".');\n            }\n        }));\n    };\n}\nexports.applyToSubtree = applyToSubtree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}