{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.schematic = exports.externalSchematic = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst interface_1 = require(\"../tree/interface\");\n\nconst static_1 = require(\"../tree/static\");\n/**\n * Run a schematic from a separate collection.\n *\n * @param collectionName The name of the collection that contains the schematic to run.\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\n\n\nfunction externalSchematic(collectionName, schematicName, options, executionOptions) {\n  return (input, context) => {\n    const collection = context.engine.createCollection(collectionName, context.schematic.collection);\n    const schematic = collection.createSchematic(schematicName);\n    return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)(x => {\n      input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n      return input;\n    }));\n  };\n}\n\nexports.externalSchematic = externalSchematic;\n/**\n * Run a schematic from the same collection.\n *\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\n\nfunction schematic(schematicName, options, executionOptions) {\n  return (input, context) => {\n    const collection = context.schematic.collection;\n    const schematic = collection.createSchematic(schematicName, true);\n    return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)(x => {\n      // We allow overwrite conflict here because they're the only merge conflict we particularly\n      // don't want to deal with; the input tree might have an OVERWRITE which the sub\n      input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n      return input;\n    }));\n  };\n}\n\nexports.schematic = schematic;","map":{"version":3,"names":["Object","defineProperty","exports","value","schematic","externalSchematic","rxjs_1","require","operators_1","interface_1","static_1","collectionName","schematicName","options","executionOptions","input","context","collection","engine","createCollection","createSchematic","call","of","branch","pipe","last","map","x","merge","MergeStrategy","AllowOverwriteConflict"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/schematics/src/rules/schematic.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.schematic = exports.externalSchematic = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst interface_1 = require(\"../tree/interface\");\nconst static_1 = require(\"../tree/static\");\n/**\n * Run a schematic from a separate collection.\n *\n * @param collectionName The name of the collection that contains the schematic to run.\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\nfunction externalSchematic(collectionName, schematicName, options, executionOptions) {\n    return (input, context) => {\n        const collection = context.engine.createCollection(collectionName, context.schematic.collection);\n        const schematic = collection.createSchematic(schematicName);\n        return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)((x) => {\n            input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n            return input;\n        }));\n    };\n}\nexports.externalSchematic = externalSchematic;\n/**\n * Run a schematic from the same collection.\n *\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\nfunction schematic(schematicName, options, executionOptions) {\n    return (input, context) => {\n        const collection = context.schematic.collection;\n        const schematic = collection.createSchematic(schematicName, true);\n        return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)((x) => {\n            // We allow overwrite conflict here because they're the only merge conflict we particularly\n            // don't want to deal with; the input tree might have an OVERWRITE which the sub\n            input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n            return input;\n        }));\n    };\n}\nexports.schematic = schematic;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoBF,OAAO,CAACG,iBAAR,GAA4B,KAAK,CAArD;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,gBAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,iBAAT,CAA2BM,cAA3B,EAA2CC,aAA3C,EAA0DC,OAA1D,EAAmEC,gBAAnE,EAAqF;EACjF,OAAO,CAACC,KAAD,EAAQC,OAAR,KAAoB;IACvB,MAAMC,UAAU,GAAGD,OAAO,CAACE,MAAR,CAAeC,gBAAf,CAAgCR,cAAhC,EAAgDK,OAAO,CAACZ,SAAR,CAAkBa,UAAlE,CAAnB;IACA,MAAMb,SAAS,GAAGa,UAAU,CAACG,eAAX,CAA2BR,aAA3B,CAAlB;IACA,OAAOR,SAAS,CAACiB,IAAV,CAAeR,OAAf,EAAwB,CAAC,GAAGP,MAAM,CAACgB,EAAX,EAAe,CAAC,GAAGZ,QAAQ,CAACa,MAAb,EAAqBR,KAArB,CAAf,CAAxB,EAAqEC,OAArE,EAA8EF,gBAA9E,EAAgGU,IAAhG,CAAqG,CAAC,GAAGhB,WAAW,CAACiB,IAAhB,GAArG,EAA8H,CAAC,GAAGjB,WAAW,CAACkB,GAAhB,EAAsBC,CAAD,IAAO;MAC7JZ,KAAK,CAACa,KAAN,CAAYD,CAAZ,EAAelB,WAAW,CAACoB,aAAZ,CAA0BC,sBAAzC;MACA,OAAOf,KAAP;IACH,CAHoI,CAA9H,CAAP;EAIH,CAPD;AAQH;;AACDb,OAAO,CAACG,iBAAR,GAA4BA,iBAA5B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,SAAT,CAAmBQ,aAAnB,EAAkCC,OAAlC,EAA2CC,gBAA3C,EAA6D;EACzD,OAAO,CAACC,KAAD,EAAQC,OAAR,KAAoB;IACvB,MAAMC,UAAU,GAAGD,OAAO,CAACZ,SAAR,CAAkBa,UAArC;IACA,MAAMb,SAAS,GAAGa,UAAU,CAACG,eAAX,CAA2BR,aAA3B,EAA0C,IAA1C,CAAlB;IACA,OAAOR,SAAS,CAACiB,IAAV,CAAeR,OAAf,EAAwB,CAAC,GAAGP,MAAM,CAACgB,EAAX,EAAe,CAAC,GAAGZ,QAAQ,CAACa,MAAb,EAAqBR,KAArB,CAAf,CAAxB,EAAqEC,OAArE,EAA8EF,gBAA9E,EAAgGU,IAAhG,CAAqG,CAAC,GAAGhB,WAAW,CAACiB,IAAhB,GAArG,EAA8H,CAAC,GAAGjB,WAAW,CAACkB,GAAhB,EAAsBC,CAAD,IAAO;MAC7J;MACA;MACAZ,KAAK,CAACa,KAAN,CAAYD,CAAZ,EAAelB,WAAW,CAACoB,aAAZ,CAA0BC,sBAAzC;MACA,OAAOf,KAAP;IACH,CALoI,CAA9H,CAAP;EAMH,CATD;AAUH;;AACDb,OAAO,CAACE,SAAR,GAAoBA,SAApB"},"metadata":{},"sourceType":"script"}