{"ast":null,"code":"// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\nconst semver = require('semver');\n\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {}\n}));\n\nconst finish = revs => distTags(shaList(peelTags(revs))); // We can check out shallow clones on specific SHAs if we have a ref\n\n\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref];\n\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref];\n    } else {\n      revs.shas[doc.sha].push(ref);\n    }\n  });\n  return revs;\n}; // Replace any tags with their ^{} counterparts, if those exist\n\n\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref];\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')];\n\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha;\n      delete revs.refs[ref];\n    }\n  });\n  return revs;\n};\n\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD ||\n  /* istanbul ignore next */\n  {};\n  const versions = Object.keys(revs.versions);\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v];\n\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v;\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v;\n\n      if (!revs.refs.latest) {\n        revs['dist-tags'].latest = v;\n      }\n    }\n  });\n  return revs;\n};\n\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag';\n  }\n\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch';\n  }\n\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull';\n  }\n\n  if (ref === 'HEAD') {\n    return 'head';\n  } // Could be anything, ignore for now\n\n  /* istanbul ignore next */\n\n\n  return 'other';\n}; // return the doc, or null if we should ignore it.\n\n\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2);\n\n  if (split.length < 2) {\n    return null;\n  }\n\n  const sha = split[0].trim();\n  const rawRef = split[1].trim();\n  const type = refType(rawRef);\n\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.slice('refs/tags/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'branch') {\n    const ref = rawRef.slice('refs/heads/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.slice('refs/'.length).replace(/\\/head$/, '');\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'head') {\n    const ref = 'HEAD';\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  } // at this point, all we can do is leave the ref un-munged\n\n\n  return {\n    sha,\n    ref: rawRef,\n    rawRef,\n    type\n  };\n};\n\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line);\n\n  if (!doc) {\n    return revs;\n  }\n\n  revs.refs[doc.ref] = doc;\n  revs.refs[doc.rawRef] = doc;\n\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') && doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/);\n\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc;\n    }\n  }\n\n  return revs;\n};","map":{"version":3,"names":["semver","require","module","exports","lines","finish","reduce","linesToRevsReducer","versions","refs","shas","revs","distTags","shaList","peelTags","Object","keys","forEach","ref","doc","sha","push","filter","endsWith","peeled","unpeeled","replace","HEAD","v","ver","latest","refType","startsWith","lineToRevDoc","line","split","trim","length","rawRef","type","slice","match","valid","clean"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@npmcli/git/lib/lines-to-revs.js"],"sourcesContent":["// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\n\nconst semver = require('semver')\n\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {},\n}))\n\nconst finish = revs => distTags(shaList(peelTags(revs)))\n\n// We can check out shallow clones on specific SHAs if we have a ref\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref]\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref]\n    } else {\n      revs.shas[doc.sha].push(ref)\n    }\n  })\n  return revs\n}\n\n// Replace any tags with their ^{} counterparts, if those exist\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref]\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')]\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha\n      delete revs.refs[ref]\n    }\n  })\n  return revs\n}\n\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD || /* istanbul ignore next */ {}\n  const versions = Object.keys(revs.versions)\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v]\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v\n      if (!revs.refs.latest) {\n        revs['dist-tags'].latest = v\n      }\n    }\n  })\n  return revs\n}\n\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag'\n  }\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch'\n  }\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull'\n  }\n  if (ref === 'HEAD') {\n    return 'head'\n  }\n  // Could be anything, ignore for now\n  /* istanbul ignore next */\n  return 'other'\n}\n\n// return the doc, or null if we should ignore it.\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2)\n  if (split.length < 2) {\n    return null\n  }\n\n  const sha = split[0].trim()\n  const rawRef = split[1].trim()\n  const type = refType(rawRef)\n\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.slice('refs/tags/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'branch') {\n    const ref = rawRef.slice('refs/heads/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.slice('refs/'.length).replace(/\\/head$/, '')\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'head') {\n    const ref = 'HEAD'\n    return { sha, ref, rawRef, type }\n  }\n\n  // at this point, all we can do is leave the ref un-munged\n  return { sha, ref: rawRef, rawRef, type }\n}\n\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line)\n\n  if (!doc) {\n    return revs\n  }\n\n  revs.refs[doc.ref] = doc\n  revs.refs[doc.rawRef] = doc\n\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') &&\n      doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/)\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc\n    }\n  }\n\n  return revs\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}