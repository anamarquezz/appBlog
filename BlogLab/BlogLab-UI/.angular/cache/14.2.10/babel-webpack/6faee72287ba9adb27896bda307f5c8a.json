{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst fsm = require('fs-minipass');\n\nconst cacache = require('cacache');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _exeBins = Symbol('_exeBins');\n\nconst {\n  resolve\n} = require('path');\n\nconst fs = require('fs');\n\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson');\n\nclass FileFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // just the fully resolved filename\n\n    this.resolved = this.spec.fetchSpec;\n  }\n\n  get types() {\n    return ['file'];\n  }\n\n  manifest() {\n    if (this.package) {\n      return Promise.resolve(this.package);\n    } // have to unpack the tarball for this.\n\n\n    return cacache.tmp.withTmp(this.cache, this.opts, dir => this.extract(dir).then(() => this[_readPackageJson](dir + '/package.json')).then(mani => this.package = { ...mani,\n      _integrity: this.integrity && String(this.integrity),\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n\n  [_exeBins](pkg, dest) {\n    if (!pkg.bin) {\n      return Promise.resolve();\n    }\n\n    return Promise.all(Object.keys(pkg.bin).map(k => new Promise(res => {\n      const script = resolve(dest, pkg.bin[k]); // Best effort.  Ignore errors here, the only result is that\n      // a bin script is not executable.  But if it's missing or\n      // something, we just leave it for a later stage to trip over\n      // when we can provide a more useful contextual error.\n\n      fs.stat(script, (er, st) => {\n        if (er) {\n          return res();\n        }\n\n        const mode = st.mode | 0o111;\n\n        if (mode === st.mode) {\n          return res();\n        }\n\n        fs.chmod(script, mode, res);\n      });\n    })));\n  }\n\n  extract(dest) {\n    // if we've already loaded the manifest, then the super got it.\n    // but if not, read the unpacked manifest and chmod properly.\n    return super.extract(dest).then(result => this.package ? result : this[_readPackageJson](dest + '/package.json').then(pkg => this[_exeBins](pkg, dest)).then(() => result));\n  }\n\n  [_tarballFromResolved]() {\n    // create a read stream and return it\n    return new fsm.ReadStream(this.resolved);\n  }\n\n  packument() {\n    // simulate based on manifest\n    return this.manifest().then(mani => ({\n      name: mani.name,\n      'dist-tags': {\n        [this.defaultTag]: mani.version\n      },\n      versions: {\n        [mani.version]: { ...mani,\n          dist: {\n            tarball: `file:${this.resolved}`,\n            integrity: this.integrity && String(this.integrity)\n          }\n        }\n      }\n    }));\n  }\n\n}\n\nmodule.exports = FileFetcher;","map":{"version":3,"names":["Fetcher","require","fsm","cacache","_tarballFromResolved","Symbol","for","_exeBins","resolve","fs","_readPackageJson","FileFetcher","constructor","spec","opts","resolved","fetchSpec","types","manifest","package","Promise","tmp","withTmp","cache","dir","extract","then","mani","_integrity","integrity","String","_resolved","_from","from","pkg","dest","bin","all","Object","keys","map","k","res","script","stat","er","st","mode","chmod","result","ReadStream","packument","name","defaultTag","version","versions","dist","tarball","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/pacote/lib/file.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _exeBins = Symbol('_exeBins')\nconst { resolve } = require('path')\nconst fs = require('fs')\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson')\n\nclass FileFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    // just the fully resolved filename\n    this.resolved = this.spec.fetchSpec\n  }\n\n  get types () {\n    return ['file']\n  }\n\n  manifest () {\n    if (this.package) {\n      return Promise.resolve(this.package)\n    }\n\n    // have to unpack the tarball for this.\n    return cacache.tmp.withTmp(this.cache, this.opts, dir =>\n      this.extract(dir)\n        .then(() => this[_readPackageJson](dir + '/package.json'))\n        .then(mani => this.package = {\n          ...mani,\n          _integrity: this.integrity && String(this.integrity),\n          _resolved: this.resolved,\n          _from: this.from,\n        }))\n  }\n\n  [_exeBins] (pkg, dest) {\n    if (!pkg.bin) {\n      return Promise.resolve()\n    }\n\n    return Promise.all(Object.keys(pkg.bin).map(k => new Promise(res => {\n      const script = resolve(dest, pkg.bin[k])\n      // Best effort.  Ignore errors here, the only result is that\n      // a bin script is not executable.  But if it's missing or\n      // something, we just leave it for a later stage to trip over\n      // when we can provide a more useful contextual error.\n      fs.stat(script, (er, st) => {\n        if (er) {\n          return res()\n        }\n        const mode = st.mode | 0o111\n        if (mode === st.mode) {\n          return res()\n        }\n        fs.chmod(script, mode, res)\n      })\n    })))\n  }\n\n  extract (dest) {\n    // if we've already loaded the manifest, then the super got it.\n    // but if not, read the unpacked manifest and chmod properly.\n    return super.extract(dest)\n      .then(result => this.package ? result\n      : this[_readPackageJson](dest + '/package.json').then(pkg =>\n        this[_exeBins](pkg, dest)).then(() => result))\n  }\n\n  [_tarballFromResolved] () {\n    // create a read stream and return it\n    return new fsm.ReadStream(this.resolved)\n  }\n\n  packument () {\n    // simulate based on manifest\n    return this.manifest().then(mani => ({\n      name: mani.name,\n      'dist-tags': {\n        [this.defaultTag]: mani.version,\n      },\n      versions: {\n        [mani.version]: {\n          ...mani,\n          dist: {\n            tarball: `file:${this.resolved}`,\n            integrity: this.integrity && String(this.integrity),\n          },\n        },\n      },\n    }))\n  }\n}\n\nmodule.exports = FileFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}