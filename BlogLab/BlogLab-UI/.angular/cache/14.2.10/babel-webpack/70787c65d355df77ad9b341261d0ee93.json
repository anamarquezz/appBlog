{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitJsonSchema = exports.visitJson = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst pointer_1 = require(\"./pointer\");\n\nfunction _getObjectSubSchema(schema, key) {\n  if (typeof schema !== 'object' || schema === null) {\n    return undefined;\n  } // Is it an object schema?\n\n\n  if (typeof schema.properties == 'object' || schema.type == 'object') {\n    if (typeof schema.properties == 'object' && typeof schema.properties[key] == 'object') {\n      return schema.properties[key];\n    }\n\n    if (typeof schema.additionalProperties == 'object') {\n      return schema.additionalProperties;\n    }\n\n    return undefined;\n  } // Is it an array schema?\n\n\n  if (typeof schema.items == 'object' || schema.type == 'array') {\n    return typeof schema.items == 'object' ? schema.items : undefined;\n  }\n\n  return undefined;\n}\n\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n  if (schema === true || schema === false) {\n    // There's no schema definition, so just visit the JSON recursively.\n    schema = undefined;\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n    if (refResolver) {\n      const resolved = refResolver(schema['$ref'], context);\n      schema = resolved.schema;\n      context = resolved.context;\n    }\n  }\n\n  const value = visitor(json, ptr, schema, root);\n  return ((0, rxjs_1.isObservable)(value) ? value : (0, rxjs_1.of)(value)).pipe((0, operators_1.concatMap)(value => {\n    if (Array.isArray(value)) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(value).pipe((0, operators_1.mergeMap)((item, i) => {\n        return _visitJsonRecursive(item, visitor, (0, pointer_1.joinJsonPointer)(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe((0, operators_1.tap)(x => value[i] = x));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else if (typeof value == 'object' && value !== null) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(Object.getOwnPropertyNames(value)).pipe((0, operators_1.mergeMap)(key => {\n        return _visitJsonRecursive(value[key], visitor, (0, pointer_1.joinJsonPointer)(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe((0, operators_1.tap)(x => {\n          const descriptor = Object.getOwnPropertyDescriptor(value, key);\n\n          if (descriptor && descriptor.writable && value[key] !== x) {\n            value[key] = x;\n          }\n        }));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else {\n      return (0, rxjs_1.of)(value);\n    }\n  }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\n\n\nfunction visitJson(json, visitor, schema, refResolver, context) {\n  return _visitJsonRecursive(json, visitor, (0, pointer_1.buildJsonPointer)([]), schema, refResolver, context);\n}\n\nexports.visitJson = visitJson;\n\nfunction visitJsonSchema(schema, visitor) {\n  if (schema === false || schema === true) {\n    // Nothing to visit.\n    return;\n  }\n\n  const keywords = {\n    additionalItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    propertyNames: true,\n    not: true\n  };\n  const arrayKeywords = {\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n  };\n  const propsKeywords = {\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    dependencies: true,\n    items: true\n  };\n\n  function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n      visitor(schema, jsonPtr, parentSchema, keyIndex);\n\n      for (const key of Object.keys(schema)) {\n        const sch = schema[key];\n\n        if (key in propsKeywords) {\n          if (sch && typeof sch == 'object') {\n            for (const prop of Object.keys(sch)) {\n              _traverse(sch[prop], (0, pointer_1.joinJsonPointer)(jsonPtr, key, prop), rootSchema, schema, prop);\n            }\n          }\n        } else if (key in keywords) {\n          _traverse(sch, (0, pointer_1.joinJsonPointer)(jsonPtr, key), rootSchema, schema, key);\n        } else if (key in arrayKeywords) {\n          if (Array.isArray(sch)) {\n            for (let i = 0; i < sch.length; i++) {\n              _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n            }\n          }\n        } else if (Array.isArray(sch)) {\n          for (let i = 0; i < sch.length; i++) {\n            _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n          }\n        }\n      }\n    }\n  }\n\n  _traverse(schema, (0, pointer_1.buildJsonPointer)([]), schema);\n}\n\nexports.visitJsonSchema = visitJsonSchema;","map":{"version":3,"names":["Object","defineProperty","exports","value","visitJsonSchema","visitJson","rxjs_1","require","operators_1","pointer_1","_getObjectSubSchema","schema","key","undefined","properties","type","additionalProperties","items","_visitJsonRecursive","json","visitor","ptr","refResolver","context","root","hasOwnProperty","resolved","isObservable","of","pipe","concatMap","Array","isArray","concat","from","mergeMap","item","i","joinJsonPointer","tap","x","ignoreElements","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","writable","buildJsonPointer","keywords","additionalItems","contains","propertyNames","not","arrayKeywords","allOf","anyOf","oneOf","propsKeywords","definitions","patternProperties","dependencies","_traverse","jsonPtr","rootSchema","parentSchema","keyIndex","keys","sch","prop","length"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/json/schema/visitor.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitJsonSchema = exports.visitJson = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst pointer_1 = require(\"./pointer\");\nfunction _getObjectSubSchema(schema, key) {\n    if (typeof schema !== 'object' || schema === null) {\n        return undefined;\n    }\n    // Is it an object schema?\n    if (typeof schema.properties == 'object' || schema.type == 'object') {\n        if (typeof schema.properties == 'object' &&\n            typeof schema.properties[key] == 'object') {\n            return schema.properties[key];\n        }\n        if (typeof schema.additionalProperties == 'object') {\n            return schema.additionalProperties;\n        }\n        return undefined;\n    }\n    // Is it an array schema?\n    if (typeof schema.items == 'object' || schema.type == 'array') {\n        return typeof schema.items == 'object' ? schema.items : undefined;\n    }\n    return undefined;\n}\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n    if (schema === true || schema === false) {\n        // There's no schema definition, so just visit the JSON recursively.\n        schema = undefined;\n    }\n    // eslint-disable-next-line no-prototype-builtins\n    if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n        if (refResolver) {\n            const resolved = refResolver(schema['$ref'], context);\n            schema = resolved.schema;\n            context = resolved.context;\n        }\n    }\n    const value = visitor(json, ptr, schema, root);\n    return ((0, rxjs_1.isObservable)(value) ? value : (0, rxjs_1.of)(value)).pipe((0, operators_1.concatMap)((value) => {\n        if (Array.isArray(value)) {\n            return (0, rxjs_1.concat)((0, rxjs_1.from)(value).pipe((0, operators_1.mergeMap)((item, i) => {\n                return _visitJsonRecursive(item, visitor, (0, pointer_1.joinJsonPointer)(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe((0, operators_1.tap)((x) => (value[i] = x)));\n            }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n        }\n        else if (typeof value == 'object' && value !== null) {\n            return (0, rxjs_1.concat)((0, rxjs_1.from)(Object.getOwnPropertyNames(value)).pipe((0, operators_1.mergeMap)((key) => {\n                return _visitJsonRecursive(value[key], visitor, (0, pointer_1.joinJsonPointer)(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe((0, operators_1.tap)((x) => {\n                    const descriptor = Object.getOwnPropertyDescriptor(value, key);\n                    if (descriptor && descriptor.writable && value[key] !== x) {\n                        value[key] = x;\n                    }\n                }));\n            }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n        }\n        else {\n            return (0, rxjs_1.of)(value);\n        }\n    }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\nfunction visitJson(json, visitor, schema, refResolver, context) {\n    return _visitJsonRecursive(json, visitor, (0, pointer_1.buildJsonPointer)([]), schema, refResolver, context);\n}\nexports.visitJson = visitJson;\nfunction visitJsonSchema(schema, visitor) {\n    if (schema === false || schema === true) {\n        // Nothing to visit.\n        return;\n    }\n    const keywords = {\n        additionalItems: true,\n        items: true,\n        contains: true,\n        additionalProperties: true,\n        propertyNames: true,\n        not: true,\n    };\n    const arrayKeywords = {\n        items: true,\n        allOf: true,\n        anyOf: true,\n        oneOf: true,\n    };\n    const propsKeywords = {\n        definitions: true,\n        properties: true,\n        patternProperties: true,\n        additionalProperties: true,\n        dependencies: true,\n        items: true,\n    };\n    function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n        if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n            visitor(schema, jsonPtr, parentSchema, keyIndex);\n            for (const key of Object.keys(schema)) {\n                const sch = schema[key];\n                if (key in propsKeywords) {\n                    if (sch && typeof sch == 'object') {\n                        for (const prop of Object.keys(sch)) {\n                            _traverse(sch[prop], (0, pointer_1.joinJsonPointer)(jsonPtr, key, prop), rootSchema, schema, prop);\n                        }\n                    }\n                }\n                else if (key in keywords) {\n                    _traverse(sch, (0, pointer_1.joinJsonPointer)(jsonPtr, key), rootSchema, schema, key);\n                }\n                else if (key in arrayKeywords) {\n                    if (Array.isArray(sch)) {\n                        for (let i = 0; i < sch.length; i++) {\n                            _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                        }\n                    }\n                }\n                else if (Array.isArray(sch)) {\n                    for (let i = 0; i < sch.length; i++) {\n                        _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                    }\n                }\n            }\n        }\n    }\n    _traverse(schema, (0, pointer_1.buildJsonPointer)([]), schema);\n}\nexports.visitJsonSchema = visitJsonSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}