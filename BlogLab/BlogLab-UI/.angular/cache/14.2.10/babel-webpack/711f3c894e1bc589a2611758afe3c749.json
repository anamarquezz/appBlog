{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSystemPath = exports.asPosixPath = exports.asWindowsPath = exports.path = exports.noCacheNormalize = exports.normalize = exports.resetNormalizeCache = exports.fragment = exports.resolve = exports.relative = exports.isAbsolute = exports.join = exports.dirname = exports.basename = exports.extname = exports.split = exports.NormalizedRoot = exports.NormalizedSep = exports.PathCannotBeFragmentException = exports.PathMustBeAbsoluteException = exports.InvalidPathException = void 0;\n\nconst exception_1 = require(\"../exception\");\n\nclass InvalidPathException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} is invalid.`);\n  }\n\n}\n\nexports.InvalidPathException = InvalidPathException;\n\nclass PathMustBeAbsoluteException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} must be absolute.`);\n  }\n\n}\n\nexports.PathMustBeAbsoluteException = PathMustBeAbsoluteException;\n\nclass PathCannotBeFragmentException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} cannot be made a fragment.`);\n  }\n\n}\n\nexports.PathCannotBeFragmentException = PathCannotBeFragmentException;\n/**\n * The Separator for normalized path.\n * @type {Path}\n */\n\nexports.NormalizedSep = '/';\n/**\n * The root of a normalized path.\n * @type {Path}\n */\n\nexports.NormalizedRoot = exports.NormalizedSep;\n/**\n * Split a path into multiple path fragments. Each fragments except the last one will end with\n * a path separator.\n * @param {Path} path The path to split.\n * @returns {Path[]} An array of path fragments.\n */\n\nfunction split(path) {\n  const fragments = path.split(exports.NormalizedSep).map(x => fragment(x));\n\n  if (fragments[fragments.length - 1].length === 0) {\n    fragments.pop();\n  }\n\n  return fragments;\n}\n\nexports.split = split;\n/**\n *\n */\n\nfunction extname(path) {\n  const base = basename(path);\n  const i = base.lastIndexOf('.');\n\n  if (i < 1) {\n    return '';\n  } else {\n    return base.slice(i);\n  }\n}\n\nexports.extname = extname;\n/**\n * Return the basename of the path, as a Path. See path.basename\n */\n\nfunction basename(path) {\n  const i = path.lastIndexOf(exports.NormalizedSep);\n\n  if (i == -1) {\n    return fragment(path);\n  } else {\n    return fragment(path.slice(path.lastIndexOf(exports.NormalizedSep) + 1));\n  }\n}\n\nexports.basename = basename;\n/**\n * Return the dirname of the path, as a Path. See path.dirname\n */\n\nfunction dirname(path) {\n  const index = path.lastIndexOf(exports.NormalizedSep);\n\n  if (index === -1) {\n    return '';\n  }\n\n  const endIndex = index === 0 ? 1 : index; // case of file under root: '/file'\n\n  return normalize(path.slice(0, endIndex));\n}\n\nexports.dirname = dirname;\n/**\n * Join multiple paths together, and normalize the result. Accepts strings that will be\n * normalized as well (but the original must be a path).\n */\n\nfunction join(p1, ...others) {\n  if (others.length > 0) {\n    return normalize((p1 ? p1 + exports.NormalizedSep : '') + others.join(exports.NormalizedSep));\n  } else {\n    return p1;\n  }\n}\n\nexports.join = join;\n/**\n * Returns true if a path is absolute.\n */\n\nfunction isAbsolute(p) {\n  return p.startsWith(exports.NormalizedSep);\n}\n\nexports.isAbsolute = isAbsolute;\n/**\n * Returns a path such that `join(from, relative(from, to)) == to`.\n * Both paths must be absolute, otherwise it does not make much sense.\n */\n\nfunction relative(from, to) {\n  if (!isAbsolute(from)) {\n    throw new PathMustBeAbsoluteException(from);\n  }\n\n  if (!isAbsolute(to)) {\n    throw new PathMustBeAbsoluteException(to);\n  }\n\n  let p;\n\n  if (from == to) {\n    p = '';\n  } else {\n    const splitFrom = split(from);\n    const splitTo = split(to);\n\n    while (splitFrom.length > 0 && splitTo.length > 0 && splitFrom[0] == splitTo[0]) {\n      splitFrom.shift();\n      splitTo.shift();\n    }\n\n    if (splitFrom.length == 0) {\n      p = splitTo.join(exports.NormalizedSep);\n    } else {\n      p = splitFrom.map(() => '..').concat(splitTo).join(exports.NormalizedSep);\n    }\n  }\n\n  return normalize(p);\n}\n\nexports.relative = relative;\n/**\n * Returns a Path that is the resolution of p2, from p1. If p2 is absolute, it will return p2,\n * otherwise will join both p1 and p2.\n */\n\nfunction resolve(p1, p2) {\n  if (isAbsolute(p2)) {\n    return p2;\n  } else {\n    return join(p1, p2);\n  }\n}\n\nexports.resolve = resolve;\n\nfunction fragment(path) {\n  if (path.indexOf(exports.NormalizedSep) != -1) {\n    throw new PathCannotBeFragmentException(path);\n  }\n\n  return path;\n}\n\nexports.fragment = fragment;\n/**\n * normalize() cache to reduce computation. For now this grows and we never flush it, but in the\n * future we might want to add a few cache flush to prevent this from growing too large.\n */\n\nlet normalizedCache = new Map();\n/**\n * Reset the cache. This is only useful for testing.\n * @private\n */\n\nfunction resetNormalizeCache() {\n  normalizedCache = new Map();\n}\n\nexports.resetNormalizeCache = resetNormalizeCache;\n/**\n * Normalize a string into a Path. This is the only mean to get a Path type from a string that\n * represents a system path. This method cache the results as real world paths tend to be\n * duplicated often.\n * Normalization includes:\n *   - Windows backslashes `\\\\` are replaced with `/`.\n *   - Windows drivers are replaced with `/X/`, where X is the drive letter.\n *   - Absolute paths starts with `/`.\n *   - Multiple `/` are replaced by a single one.\n *   - Path segments `.` are removed.\n *   - Path segments `..` are resolved.\n *   - If a path is absolute, having a `..` at the start is invalid (and will throw).\n * @param path The path to be normalized.\n */\n\nfunction normalize(path) {\n  let maybePath = normalizedCache.get(path);\n\n  if (!maybePath) {\n    maybePath = noCacheNormalize(path);\n    normalizedCache.set(path, maybePath);\n  }\n\n  return maybePath;\n}\n\nexports.normalize = normalize;\n/**\n * The no cache version of the normalize() function. Used for benchmarking and testing.\n */\n\nfunction noCacheNormalize(path) {\n  if (path == '' || path == '.') {\n    return '';\n  } else if (path == exports.NormalizedRoot) {\n    return exports.NormalizedRoot;\n  } // Match absolute windows path.\n\n\n  const original = path;\n\n  if (path.match(/^[A-Z]:[/\\\\]/i)) {\n    path = '\\\\' + path[0] + '\\\\' + path.slice(3);\n  } // We convert Windows paths as well here.\n\n\n  const p = path.split(/[/\\\\]/g);\n  let relative = false;\n  let i = 1; // Special case the first one.\n\n  if (p[0] != '') {\n    p.unshift('.');\n    relative = true;\n  }\n\n  while (i < p.length) {\n    if (p[i] == '.') {\n      p.splice(i, 1);\n    } else if (p[i] == '..') {\n      if (i < 2 && !relative) {\n        throw new InvalidPathException(original);\n      } else if (i >= 2 && p[i - 1] != '..') {\n        p.splice(i - 1, 2);\n        i--;\n      } else {\n        i++;\n      }\n    } else if (p[i] == '') {\n      p.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  if (p.length == 1) {\n    return p[0] == '' ? exports.NormalizedSep : '';\n  } else {\n    if (p[0] == '.') {\n      p.shift();\n    }\n\n    return p.join(exports.NormalizedSep);\n  }\n}\n\nexports.noCacheNormalize = noCacheNormalize;\n\nconst path = (strings, ...values) => {\n  return normalize(String.raw(strings, ...values));\n};\n\nexports.path = path;\n\nfunction asWindowsPath(path) {\n  const drive = path.match(/^\\/(\\w)(?:\\/(.*))?$/);\n\n  if (drive) {\n    const subPath = drive[2] ? drive[2].replace(/\\//g, '\\\\') : '';\n    return `${drive[1]}:\\\\${subPath}`;\n  }\n\n  return path.replace(/\\//g, '\\\\');\n}\n\nexports.asWindowsPath = asWindowsPath;\n\nfunction asPosixPath(path) {\n  return path;\n}\n\nexports.asPosixPath = asPosixPath;\n\nfunction getSystemPath(path) {\n  if (process.platform.startsWith('win32')) {\n    return asWindowsPath(path);\n  } else {\n    return asPosixPath(path);\n  }\n}\n\nexports.getSystemPath = getSystemPath;","map":{"version":3,"names":["Object","defineProperty","exports","value","getSystemPath","asPosixPath","asWindowsPath","path","noCacheNormalize","normalize","resetNormalizeCache","fragment","resolve","relative","isAbsolute","join","dirname","basename","extname","split","NormalizedRoot","NormalizedSep","PathCannotBeFragmentException","PathMustBeAbsoluteException","InvalidPathException","exception_1","require","BaseException","constructor","JSON","stringify","fragments","map","x","length","pop","base","i","lastIndexOf","slice","index","endIndex","p1","others","p","startsWith","from","to","splitFrom","splitTo","shift","concat","p2","indexOf","normalizedCache","Map","maybePath","get","set","original","match","unshift","splice","strings","values","String","raw","drive","subPath","replace","process","platform"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/virtual-fs/path.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSystemPath = exports.asPosixPath = exports.asWindowsPath = exports.path = exports.noCacheNormalize = exports.normalize = exports.resetNormalizeCache = exports.fragment = exports.resolve = exports.relative = exports.isAbsolute = exports.join = exports.dirname = exports.basename = exports.extname = exports.split = exports.NormalizedRoot = exports.NormalizedSep = exports.PathCannotBeFragmentException = exports.PathMustBeAbsoluteException = exports.InvalidPathException = void 0;\nconst exception_1 = require(\"../exception\");\nclass InvalidPathException extends exception_1.BaseException {\n    constructor(path) {\n        super(`Path ${JSON.stringify(path)} is invalid.`);\n    }\n}\nexports.InvalidPathException = InvalidPathException;\nclass PathMustBeAbsoluteException extends exception_1.BaseException {\n    constructor(path) {\n        super(`Path ${JSON.stringify(path)} must be absolute.`);\n    }\n}\nexports.PathMustBeAbsoluteException = PathMustBeAbsoluteException;\nclass PathCannotBeFragmentException extends exception_1.BaseException {\n    constructor(path) {\n        super(`Path ${JSON.stringify(path)} cannot be made a fragment.`);\n    }\n}\nexports.PathCannotBeFragmentException = PathCannotBeFragmentException;\n/**\n * The Separator for normalized path.\n * @type {Path}\n */\nexports.NormalizedSep = '/';\n/**\n * The root of a normalized path.\n * @type {Path}\n */\nexports.NormalizedRoot = exports.NormalizedSep;\n/**\n * Split a path into multiple path fragments. Each fragments except the last one will end with\n * a path separator.\n * @param {Path} path The path to split.\n * @returns {Path[]} An array of path fragments.\n */\nfunction split(path) {\n    const fragments = path.split(exports.NormalizedSep).map((x) => fragment(x));\n    if (fragments[fragments.length - 1].length === 0) {\n        fragments.pop();\n    }\n    return fragments;\n}\nexports.split = split;\n/**\n *\n */\nfunction extname(path) {\n    const base = basename(path);\n    const i = base.lastIndexOf('.');\n    if (i < 1) {\n        return '';\n    }\n    else {\n        return base.slice(i);\n    }\n}\nexports.extname = extname;\n/**\n * Return the basename of the path, as a Path. See path.basename\n */\nfunction basename(path) {\n    const i = path.lastIndexOf(exports.NormalizedSep);\n    if (i == -1) {\n        return fragment(path);\n    }\n    else {\n        return fragment(path.slice(path.lastIndexOf(exports.NormalizedSep) + 1));\n    }\n}\nexports.basename = basename;\n/**\n * Return the dirname of the path, as a Path. See path.dirname\n */\nfunction dirname(path) {\n    const index = path.lastIndexOf(exports.NormalizedSep);\n    if (index === -1) {\n        return '';\n    }\n    const endIndex = index === 0 ? 1 : index; // case of file under root: '/file'\n    return normalize(path.slice(0, endIndex));\n}\nexports.dirname = dirname;\n/**\n * Join multiple paths together, and normalize the result. Accepts strings that will be\n * normalized as well (but the original must be a path).\n */\nfunction join(p1, ...others) {\n    if (others.length > 0) {\n        return normalize((p1 ? p1 + exports.NormalizedSep : '') + others.join(exports.NormalizedSep));\n    }\n    else {\n        return p1;\n    }\n}\nexports.join = join;\n/**\n * Returns true if a path is absolute.\n */\nfunction isAbsolute(p) {\n    return p.startsWith(exports.NormalizedSep);\n}\nexports.isAbsolute = isAbsolute;\n/**\n * Returns a path such that `join(from, relative(from, to)) == to`.\n * Both paths must be absolute, otherwise it does not make much sense.\n */\nfunction relative(from, to) {\n    if (!isAbsolute(from)) {\n        throw new PathMustBeAbsoluteException(from);\n    }\n    if (!isAbsolute(to)) {\n        throw new PathMustBeAbsoluteException(to);\n    }\n    let p;\n    if (from == to) {\n        p = '';\n    }\n    else {\n        const splitFrom = split(from);\n        const splitTo = split(to);\n        while (splitFrom.length > 0 && splitTo.length > 0 && splitFrom[0] == splitTo[0]) {\n            splitFrom.shift();\n            splitTo.shift();\n        }\n        if (splitFrom.length == 0) {\n            p = splitTo.join(exports.NormalizedSep);\n        }\n        else {\n            p = splitFrom\n                .map(() => '..')\n                .concat(splitTo)\n                .join(exports.NormalizedSep);\n        }\n    }\n    return normalize(p);\n}\nexports.relative = relative;\n/**\n * Returns a Path that is the resolution of p2, from p1. If p2 is absolute, it will return p2,\n * otherwise will join both p1 and p2.\n */\nfunction resolve(p1, p2) {\n    if (isAbsolute(p2)) {\n        return p2;\n    }\n    else {\n        return join(p1, p2);\n    }\n}\nexports.resolve = resolve;\nfunction fragment(path) {\n    if (path.indexOf(exports.NormalizedSep) != -1) {\n        throw new PathCannotBeFragmentException(path);\n    }\n    return path;\n}\nexports.fragment = fragment;\n/**\n * normalize() cache to reduce computation. For now this grows and we never flush it, but in the\n * future we might want to add a few cache flush to prevent this from growing too large.\n */\nlet normalizedCache = new Map();\n/**\n * Reset the cache. This is only useful for testing.\n * @private\n */\nfunction resetNormalizeCache() {\n    normalizedCache = new Map();\n}\nexports.resetNormalizeCache = resetNormalizeCache;\n/**\n * Normalize a string into a Path. This is the only mean to get a Path type from a string that\n * represents a system path. This method cache the results as real world paths tend to be\n * duplicated often.\n * Normalization includes:\n *   - Windows backslashes `\\\\` are replaced with `/`.\n *   - Windows drivers are replaced with `/X/`, where X is the drive letter.\n *   - Absolute paths starts with `/`.\n *   - Multiple `/` are replaced by a single one.\n *   - Path segments `.` are removed.\n *   - Path segments `..` are resolved.\n *   - If a path is absolute, having a `..` at the start is invalid (and will throw).\n * @param path The path to be normalized.\n */\nfunction normalize(path) {\n    let maybePath = normalizedCache.get(path);\n    if (!maybePath) {\n        maybePath = noCacheNormalize(path);\n        normalizedCache.set(path, maybePath);\n    }\n    return maybePath;\n}\nexports.normalize = normalize;\n/**\n * The no cache version of the normalize() function. Used for benchmarking and testing.\n */\nfunction noCacheNormalize(path) {\n    if (path == '' || path == '.') {\n        return '';\n    }\n    else if (path == exports.NormalizedRoot) {\n        return exports.NormalizedRoot;\n    }\n    // Match absolute windows path.\n    const original = path;\n    if (path.match(/^[A-Z]:[/\\\\]/i)) {\n        path = '\\\\' + path[0] + '\\\\' + path.slice(3);\n    }\n    // We convert Windows paths as well here.\n    const p = path.split(/[/\\\\]/g);\n    let relative = false;\n    let i = 1;\n    // Special case the first one.\n    if (p[0] != '') {\n        p.unshift('.');\n        relative = true;\n    }\n    while (i < p.length) {\n        if (p[i] == '.') {\n            p.splice(i, 1);\n        }\n        else if (p[i] == '..') {\n            if (i < 2 && !relative) {\n                throw new InvalidPathException(original);\n            }\n            else if (i >= 2 && p[i - 1] != '..') {\n                p.splice(i - 1, 2);\n                i--;\n            }\n            else {\n                i++;\n            }\n        }\n        else if (p[i] == '') {\n            p.splice(i, 1);\n        }\n        else {\n            i++;\n        }\n    }\n    if (p.length == 1) {\n        return p[0] == '' ? exports.NormalizedSep : '';\n    }\n    else {\n        if (p[0] == '.') {\n            p.shift();\n        }\n        return p.join(exports.NormalizedSep);\n    }\n}\nexports.noCacheNormalize = noCacheNormalize;\nconst path = (strings, ...values) => {\n    return normalize(String.raw(strings, ...values));\n};\nexports.path = path;\nfunction asWindowsPath(path) {\n    const drive = path.match(/^\\/(\\w)(?:\\/(.*))?$/);\n    if (drive) {\n        const subPath = drive[2] ? drive[2].replace(/\\//g, '\\\\') : '';\n        return `${drive[1]}:\\\\${subPath}`;\n    }\n    return path.replace(/\\//g, '\\\\');\n}\nexports.asWindowsPath = asWindowsPath;\nfunction asPosixPath(path) {\n    return path;\n}\nexports.asPosixPath = asPosixPath;\nfunction getSystemPath(path) {\n    if (process.platform.startsWith('win32')) {\n        return asWindowsPath(path);\n    }\n    else {\n        return asPosixPath(path);\n    }\n}\nexports.getSystemPath = getSystemPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}