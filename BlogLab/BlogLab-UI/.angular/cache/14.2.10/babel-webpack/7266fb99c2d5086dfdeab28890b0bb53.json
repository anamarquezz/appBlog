{"ast":null,"code":"const CacheSemantics = require('http-cache-semantics');\n\nconst Negotiator = require('negotiator');\n\nconst ssri = require('ssri'); // options passed to http-cache-semantics constructor\n\n\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true\n}; // a fake empty response, used when only testing the\n// request for storability\n\nconst emptyResponse = {\n  status: 200,\n  headers: {}\n}; // returns a plain object representation of the Request\n\nconst requestObject = request => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n    compress: request.compress\n  };\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n}; // returns a plain object representation of the Response\n\n\nconst responseObject = response => {\n  const _obj = {\n    status: response.status,\n    headers: {}\n  };\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\n\nclass CachePolicy {\n  constructor({\n    entry,\n    request,\n    response,\n    options\n  }) {\n    this.entry = entry;\n    this.request = requestObject(request);\n    this.response = responseObject(response);\n    this.options = options;\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions);\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time;\n    }\n  } // static method to quickly determine if a request alone is storable\n\n\n  static storable(request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) {\n      return false;\n    } // user explicitly asked not to cache\n\n\n    if (options.cache === 'no-store') {\n      return false;\n    } // we only cache GET and HEAD requests\n\n\n    if (!['GET', 'HEAD'].includes(request.method)) {\n      return false;\n    } // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n\n\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);\n    return policy.storable();\n  } // returns true if the policy satisfies the request\n\n\n  satisfies(request) {\n    const _req = requestObject(request);\n\n    if (this.request.headers.host !== _req.headers.host) {\n      return false;\n    }\n\n    if (this.request.compress !== _req.compress) {\n      return false;\n    }\n\n    const negotiatorA = new Negotiator(this.request);\n    const negotiatorB = new Negotiator(_req);\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) {\n      return false;\n    }\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) {\n      return false;\n    }\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) {\n      return false;\n    }\n\n    if (this.options.integrity) {\n      return ssri.parse(this.options.integrity).match(this.entry.integrity);\n    }\n\n    return true;\n  } // returns true if the request and response allow caching\n\n\n  storable() {\n    return this.policy.storable();\n  } // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n\n\n  get mustRevalidate() {\n    return !!this.policy._rescc['must-revalidate'];\n  } // returns true if the cached response requires revalidation\n  // for the given request\n\n\n  needsRevalidation(request) {\n    const _req = requestObject(request); // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n\n\n    _req.method = 'GET';\n    return !this.policy.satisfiesWithoutRevalidation(_req);\n  }\n\n  responseHeaders() {\n    return this.policy.responseHeaders();\n  } // returns a new object containing the appropriate headers\n  // to send a revalidation request\n\n\n  revalidationHeaders(request) {\n    const _req = requestObject(request);\n\n    return this.policy.revalidationHeaders(_req);\n  } // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n\n\n  revalidated(request, response) {\n    const _req = requestObject(request);\n\n    const _res = responseObject(response);\n\n    const policy = this.policy.revalidatedPolicy(_req, _res);\n    return !policy.modified;\n  }\n\n}\n\nmodule.exports = CachePolicy;","map":{"version":3,"names":["CacheSemantics","require","Negotiator","ssri","policyOptions","shared","ignoreCargoCult","emptyResponse","status","headers","requestObject","request","_obj","method","url","compress","forEach","value","key","responseObject","response","CachePolicy","constructor","entry","options","policy","_responseTime","metadata","time","storable","cachePath","cache","includes","satisfies","_req","host","negotiatorA","negotiatorB","JSON","stringify","mediaTypes","languages","encodings","integrity","parse","match","mustRevalidate","_rescc","needsRevalidation","satisfiesWithoutRevalidation","responseHeaders","revalidationHeaders","revalidated","_res","revalidatedPolicy","modified","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/make-fetch-happen/lib/cache/policy.js"],"sourcesContent":["const CacheSemantics = require('http-cache-semantics')\nconst Negotiator = require('negotiator')\nconst ssri = require('ssri')\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true,\n}\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = { status: 200, headers: {} }\n\n// returns a plain object representation of the Request\nconst requestObject = (request) => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n    compress: request.compress,\n  }\n\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\n// returns a plain object representation of the Response\nconst responseObject = (response) => {\n  const _obj = {\n    status: response.status,\n    headers: {},\n  }\n\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\nclass CachePolicy {\n  constructor ({ entry, request, response, options }) {\n    this.entry = entry\n    this.request = requestObject(request)\n    this.response = responseObject(response)\n    this.options = options\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions)\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable (request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) {\n      return false\n    }\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store') {\n      return false\n    }\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method)) {\n      return false\n    }\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions)\n    return policy.storable()\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies (request) {\n    const _req = requestObject(request)\n    if (this.request.headers.host !== _req.headers.host) {\n      return false\n    }\n\n    if (this.request.compress !== _req.compress) {\n      return false\n    }\n\n    const negotiatorA = new Negotiator(this.request)\n    const negotiatorB = new Negotiator(_req)\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) {\n      return false\n    }\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) {\n      return false\n    }\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) {\n      return false\n    }\n\n    if (this.options.integrity) {\n      return ssri.parse(this.options.integrity).match(this.entry.integrity)\n    }\n\n    return true\n  }\n\n  // returns true if the request and response allow caching\n  storable () {\n    return this.policy.storable()\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate () {\n    return !!this.policy._rescc['must-revalidate']\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation (request) {\n    const _req = requestObject(request)\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET'\n    return !this.policy.satisfiesWithoutRevalidation(_req)\n  }\n\n  responseHeaders () {\n    return this.policy.responseHeaders()\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders (request) {\n    const _req = requestObject(request)\n    return this.policy.revalidationHeaders(_req)\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated (request, response) {\n    const _req = requestObject(request)\n    const _res = responseObject(response)\n    const policy = this.policy.revalidatedPolicy(_req, _res)\n    return !policy.modified\n  }\n}\n\nmodule.exports = CachePolicy\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}