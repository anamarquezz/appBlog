{"ast":null,"code":"'use strict'; // Do a two-pass walk, first to get the list of packages that need to be\n// bundled, then again to get the actual files and folders.\n// Keep a cache of node_modules content and package.json data, so that the\n// second walk doesn't have to re-do all the same work.\n\nconst bundleWalk = require('npm-bundled');\n\nconst BundleWalker = bundleWalk.BundleWalker;\n\nconst ignoreWalk = require('ignore-walk');\n\nconst IgnoreWalker = ignoreWalk.Walker;\nconst rootBuiltinRules = Symbol('root-builtin-rules');\nconst packageNecessaryRules = Symbol('package-necessary-rules');\n\nconst path = require('path');\n\nconst normalizePackageBin = require('npm-normalize-package-bin'); // Weird side-effect of this: a readme (etc) file will be included\n// if it exists anywhere within a folder with a package.json file.\n// The original intent was only to include these files in the root,\n// but now users in the wild are dependent on that behavior for\n// localized documentation and other use cases.  Adding a `/` to\n// these rules, while tempting and arguably more \"correct\", is a\n// significant change that will break existing use cases.\n\n\nconst packageMustHaveFileNames = 'readme|copying|license|licence';\nconst packageMustHaves = `@(${packageMustHaveFileNames}){,.*[^~$]}`;\nconst packageMustHavesRE = new RegExp(`^(${packageMustHaveFileNames})(\\\\..*[^~$])?$`, 'i');\n\nconst fs = require('fs');\n\nconst glob = require('glob');\n\nconst globify = pattern => pattern.split('\\\\').join('/');\n\nconst readOutOfTreeIgnoreFiles = (root, rel, result = '') => {\n  for (const file of ['.npmignore', '.gitignore']) {\n    try {\n      const ignoreContent = fs.readFileSync(path.join(root, file), {\n        encoding: 'utf8'\n      });\n      result += ignoreContent + '\\n'; // break the loop immediately after concatting, this allows us to prioritize the\n      // .npmignore and discard the .gitignore if one exists\n\n      break;\n    } catch (err) {\n      // we ignore ENOENT errors completely because we don't care if the file doesn't exist\n      // but we throw everything else because failing to read a file that does exist is\n      // something that the user likely wants to know about. we don't need to test this.\n\n      /* istanbul ignore next */\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n  }\n\n  if (!rel) {\n    return result;\n  }\n\n  const firstRel = rel.split(path.sep)[0];\n  const newRoot = path.join(root, firstRel);\n  const newRel = path.relative(newRoot, path.join(root, rel));\n  return readOutOfTreeIgnoreFiles(newRoot, newRel, result);\n};\n\nconst pathHasPkg = input => {\n  if (!input.startsWith('node_modules/')) {\n    return false;\n  }\n\n  const segments = input.slice('node_modules/'.length).split('/', 2);\n  return segments[0].startsWith('@') ? segments.length === 2 : true;\n};\n\nconst pkgFromPath = input => {\n  const segments = input.slice('node_modules/'.length).split('/', 2);\n  return segments[0].startsWith('@') ? segments.join('/') : segments[0];\n};\n\nconst defaultRules = ['.npmignore', '.gitignore', '**/.git', '**/.svn', '**/.hg', '**/CVS', '**/.git/**', '**/.svn/**', '**/.hg/**', '**/CVS/**', '/.lock-wscript', '/.wafpickle-*', '/build/config.gypi', 'npm-debug.log', '**/.npmrc', '.*.swp', '.DS_Store', '**/.DS_Store/**', '._*', '**/._*/**', '*.orig', '/package-lock.json', '/yarn.lock', '/pnpm-lock.yaml', '/archived-packages/**']; // There may be others, but :?|<> are handled by node-tar\n\nconst nameIsBadForWindows = file => /\\*/.test(file);\n\nclass Walker extends IgnoreWalker {\n  constructor(opt) {\n    opt = opt || {}; // the order in which rules are applied.\n\n    opt.ignoreFiles = [rootBuiltinRules, 'package.json', '.npmignore', '.gitignore', packageNecessaryRules];\n    opt.includeEmpty = false;\n    opt.path = opt.path || process.cwd(); // only follow links in the root node_modules folder, because if those\n    // folders are included, it's because they're bundled, and bundles\n    // should include the contents, not the symlinks themselves.\n    // This regexp tests to see that we're either a node_modules folder,\n    // or a @scope within a node_modules folder, in the root's node_modules\n    // hierarchy (ie, not in test/foo/node_modules/ or something).\n\n    const followRe = /^(?:\\/node_modules\\/(?:@[^/]+\\/[^/]+|[^/]+)\\/)*\\/node_modules(?:\\/@[^/]+)?$/;\n    const rootPath = opt.parent ? opt.parent.root : opt.path;\n    const followTestPath = opt.path.replace(/\\\\/g, '/').slice(rootPath.length);\n    opt.follow = followRe.test(followTestPath);\n    super(opt); // ignore a bunch of things by default at the root level.\n    // also ignore anything in the main project node_modules hierarchy,\n    // except bundled dependencies\n\n    if (this.isProject) {\n      this.bundled = opt.bundled || [];\n      this.bundledScopes = Array.from(new Set(this.bundled.filter(f => /^@/.test(f)).map(f => f.split('/')[0])));\n      this.packageJsonCache = this.parent ? this.parent.packageJsonCache : opt.packageJsonCache || new Map();\n      let rules = defaultRules.join('\\n') + '\\n';\n\n      if (opt.prefix && opt.workspaces) {\n        const gPath = globify(opt.path);\n        const gPrefix = globify(opt.prefix);\n        const gWorkspaces = opt.workspaces.map(ws => globify(ws)); // if opt.path and opt.prefix are not the same directory, and opt.workspaces has opt.path\n        // in it, then we know that opt.path is a workspace directory. in order to not drop ignore\n        // rules from directories between the workspace root (opt.prefix) and the workspace itself\n        // (opt.path), we need to find and read those now\n\n        /* istanbul ignore else */\n\n        if (gPath !== gPrefix && gWorkspaces.includes(gPath)) {\n          // relpath is the relative path between the prefix and the parent of opt.path\n          // we use the parent because ignore-walk will read the files in opt.path already\n          const relpath = path.relative(opt.prefix, path.dirname(opt.path));\n          rules += readOutOfTreeIgnoreFiles(opt.prefix, relpath);\n        } else if (gPath === gPrefix) {\n          // on the other hand, if the path and the prefix are the same, then we ignore workspaces\n          // so that we don't pack workspaces inside of a root project\n          rules += opt.workspaces.map(ws => globify(path.relative(opt.path, ws))).join('\\n');\n        }\n      }\n\n      super.onReadIgnoreFile(rootBuiltinRules, rules, _ => _);\n    } else {\n      this.bundled = [];\n      this.bundledScopes = [];\n      this.packageJsonCache = this.parent.packageJsonCache;\n    }\n  }\n\n  get isProject() {\n    return !this.parent || this.parent.follow && this.isSymbolicLink;\n  }\n\n  onReaddir(entries) {\n    if (this.isProject) {\n      entries = entries.filter(e => e !== '.git' && !(e === 'node_modules' && this.bundled.length === 0));\n    } // if we have a package.json, then look in it for 'files'\n    // we _only_ do this in the root project, not bundled deps\n    // or other random folders.  Bundled deps are always assumed\n    // to be in the state the user wants to include them, and\n    // a package.json somewhere else might be a template or\n    // test or something else entirely.\n\n\n    if (!this.isProject || !entries.includes('package.json')) {\n      return super.onReaddir(entries);\n    } // when the cache has been seeded with the root manifest,\n    // we must respect that (it may differ from the filesystem)\n\n\n    const ig = path.resolve(this.path, 'package.json');\n\n    if (this.packageJsonCache.has(ig)) {\n      const pkg = this.packageJsonCache.get(ig); // fall back to filesystem when seeded manifest is invalid\n\n      if (!pkg || typeof pkg !== 'object') {\n        return this.readPackageJson(entries);\n      } // feels wonky, but this ensures package bin is _always_\n      // normalized, as well as guarding against invalid JSON\n\n\n      return this.getPackageFiles(entries, JSON.stringify(pkg));\n    }\n\n    this.readPackageJson(entries);\n  }\n\n  onReadPackageJson(entries, er, pkg) {\n    if (er) {\n      this.emit('error', er);\n    } else {\n      this.getPackageFiles(entries, pkg);\n    }\n  }\n\n  mustHaveFilesFromPackage(pkg) {\n    const files = [];\n\n    if (pkg.browser) {\n      files.push('/' + pkg.browser);\n    }\n\n    if (pkg.main) {\n      files.push('/' + pkg.main);\n    }\n\n    if (pkg.bin) {\n      // always an object because normalized already\n      for (const key in pkg.bin) {\n        files.push('/' + pkg.bin[key]);\n      }\n    }\n\n    files.push('/package.json', '/npm-shrinkwrap.json', '!/package-lock.json', packageMustHaves);\n    return files;\n  }\n\n  getPackageFiles(entries, pkg) {\n    try {\n      // XXX this could be changed to use read-package-json-fast\n      // which handles the normalizing of bins for us, and simplifies\n      // the test for bundleDependencies and bundledDependencies later.\n      // HOWEVER if we do this, we need to be sure that we're careful\n      // about what we write back out since rpj-fast removes some fields\n      // that the user likely wants to keep. it also would add a second\n      // file read that we would want to optimize away.\n      pkg = normalizePackageBin(JSON.parse(pkg.toString()));\n    } catch (er) {\n      // not actually a valid package.json\n      return super.onReaddir(entries);\n    }\n\n    const ig = path.resolve(this.path, 'package.json');\n    this.packageJsonCache.set(ig, pkg); // no files list, just return the normal readdir() result\n\n    if (!Array.isArray(pkg.files)) {\n      return super.onReaddir(entries);\n    }\n\n    pkg.files.push(...this.mustHaveFilesFromPackage(pkg)); // If the package has a files list, then it's unlikely to include\n    // node_modules, because why would you do that?  but since we use\n    // the files list as the effective readdir result, that means it\n    // looks like we don't have a node_modules folder at all unless we\n    // include it here.\n\n    if ((pkg.bundleDependencies || pkg.bundledDependencies) && entries.includes('node_modules')) {\n      pkg.files.push('node_modules');\n    }\n\n    const patterns = Array.from(new Set(pkg.files)).reduce((set, pattern) => {\n      const excl = pattern.match(/^!+/);\n\n      if (excl) {\n        pattern = pattern.slice(excl[0].length);\n      } // strip off any / or ./ from the start of the pattern.  /foo => foo, ./foo => foo\n\n\n      pattern = pattern.replace(/^\\.?\\/+/, ''); // an odd number of ! means a negated pattern.  !!foo ==> foo\n\n      const negate = excl && excl[0].length % 2 === 1;\n      set.push({\n        pattern,\n        negate\n      });\n      return set;\n    }, []);\n    let n = patterns.length;\n    const set = new Set();\n    const negates = new Set();\n    const results = [];\n\n    const then = (pattern, negate, er, fileList, i) => {\n      if (er) {\n        return this.emit('error', er);\n      }\n\n      results[i] = {\n        negate,\n        fileList\n      };\n\n      if (--n === 0) {\n        processResults(results);\n      }\n    };\n\n    const processResults = processed => {\n      for (const {\n        negate,\n        fileList\n      } of processed) {\n        if (negate) {\n          fileList.forEach(f => {\n            f = f.replace(/\\/+$/, '');\n            set.delete(f);\n            negates.add(f);\n          });\n        } else {\n          fileList.forEach(f => {\n            f = f.replace(/\\/+$/, '');\n            set.add(f);\n            negates.delete(f);\n          });\n        }\n      }\n\n      const list = Array.from(set); // replace the files array with our computed explicit set\n\n      pkg.files = list.concat(Array.from(negates).map(f => '!' + f));\n      const rdResult = Array.from(new Set(list.map(f => f.replace(/^\\/+/, ''))));\n      super.onReaddir(rdResult);\n    }; // maintain the index so that we process them in-order only once all\n    // are completed, otherwise the parallelism messes things up, since a\n    // glob like **/*.js will always be slower than a subsequent !foo.js\n\n\n    patterns.forEach(({\n      pattern,\n      negate\n    }, i) => this.globFiles(pattern, (er, res) => then(pattern, negate, er, res, i)));\n  }\n\n  filterEntry(entry, partial) {\n    // get the partial path from the root of the walk\n    const p = this.path.slice(this.root.length + 1);\n    const {\n      isProject\n    } = this;\n    const pkg = isProject && pathHasPkg(entry) ? pkgFromPath(entry) : null;\n    const rootNM = isProject && entry === 'node_modules';\n    const rootPJ = isProject && entry === 'package.json';\n    return (// if we're in a bundled package, check with the parent.\n      /^node_modules($|\\/)/i.test(p) && !this.isProject ? this.parent.filterEntry(this.basename + '/' + entry, partial) // if package is bundled, all files included\n      // also include @scope dirs for bundled scoped deps\n      // they'll be ignored if no files end up in them.\n      // However, this only matters if we're in the root.\n      // node_modules folders elsewhere, like lib/node_modules,\n      // should be included normally unless ignored.\n      : pkg ? this.bundled.indexOf(pkg) !== -1 || this.bundledScopes.indexOf(pkg) !== -1 // only walk top node_modules if we want to bundle something\n      : rootNM ? !!this.bundled.length // always include package.json at the root.\n      : rootPJ ? true // always include readmes etc in any included dir\n      : packageMustHavesRE.test(entry) ? true // npm-shrinkwrap and package.json always included in the root pkg\n      : isProject && (entry === 'npm-shrinkwrap.json' || entry === 'package.json') ? true // package-lock never included\n      : isProject && entry === 'package-lock.json' ? false // otherwise, follow ignore-walk's logic\n      : super.filterEntry(entry, partial)\n    );\n  }\n\n  filterEntries() {\n    if (this.ignoreRules['.npmignore']) {\n      this.ignoreRules['.gitignore'] = null;\n    }\n\n    this.filterEntries = super.filterEntries;\n    super.filterEntries();\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n\n    if (file === 'package.json' && !this.isProject) {\n      then();\n    } else if (this.packageJsonCache.has(ig)) {\n      this.onPackageJson(ig, this.packageJsonCache.get(ig), then);\n    } else {\n      super.addIgnoreFile(file, then);\n    }\n  }\n\n  onPackageJson(ig, pkg, then) {\n    this.packageJsonCache.set(ig, pkg);\n\n    if (Array.isArray(pkg.files)) {\n      // in this case we already included all the must-haves\n      super.onReadIgnoreFile('package.json', pkg.files.map(f => '!' + f).join('\\n') + '\\n', then);\n    } else {\n      // if there's a bin, browser or main, make sure we don't ignore it\n      // also, don't ignore the package.json itself, or any files that\n      // must be included in the package.\n      const rules = this.mustHaveFilesFromPackage(pkg).map(f => `!${f}`);\n      const data = rules.join('\\n') + '\\n';\n      super.onReadIgnoreFile(packageNecessaryRules, data, then);\n    }\n  } // override parent stat function to completely skip any filenames\n  // that will break windows entirely.\n  // XXX(isaacs) Next major version should make this an error instead.\n\n\n  stat({\n    entry,\n    file,\n    dir\n  }, then) {\n    if (nameIsBadForWindows(entry)) {\n      then();\n    } else {\n      super.stat({\n        entry,\n        file,\n        dir\n      }, then);\n    }\n  } // override parent onstat function to nix all symlinks, other than\n  // those coming out of the followed bundled symlink deps\n\n\n  onstat({\n    st,\n    entry,\n    file,\n    dir,\n    isSymbolicLink\n  }, then) {\n    if (st.isSymbolicLink()) {\n      then();\n    } else {\n      super.onstat({\n        st,\n        entry,\n        file,\n        dir,\n        isSymbolicLink\n      }, then);\n    }\n  }\n\n  onReadIgnoreFile(file, data, then) {\n    if (file === 'package.json') {\n      try {\n        const ig = path.resolve(this.path, file);\n        this.onPackageJson(ig, JSON.parse(data), then);\n      } catch (er) {\n        // ignore package.json files that are not json\n        then();\n      }\n    } else {\n      super.onReadIgnoreFile(file, data, then);\n    }\n  }\n\n  sort(a, b) {\n    // optimize for compressibility\n    // extname, then basename, then locale alphabetically\n    // https://twitter.com/isntitvacant/status/1131094910923231232\n    const exta = path.extname(a).toLowerCase();\n    const extb = path.extname(b).toLowerCase();\n    const basea = path.basename(a).toLowerCase();\n    const baseb = path.basename(b).toLowerCase();\n    return exta.localeCompare(extb, 'en') || basea.localeCompare(baseb, 'en') || a.localeCompare(b, 'en');\n  }\n\n  globFiles(pattern, cb) {\n    glob(globify(pattern), {\n      dot: true,\n      cwd: this.path,\n      nocase: true\n    }, cb);\n  }\n\n  readPackageJson(entries) {\n    fs.readFile(this.path + '/package.json', (er, pkg) => this.onReadPackageJson(entries, er, pkg));\n  }\n\n  walker(entry, opt, then) {\n    new Walker(this.walkerOpt(entry, opt)).on('done', then).start();\n  }\n\n}\n\nconst walk = (options, callback) => {\n  options = options || {};\n  const p = new Promise((resolve, reject) => {\n    const bw = new BundleWalker(options);\n    bw.on('done', bundled => {\n      options.bundled = bundled;\n      options.packageJsonCache = bw.packageJsonCache;\n      new Walker(options).on('done', resolve).on('error', reject).start();\n    });\n    bw.start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nmodule.exports = walk;\nwalk.Walker = Walker;","map":{"version":3,"names":["bundleWalk","require","BundleWalker","ignoreWalk","IgnoreWalker","Walker","rootBuiltinRules","Symbol","packageNecessaryRules","path","normalizePackageBin","packageMustHaveFileNames","packageMustHaves","packageMustHavesRE","RegExp","fs","glob","globify","pattern","split","join","readOutOfTreeIgnoreFiles","root","rel","result","file","ignoreContent","readFileSync","encoding","err","code","firstRel","sep","newRoot","newRel","relative","pathHasPkg","input","startsWith","segments","slice","length","pkgFromPath","defaultRules","nameIsBadForWindows","test","constructor","opt","ignoreFiles","includeEmpty","process","cwd","followRe","rootPath","parent","followTestPath","replace","follow","isProject","bundled","bundledScopes","Array","from","Set","filter","f","map","packageJsonCache","Map","rules","prefix","workspaces","gPath","gPrefix","gWorkspaces","ws","includes","relpath","dirname","onReadIgnoreFile","_","isSymbolicLink","onReaddir","entries","e","ig","resolve","has","pkg","get","readPackageJson","getPackageFiles","JSON","stringify","onReadPackageJson","er","emit","mustHaveFilesFromPackage","files","browser","push","main","bin","key","parse","toString","set","isArray","bundleDependencies","bundledDependencies","patterns","reduce","excl","match","negate","n","negates","results","then","fileList","i","processResults","processed","forEach","delete","add","list","concat","rdResult","globFiles","res","filterEntry","entry","partial","p","rootNM","rootPJ","basename","indexOf","filterEntries","ignoreRules","addIgnoreFile","onPackageJson","data","stat","dir","onstat","st","sort","a","b","exta","extname","toLowerCase","extb","basea","baseb","localeCompare","cb","dot","nocase","readFile","walker","walkerOpt","on","start","walk","options","callback","Promise","reject","bw","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/npm-packlist/lib/index.js"],"sourcesContent":["'use strict'\n\n// Do a two-pass walk, first to get the list of packages that need to be\n// bundled, then again to get the actual files and folders.\n// Keep a cache of node_modules content and package.json data, so that the\n// second walk doesn't have to re-do all the same work.\n\nconst bundleWalk = require('npm-bundled')\nconst BundleWalker = bundleWalk.BundleWalker\n\nconst ignoreWalk = require('ignore-walk')\nconst IgnoreWalker = ignoreWalk.Walker\n\nconst rootBuiltinRules = Symbol('root-builtin-rules')\nconst packageNecessaryRules = Symbol('package-necessary-rules')\nconst path = require('path')\n\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\n// Weird side-effect of this: a readme (etc) file will be included\n// if it exists anywhere within a folder with a package.json file.\n// The original intent was only to include these files in the root,\n// but now users in the wild are dependent on that behavior for\n// localized documentation and other use cases.  Adding a `/` to\n// these rules, while tempting and arguably more \"correct\", is a\n// significant change that will break existing use cases.\nconst packageMustHaveFileNames = 'readme|copying|license|licence'\n\nconst packageMustHaves = `@(${packageMustHaveFileNames}){,.*[^~$]}`\nconst packageMustHavesRE = new RegExp(`^(${packageMustHaveFileNames})(\\\\..*[^~$])?$`, 'i')\n\nconst fs = require('fs')\nconst glob = require('glob')\nconst globify = pattern => pattern.split('\\\\').join('/')\n\nconst readOutOfTreeIgnoreFiles = (root, rel, result = '') => {\n  for (const file of ['.npmignore', '.gitignore']) {\n    try {\n      const ignoreContent = fs.readFileSync(path.join(root, file), { encoding: 'utf8' })\n      result += ignoreContent + '\\n'\n      // break the loop immediately after concatting, this allows us to prioritize the\n      // .npmignore and discard the .gitignore if one exists\n      break\n    } catch (err) {\n      // we ignore ENOENT errors completely because we don't care if the file doesn't exist\n      // but we throw everything else because failing to read a file that does exist is\n      // something that the user likely wants to know about. we don't need to test this.\n      /* istanbul ignore next */\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n  }\n\n  if (!rel) {\n    return result\n  }\n\n  const firstRel = rel.split(path.sep)[0]\n  const newRoot = path.join(root, firstRel)\n  const newRel = path.relative(newRoot, path.join(root, rel))\n\n  return readOutOfTreeIgnoreFiles(newRoot, newRel, result)\n}\n\nconst pathHasPkg = (input) => {\n  if (!input.startsWith('node_modules/')) {\n    return false\n  }\n\n  const segments = input.slice('node_modules/'.length).split('/', 2)\n  return segments[0].startsWith('@')\n    ? segments.length === 2\n    : true\n}\n\nconst pkgFromPath = (input) => {\n  const segments = input.slice('node_modules/'.length).split('/', 2)\n  return segments[0].startsWith('@')\n    ? segments.join('/')\n    : segments[0]\n}\n\nconst defaultRules = [\n  '.npmignore',\n  '.gitignore',\n  '**/.git',\n  '**/.svn',\n  '**/.hg',\n  '**/CVS',\n  '**/.git/**',\n  '**/.svn/**',\n  '**/.hg/**',\n  '**/CVS/**',\n  '/.lock-wscript',\n  '/.wafpickle-*',\n  '/build/config.gypi',\n  'npm-debug.log',\n  '**/.npmrc',\n  '.*.swp',\n  '.DS_Store',\n  '**/.DS_Store/**',\n  '._*',\n  '**/._*/**',\n  '*.orig',\n  '/package-lock.json',\n  '/yarn.lock',\n  '/pnpm-lock.yaml',\n  '/archived-packages/**',\n]\n\n// There may be others, but :?|<> are handled by node-tar\nconst nameIsBadForWindows = file => /\\*/.test(file)\n\nclass Walker extends IgnoreWalker {\n  constructor (opt) {\n    opt = opt || {}\n\n    // the order in which rules are applied.\n    opt.ignoreFiles = [\n      rootBuiltinRules,\n      'package.json',\n      '.npmignore',\n      '.gitignore',\n      packageNecessaryRules,\n    ]\n\n    opt.includeEmpty = false\n    opt.path = opt.path || process.cwd()\n\n    // only follow links in the root node_modules folder, because if those\n    // folders are included, it's because they're bundled, and bundles\n    // should include the contents, not the symlinks themselves.\n    // This regexp tests to see that we're either a node_modules folder,\n    // or a @scope within a node_modules folder, in the root's node_modules\n    // hierarchy (ie, not in test/foo/node_modules/ or something).\n    const followRe = /^(?:\\/node_modules\\/(?:@[^/]+\\/[^/]+|[^/]+)\\/)*\\/node_modules(?:\\/@[^/]+)?$/\n    const rootPath = opt.parent ? opt.parent.root : opt.path\n    const followTestPath = opt.path.replace(/\\\\/g, '/').slice(rootPath.length)\n    opt.follow = followRe.test(followTestPath)\n\n    super(opt)\n\n    // ignore a bunch of things by default at the root level.\n    // also ignore anything in the main project node_modules hierarchy,\n    // except bundled dependencies\n    if (this.isProject) {\n      this.bundled = opt.bundled || []\n      this.bundledScopes = Array.from(new Set(\n        this.bundled.filter(f => /^@/.test(f))\n          .map(f => f.split('/')[0])))\n      this.packageJsonCache = this.parent ? this.parent.packageJsonCache\n        : (opt.packageJsonCache || new Map())\n      let rules = defaultRules.join('\\n') + '\\n'\n\n      if (opt.prefix && opt.workspaces) {\n        const gPath = globify(opt.path)\n        const gPrefix = globify(opt.prefix)\n        const gWorkspaces = opt.workspaces.map((ws) => globify(ws))\n        // if opt.path and opt.prefix are not the same directory, and opt.workspaces has opt.path\n        // in it, then we know that opt.path is a workspace directory. in order to not drop ignore\n        // rules from directories between the workspace root (opt.prefix) and the workspace itself\n        // (opt.path), we need to find and read those now\n        /* istanbul ignore else */\n        if (gPath !== gPrefix && gWorkspaces.includes(gPath)) {\n          // relpath is the relative path between the prefix and the parent of opt.path\n          // we use the parent because ignore-walk will read the files in opt.path already\n          const relpath = path.relative(opt.prefix, path.dirname(opt.path))\n          rules += readOutOfTreeIgnoreFiles(opt.prefix, relpath)\n        } else if (gPath === gPrefix) {\n          // on the other hand, if the path and the prefix are the same, then we ignore workspaces\n          // so that we don't pack workspaces inside of a root project\n          rules += opt.workspaces.map((ws) => globify(path.relative(opt.path, ws))).join('\\n')\n        }\n      }\n\n      super.onReadIgnoreFile(rootBuiltinRules, rules, _ => _)\n    } else {\n      this.bundled = []\n      this.bundledScopes = []\n      this.packageJsonCache = this.parent.packageJsonCache\n    }\n  }\n\n  get isProject () {\n    return !this.parent || this.parent.follow && this.isSymbolicLink\n  }\n\n  onReaddir (entries) {\n    if (this.isProject) {\n      entries = entries.filter(e =>\n        e !== '.git' &&\n        !(e === 'node_modules' && this.bundled.length === 0)\n      )\n    }\n\n    // if we have a package.json, then look in it for 'files'\n    // we _only_ do this in the root project, not bundled deps\n    // or other random folders.  Bundled deps are always assumed\n    // to be in the state the user wants to include them, and\n    // a package.json somewhere else might be a template or\n    // test or something else entirely.\n    if (!this.isProject || !entries.includes('package.json')) {\n      return super.onReaddir(entries)\n    }\n\n    // when the cache has been seeded with the root manifest,\n    // we must respect that (it may differ from the filesystem)\n    const ig = path.resolve(this.path, 'package.json')\n\n    if (this.packageJsonCache.has(ig)) {\n      const pkg = this.packageJsonCache.get(ig)\n\n      // fall back to filesystem when seeded manifest is invalid\n      if (!pkg || typeof pkg !== 'object') {\n        return this.readPackageJson(entries)\n      }\n\n      // feels wonky, but this ensures package bin is _always_\n      // normalized, as well as guarding against invalid JSON\n      return this.getPackageFiles(entries, JSON.stringify(pkg))\n    }\n\n    this.readPackageJson(entries)\n  }\n\n  onReadPackageJson (entries, er, pkg) {\n    if (er) {\n      this.emit('error', er)\n    } else {\n      this.getPackageFiles(entries, pkg)\n    }\n  }\n\n  mustHaveFilesFromPackage (pkg) {\n    const files = []\n    if (pkg.browser) {\n      files.push('/' + pkg.browser)\n    }\n    if (pkg.main) {\n      files.push('/' + pkg.main)\n    }\n    if (pkg.bin) {\n      // always an object because normalized already\n      for (const key in pkg.bin) {\n        files.push('/' + pkg.bin[key])\n      }\n    }\n    files.push(\n      '/package.json',\n      '/npm-shrinkwrap.json',\n      '!/package-lock.json',\n      packageMustHaves\n    )\n    return files\n  }\n\n  getPackageFiles (entries, pkg) {\n    try {\n      // XXX this could be changed to use read-package-json-fast\n      // which handles the normalizing of bins for us, and simplifies\n      // the test for bundleDependencies and bundledDependencies later.\n      // HOWEVER if we do this, we need to be sure that we're careful\n      // about what we write back out since rpj-fast removes some fields\n      // that the user likely wants to keep. it also would add a second\n      // file read that we would want to optimize away.\n      pkg = normalizePackageBin(JSON.parse(pkg.toString()))\n    } catch (er) {\n      // not actually a valid package.json\n      return super.onReaddir(entries)\n    }\n\n    const ig = path.resolve(this.path, 'package.json')\n    this.packageJsonCache.set(ig, pkg)\n\n    // no files list, just return the normal readdir() result\n    if (!Array.isArray(pkg.files)) {\n      return super.onReaddir(entries)\n    }\n\n    pkg.files.push(...this.mustHaveFilesFromPackage(pkg))\n\n    // If the package has a files list, then it's unlikely to include\n    // node_modules, because why would you do that?  but since we use\n    // the files list as the effective readdir result, that means it\n    // looks like we don't have a node_modules folder at all unless we\n    // include it here.\n    if ((pkg.bundleDependencies || pkg.bundledDependencies) && entries.includes('node_modules')) {\n      pkg.files.push('node_modules')\n    }\n\n    const patterns = Array.from(new Set(pkg.files)).reduce((set, pattern) => {\n      const excl = pattern.match(/^!+/)\n      if (excl) {\n        pattern = pattern.slice(excl[0].length)\n      }\n      // strip off any / or ./ from the start of the pattern.  /foo => foo, ./foo => foo\n      pattern = pattern.replace(/^\\.?\\/+/, '')\n      // an odd number of ! means a negated pattern.  !!foo ==> foo\n      const negate = excl && excl[0].length % 2 === 1\n      set.push({ pattern, negate })\n      return set\n    }, [])\n\n    let n = patterns.length\n    const set = new Set()\n    const negates = new Set()\n    const results = []\n    const then = (pattern, negate, er, fileList, i) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n\n      results[i] = { negate, fileList }\n      if (--n === 0) {\n        processResults(results)\n      }\n    }\n    const processResults = processed => {\n      for (const { negate, fileList } of processed) {\n        if (negate) {\n          fileList.forEach(f => {\n            f = f.replace(/\\/+$/, '')\n            set.delete(f)\n            negates.add(f)\n          })\n        } else {\n          fileList.forEach(f => {\n            f = f.replace(/\\/+$/, '')\n            set.add(f)\n            negates.delete(f)\n          })\n        }\n      }\n\n      const list = Array.from(set)\n      // replace the files array with our computed explicit set\n      pkg.files = list.concat(Array.from(negates).map(f => '!' + f))\n      const rdResult = Array.from(new Set(\n        list.map(f => f.replace(/^\\/+/, ''))\n      ))\n      super.onReaddir(rdResult)\n    }\n\n    // maintain the index so that we process them in-order only once all\n    // are completed, otherwise the parallelism messes things up, since a\n    // glob like **/*.js will always be slower than a subsequent !foo.js\n    patterns.forEach(({ pattern, negate }, i) =>\n      this.globFiles(pattern, (er, res) => then(pattern, negate, er, res, i)))\n  }\n\n  filterEntry (entry, partial) {\n    // get the partial path from the root of the walk\n    const p = this.path.slice(this.root.length + 1)\n    const { isProject } = this\n    const pkg = isProject && pathHasPkg(entry)\n      ? pkgFromPath(entry)\n      : null\n    const rootNM = isProject && entry === 'node_modules'\n    const rootPJ = isProject && entry === 'package.json'\n\n    return (\n      // if we're in a bundled package, check with the parent.\n      /^node_modules($|\\/)/i.test(p) && !this.isProject ? this.parent.filterEntry(\n        this.basename + '/' + entry, partial)\n\n      // if package is bundled, all files included\n      // also include @scope dirs for bundled scoped deps\n      // they'll be ignored if no files end up in them.\n      // However, this only matters if we're in the root.\n      // node_modules folders elsewhere, like lib/node_modules,\n      // should be included normally unless ignored.\n      : pkg ? this.bundled.indexOf(pkg) !== -1 ||\n        this.bundledScopes.indexOf(pkg) !== -1\n\n      // only walk top node_modules if we want to bundle something\n      : rootNM ? !!this.bundled.length\n\n      // always include package.json at the root.\n      : rootPJ ? true\n\n      // always include readmes etc in any included dir\n      : packageMustHavesRE.test(entry) ? true\n\n      // npm-shrinkwrap and package.json always included in the root pkg\n      : isProject && (entry === 'npm-shrinkwrap.json' || entry === 'package.json')\n        ? true\n\n      // package-lock never included\n        : isProject && entry === 'package-lock.json' ? false\n\n        // otherwise, follow ignore-walk's logic\n        : super.filterEntry(entry, partial)\n    )\n  }\n\n  filterEntries () {\n    if (this.ignoreRules['.npmignore']) {\n      this.ignoreRules['.gitignore'] = null\n    }\n    this.filterEntries = super.filterEntries\n    super.filterEntries()\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    if (file === 'package.json' && !this.isProject) {\n      then()\n    } else if (this.packageJsonCache.has(ig)) {\n      this.onPackageJson(ig, this.packageJsonCache.get(ig), then)\n    } else {\n      super.addIgnoreFile(file, then)\n    }\n  }\n\n  onPackageJson (ig, pkg, then) {\n    this.packageJsonCache.set(ig, pkg)\n\n    if (Array.isArray(pkg.files)) {\n      // in this case we already included all the must-haves\n      super.onReadIgnoreFile('package.json', pkg.files.map(\n        f => '!' + f\n      ).join('\\n') + '\\n', then)\n    } else {\n      // if there's a bin, browser or main, make sure we don't ignore it\n      // also, don't ignore the package.json itself, or any files that\n      // must be included in the package.\n      const rules = this.mustHaveFilesFromPackage(pkg).map(f => `!${f}`)\n      const data = rules.join('\\n') + '\\n'\n      super.onReadIgnoreFile(packageNecessaryRules, data, then)\n    }\n  }\n\n  // override parent stat function to completely skip any filenames\n  // that will break windows entirely.\n  // XXX(isaacs) Next major version should make this an error instead.\n  stat ({ entry, file, dir }, then) {\n    if (nameIsBadForWindows(entry)) {\n      then()\n    } else {\n      super.stat({ entry, file, dir }, then)\n    }\n  }\n\n  // override parent onstat function to nix all symlinks, other than\n  // those coming out of the followed bundled symlink deps\n  onstat ({ st, entry, file, dir, isSymbolicLink }, then) {\n    if (st.isSymbolicLink()) {\n      then()\n    } else {\n      super.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n    }\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    if (file === 'package.json') {\n      try {\n        const ig = path.resolve(this.path, file)\n        this.onPackageJson(ig, JSON.parse(data), then)\n      } catch (er) {\n        // ignore package.json files that are not json\n        then()\n      }\n    } else {\n      super.onReadIgnoreFile(file, data, then)\n    }\n  }\n\n  sort (a, b) {\n    // optimize for compressibility\n    // extname, then basename, then locale alphabetically\n    // https://twitter.com/isntitvacant/status/1131094910923231232\n    const exta = path.extname(a).toLowerCase()\n    const extb = path.extname(b).toLowerCase()\n    const basea = path.basename(a).toLowerCase()\n    const baseb = path.basename(b).toLowerCase()\n\n    return exta.localeCompare(extb, 'en') ||\n      basea.localeCompare(baseb, 'en') ||\n      a.localeCompare(b, 'en')\n  }\n\n  globFiles (pattern, cb) {\n    glob(globify(pattern), { dot: true, cwd: this.path, nocase: true }, cb)\n  }\n\n  readPackageJson (entries) {\n    fs.readFile(this.path + '/package.json', (er, pkg) =>\n      this.onReadPackageJson(entries, er, pkg))\n  }\n\n  walker (entry, opt, then) {\n    new Walker(this.walkerOpt(entry, opt)).on('done', then).start()\n  }\n}\n\nconst walk = (options, callback) => {\n  options = options || {}\n  const p = new Promise((resolve, reject) => {\n    const bw = new BundleWalker(options)\n    bw.on('done', bundled => {\n      options.bundled = bundled\n      options.packageJsonCache = bw.packageJsonCache\n      new Walker(options).on('done', resolve).on('error', reject).start()\n    })\n    bw.start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nmodule.exports = walk\nwalk.Walker = Walker\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}