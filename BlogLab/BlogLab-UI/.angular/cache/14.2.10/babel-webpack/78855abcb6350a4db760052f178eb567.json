{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatLimitDefinition = void 0;\n\nconst ajv_1 = require(\"ajv\");\n\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nconst ops = codegen_1.operators;\nconst KWDs = {\n  formatMaximum: {\n    okStr: \"<=\",\n    ok: ops.LTE,\n    fail: ops.GT\n  },\n  formatMinimum: {\n    okStr: \">=\",\n    ok: ops.GTE,\n    fail: ops.LT\n  },\n  formatExclusiveMaximum: {\n    okStr: \"<\",\n    ok: ops.LT,\n    fail: ops.GTE\n  },\n  formatExclusiveMinimum: {\n    okStr: \">\",\n    ok: ops.GT,\n    fail: ops.LTE\n  }\n};\nconst error = {\n  message: ({\n    keyword,\n    schemaCode\n  }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,\n  params: ({\n    keyword,\n    schemaCode\n  }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`\n};\nexports.formatLimitDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schemaCode,\n      keyword,\n      it\n    } = cxt;\n    const {\n      opts,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n    if (fCxt.$data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fmt = gen.const(\"fmt\", codegen_1._`${fmts}[${fCxt.schemaCode}]`);\n      cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != \"object\"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n    }\n\n    function validateFormat() {\n      const format = fCxt.schema;\n      const fmtDef = self.formats[format];\n      if (!fmtDef || fmtDef === true) return;\n\n      if (typeof fmtDef != \"object\" || fmtDef instanceof RegExp || typeof fmtDef.compare != \"function\") {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n      }\n\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : undefined\n      });\n      cxt.fail$data(compareCode(fmt));\n    }\n\n    function compareCode(fmt) {\n      return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n    }\n  },\n\n  dependencies: [\"format\"]\n};\n\nconst formatLimitPlugin = ajv => {\n  ajv.addKeyword(exports.formatLimitDefinition);\n  return ajv;\n};\n\nexports.default = formatLimitPlugin;","map":{"version":3,"names":["Object","defineProperty","exports","value","formatLimitDefinition","ajv_1","require","codegen_1","ops","operators","KWDs","formatMaximum","okStr","ok","LTE","fail","GT","formatMinimum","GTE","LT","formatExclusiveMaximum","formatExclusiveMinimum","error","message","keyword","schemaCode","str","params","_","keys","type","schemaType","$data","code","cxt","gen","data","it","opts","self","validateFormats","fCxt","KeywordCxt","RULES","all","format","definition","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fmt","const","fail$data","or","compareCode","schema","fmtDef","RegExp","compare","Error","key","getProperty","undefined","dependencies","formatLimitPlugin","ajv","addKeyword","default"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/ajv-formats/dist/limit.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = require(\"ajv\");\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != \"object\"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports.default = formatLimitPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}