{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.template = exports.templateParser = void 0;\n\nconst source_map_1 = require(\"source-map\"); // Matches <%= expr %>. This does not support structural JavaScript (for/if/...).\n\n\nconst kInterpolateRe = /<%=([\\s\\S]+?)%>/g; // Matches <%# text %>. It's a comment and will be entirely ignored.\n\nconst kCommentRe = /<%#([\\s\\S]+?)%>/g; // Used to match template delimiters.\n// <%- expr %>: HTML escape the value.\n// <% ... %>: Structural template code.\n\nconst kEscapeRe = /<%-([\\s\\S]+?)%>/g;\nconst kEvaluateRe = /<%([\\s\\S]+?)%>/g;\n/** Used to map characters to HTML entities. */\n\nconst kHtmlEscapes = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '`': '&#96;'\n}; // Used to match HTML entities and HTML characters.\n\nconst reUnescapedHtml = new RegExp(`[${Object.keys(kHtmlEscapes).join('')}]`, 'g');\n\nfunction _positionFor(content, offset) {\n  let line = 1;\n  let column = 0;\n\n  for (let i = 0; i < offset - 1; i++) {\n    if (content[i] == '\\n') {\n      line++;\n      column = 0;\n    } else {\n      column++;\n    }\n  }\n\n  return {\n    line,\n    column\n  };\n}\n/**\n * Given a source text (and a fileName), returns a TemplateAst.\n */\n\n\nfunction templateParser(sourceText, fileName) {\n  const children = []; // Compile the regexp to match each delimiter.\n\n  const reExpressions = [kEscapeRe, kCommentRe, kInterpolateRe, kEvaluateRe];\n  const reDelimiters = RegExp(reExpressions.map(x => x.source).join('|') + '|$', 'g');\n  const parsed = sourceText.split(reDelimiters);\n  let offset = 0; // Optimization that uses the fact that the end of a node is always the beginning of the next\n  // node, so we keep the positioning of the nodes in memory.\n\n  let start = _positionFor(sourceText, offset);\n\n  let end;\n  const increment = reExpressions.length + 1;\n\n  for (let i = 0; i < parsed.length; i += increment) {\n    const [content, escape, comment, interpolate, evaluate] = parsed.slice(i, i + increment);\n\n    if (content) {\n      end = _positionFor(sourceText, offset + content.length);\n      offset += content.length;\n      children.push({\n        kind: 'content',\n        content,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (escape) {\n      end = _positionFor(sourceText, offset + escape.length + 5);\n      offset += escape.length + 5;\n      children.push({\n        kind: 'escape',\n        expression: escape,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (comment) {\n      end = _positionFor(sourceText, offset + comment.length + 5);\n      offset += comment.length + 5;\n      children.push({\n        kind: 'comment',\n        text: comment,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (interpolate) {\n      end = _positionFor(sourceText, offset + interpolate.length + 5);\n      offset += interpolate.length + 5;\n      children.push({\n        kind: 'interpolate',\n        expression: interpolate,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (evaluate) {\n      end = _positionFor(sourceText, offset + evaluate.length + 5);\n      offset += evaluate.length + 5;\n      children.push({\n        kind: 'evaluate',\n        expression: evaluate,\n        start,\n        end\n      });\n      start = end;\n    }\n  }\n\n  return {\n    fileName,\n    content: sourceText,\n    children\n  };\n}\n\nexports.templateParser = templateParser;\n/**\n * Fastest implementation of the templating algorithm. It only add strings and does not bother\n * with source maps.\n */\n\nfunction templateFast(ast, options) {\n  const module = options && options.module ? 'module.exports.default =' : '';\n  const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, \"\\\\\\\\\\\\'\");\n  return `\n    return ${module} function(obj) {\n      obj || (obj = {});\n      let __t;\n      let __p = '';\n      const __escapes = ${JSON.stringify(kHtmlEscapes)};\n      const __escapesre = new RegExp('${reHtmlEscape}', 'g');\n\n      const __e = function(s) {\n        return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';\n      };\n      with (obj) {\n        ${ast.children.map(node => {\n    switch (node.kind) {\n      case 'content':\n        return `__p += ${JSON.stringify(node.content)};`;\n\n      case 'interpolate':\n        return `__p += ((__t = (${node.expression})) == null) ? '' : __t;`;\n\n      case 'escape':\n        return `__p += __e(${node.expression});`;\n\n      case 'evaluate':\n        return node.expression;\n    }\n  }).join('\\n')}\n      }\n\n      return __p;\n    };\n  `;\n}\n/**\n * Templating algorithm with source map support. The map is outputted as //# sourceMapUrl=...\n */\n\n\nfunction templateWithSourceMap(ast, options) {\n  const sourceUrl = ast.fileName;\n  const module = options && options.module ? 'module.exports.default =' : '';\n  const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, \"\\\\\\\\\\\\'\");\n  const preamble = new source_map_1.SourceNode(1, 0, sourceUrl, '').add(new source_map_1.SourceNode(1, 0, sourceUrl, [`return ${module} function(obj) {\\n`, '  obj || (obj = {});\\n', '  let __t;\\n', '  let __p = \"\";\\n', `  const __escapes = ${JSON.stringify(kHtmlEscapes)};\\n`, `  const __escapesre = new RegExp('${reHtmlEscape}', 'g');\\n`, `\\n`, `  const __e = function(s) { `, `    return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';`, `  };\\n`, `  with (obj) {\\n`]));\n  const end = ast.children.length ? ast.children[ast.children.length - 1].end : {\n    line: 0,\n    column: 0\n  };\n  const nodes = ast.children.reduce((chunk, node) => {\n    let code = '';\n\n    switch (node.kind) {\n      case 'content':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p = __p'), ...node.content.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, '\\n    + ' + JSON.stringify(line + (i == arr.length - 1 ? '' : '\\n')));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ';\\n')];\n        break;\n\n      case 'interpolate':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += ((__t = '), ...node.expression.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ') == null ? \"\" : __t);\\n')];\n        break;\n\n      case 'escape':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += __e('), ...node.expression.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ');\\n')];\n        break;\n\n      case 'evaluate':\n        code = [...node.expression.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, '\\n')];\n        break;\n    }\n\n    return chunk.add(new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, code));\n  }, preamble).add(new source_map_1.SourceNode(end.line, end.column, sourceUrl, ['  };\\n', '\\n', '  return __p;\\n', '}\\n']));\n  const code = nodes.toStringWithSourceMap({\n    file: sourceUrl,\n    sourceRoot: options && options.sourceRoot || '.'\n  }); // Set the source content in the source map, otherwise the sourceUrl is not enough\n  // to find the content.\n\n  code.map.setSourceContent(sourceUrl, ast.content);\n  return code.code + '\\n' + Buffer.from(code.map.toString()).toString('base64');\n}\n/**\n * An equivalent of EJS templates, which is based on John Resig's `tmpl` implementation\n * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js\n * (https://github.com/olado/doT).\n *\n * This version differs from lodash by removing support from ES6 quasi-literals, and making the\n * code slightly simpler to follow. It also does not depend on any third party, which is nice.\n *\n * Finally, it supports SourceMap, if you ever need to debug, which is super nice.\n *\n * @param content The template content.\n * @param options Optional Options. See TemplateOptions for more description.\n * @return {(input: T) => string} A function that accept an input object and returns the content\n *         of the template with the input applied.\n */\n\n\nfunction template(content, options) {\n  const sourceUrl = options && options.sourceURL || 'ejs';\n  const ast = templateParser(content, sourceUrl);\n  let source; // If there's no need for source map support, we revert back to the fast implementation.\n\n  if (options && options.sourceMap) {\n    source = templateWithSourceMap(ast, options);\n  } else {\n    source = templateFast(ast, options);\n  } // We pass a dummy module in case the module option is passed. If `module: true` is passed, we\n  // need to only use the source, not the function itself. Otherwise expect a module object to be\n  // passed, and we use that one.\n\n\n  const fn = Function('module', source);\n  const module = options && options.module ? options.module === true ? {\n    exports: {}\n  } : options.module : null;\n  const result = fn(module); // Provide the compiled function's source by its `toString` method or\n  // the `source` property as a convenience for inlining compiled templates.\n\n  result.source = source;\n  return result;\n}\n\nexports.template = template;","map":{"version":3,"names":["Object","defineProperty","exports","value","template","templateParser","source_map_1","require","kInterpolateRe","kCommentRe","kEscapeRe","kEvaluateRe","kHtmlEscapes","reUnescapedHtml","RegExp","keys","join","_positionFor","content","offset","line","column","i","sourceText","fileName","children","reExpressions","reDelimiters","map","x","source","parsed","split","start","end","increment","length","escape","comment","interpolate","evaluate","slice","push","kind","expression","text","templateFast","ast","options","module","reHtmlEscape","replace","JSON","stringify","node","templateWithSourceMap","sourceUrl","preamble","SourceNode","add","nodes","reduce","chunk","code","arr","toStringWithSourceMap","file","sourceRoot","setSourceContent","Buffer","from","toString","sourceURL","sourceMap","fn","Function","result"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/utils/template.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.template = exports.templateParser = void 0;\nconst source_map_1 = require(\"source-map\");\n// Matches <%= expr %>. This does not support structural JavaScript (for/if/...).\nconst kInterpolateRe = /<%=([\\s\\S]+?)%>/g;\n// Matches <%# text %>. It's a comment and will be entirely ignored.\nconst kCommentRe = /<%#([\\s\\S]+?)%>/g;\n// Used to match template delimiters.\n// <%- expr %>: HTML escape the value.\n// <% ... %>: Structural template code.\nconst kEscapeRe = /<%-([\\s\\S]+?)%>/g;\nconst kEvaluateRe = /<%([\\s\\S]+?)%>/g;\n/** Used to map characters to HTML entities. */\nconst kHtmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;',\n};\n// Used to match HTML entities and HTML characters.\nconst reUnescapedHtml = new RegExp(`[${Object.keys(kHtmlEscapes).join('')}]`, 'g');\nfunction _positionFor(content, offset) {\n    let line = 1;\n    let column = 0;\n    for (let i = 0; i < offset - 1; i++) {\n        if (content[i] == '\\n') {\n            line++;\n            column = 0;\n        }\n        else {\n            column++;\n        }\n    }\n    return {\n        line,\n        column,\n    };\n}\n/**\n * Given a source text (and a fileName), returns a TemplateAst.\n */\nfunction templateParser(sourceText, fileName) {\n    const children = [];\n    // Compile the regexp to match each delimiter.\n    const reExpressions = [kEscapeRe, kCommentRe, kInterpolateRe, kEvaluateRe];\n    const reDelimiters = RegExp(reExpressions.map((x) => x.source).join('|') + '|$', 'g');\n    const parsed = sourceText.split(reDelimiters);\n    let offset = 0;\n    // Optimization that uses the fact that the end of a node is always the beginning of the next\n    // node, so we keep the positioning of the nodes in memory.\n    let start = _positionFor(sourceText, offset);\n    let end;\n    const increment = reExpressions.length + 1;\n    for (let i = 0; i < parsed.length; i += increment) {\n        const [content, escape, comment, interpolate, evaluate] = parsed.slice(i, i + increment);\n        if (content) {\n            end = _positionFor(sourceText, offset + content.length);\n            offset += content.length;\n            children.push({ kind: 'content', content, start, end });\n            start = end;\n        }\n        if (escape) {\n            end = _positionFor(sourceText, offset + escape.length + 5);\n            offset += escape.length + 5;\n            children.push({ kind: 'escape', expression: escape, start, end });\n            start = end;\n        }\n        if (comment) {\n            end = _positionFor(sourceText, offset + comment.length + 5);\n            offset += comment.length + 5;\n            children.push({ kind: 'comment', text: comment, start, end });\n            start = end;\n        }\n        if (interpolate) {\n            end = _positionFor(sourceText, offset + interpolate.length + 5);\n            offset += interpolate.length + 5;\n            children.push({\n                kind: 'interpolate',\n                expression: interpolate,\n                start,\n                end,\n            });\n            start = end;\n        }\n        if (evaluate) {\n            end = _positionFor(sourceText, offset + evaluate.length + 5);\n            offset += evaluate.length + 5;\n            children.push({ kind: 'evaluate', expression: evaluate, start, end });\n            start = end;\n        }\n    }\n    return {\n        fileName,\n        content: sourceText,\n        children,\n    };\n}\nexports.templateParser = templateParser;\n/**\n * Fastest implementation of the templating algorithm. It only add strings and does not bother\n * with source maps.\n */\nfunction templateFast(ast, options) {\n    const module = options && options.module ? 'module.exports.default =' : '';\n    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, \"\\\\\\\\\\\\'\");\n    return `\n    return ${module} function(obj) {\n      obj || (obj = {});\n      let __t;\n      let __p = '';\n      const __escapes = ${JSON.stringify(kHtmlEscapes)};\n      const __escapesre = new RegExp('${reHtmlEscape}', 'g');\n\n      const __e = function(s) {\n        return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';\n      };\n      with (obj) {\n        ${ast.children\n        .map((node) => {\n        switch (node.kind) {\n            case 'content':\n                return `__p += ${JSON.stringify(node.content)};`;\n            case 'interpolate':\n                return `__p += ((__t = (${node.expression})) == null) ? '' : __t;`;\n            case 'escape':\n                return `__p += __e(${node.expression});`;\n            case 'evaluate':\n                return node.expression;\n        }\n    })\n        .join('\\n')}\n      }\n\n      return __p;\n    };\n  `;\n}\n/**\n * Templating algorithm with source map support. The map is outputted as //# sourceMapUrl=...\n */\nfunction templateWithSourceMap(ast, options) {\n    const sourceUrl = ast.fileName;\n    const module = options && options.module ? 'module.exports.default =' : '';\n    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, \"\\\\\\\\\\\\'\");\n    const preamble = new source_map_1.SourceNode(1, 0, sourceUrl, '').add(new source_map_1.SourceNode(1, 0, sourceUrl, [\n        `return ${module} function(obj) {\\n`,\n        '  obj || (obj = {});\\n',\n        '  let __t;\\n',\n        '  let __p = \"\";\\n',\n        `  const __escapes = ${JSON.stringify(kHtmlEscapes)};\\n`,\n        `  const __escapesre = new RegExp('${reHtmlEscape}', 'g');\\n`,\n        `\\n`,\n        `  const __e = function(s) { `,\n        `    return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';`,\n        `  };\\n`,\n        `  with (obj) {\\n`,\n    ]));\n    const end = ast.children.length\n        ? ast.children[ast.children.length - 1].end\n        : { line: 0, column: 0 };\n    const nodes = ast.children\n        .reduce((chunk, node) => {\n        let code = '';\n        switch (node.kind) {\n            case 'content':\n                code = [\n                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p = __p'),\n                    ...node.content.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, '\\n    + ' + JSON.stringify(line + (i == arr.length - 1 ? '' : '\\n')));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ';\\n'),\n                ];\n                break;\n            case 'interpolate':\n                code = [\n                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += ((__t = '),\n                    ...node.expression.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ') == null ? \"\" : __t);\\n'),\n                ];\n                break;\n            case 'escape':\n                code = [\n                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += __e('),\n                    ...node.expression.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ');\\n'),\n                ];\n                break;\n            case 'evaluate':\n                code = [\n                    ...node.expression.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, '\\n'),\n                ];\n                break;\n        }\n        return chunk.add(new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, code));\n    }, preamble)\n        .add(new source_map_1.SourceNode(end.line, end.column, sourceUrl, ['  };\\n', '\\n', '  return __p;\\n', '}\\n']));\n    const code = nodes.toStringWithSourceMap({\n        file: sourceUrl,\n        sourceRoot: (options && options.sourceRoot) || '.',\n    });\n    // Set the source content in the source map, otherwise the sourceUrl is not enough\n    // to find the content.\n    code.map.setSourceContent(sourceUrl, ast.content);\n    return (code.code +\n        '\\n' +\n        Buffer.from(code.map.toString()).toString('base64'));\n}\n/**\n * An equivalent of EJS templates, which is based on John Resig's `tmpl` implementation\n * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js\n * (https://github.com/olado/doT).\n *\n * This version differs from lodash by removing support from ES6 quasi-literals, and making the\n * code slightly simpler to follow. It also does not depend on any third party, which is nice.\n *\n * Finally, it supports SourceMap, if you ever need to debug, which is super nice.\n *\n * @param content The template content.\n * @param options Optional Options. See TemplateOptions for more description.\n * @return {(input: T) => string} A function that accept an input object and returns the content\n *         of the template with the input applied.\n */\nfunction template(content, options) {\n    const sourceUrl = (options && options.sourceURL) || 'ejs';\n    const ast = templateParser(content, sourceUrl);\n    let source;\n    // If there's no need for source map support, we revert back to the fast implementation.\n    if (options && options.sourceMap) {\n        source = templateWithSourceMap(ast, options);\n    }\n    else {\n        source = templateFast(ast, options);\n    }\n    // We pass a dummy module in case the module option is passed. If `module: true` is passed, we\n    // need to only use the source, not the function itself. Otherwise expect a module object to be\n    // passed, and we use that one.\n    const fn = Function('module', source);\n    const module = options && options.module ? (options.module === true ? { exports: {} } : options.module) : null;\n    const result = fn(module);\n    // Provide the compiled function's source by its `toString` method or\n    // the `source` property as a convenience for inlining compiled templates.\n    result.source = source;\n    return result;\n}\nexports.template = template;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}