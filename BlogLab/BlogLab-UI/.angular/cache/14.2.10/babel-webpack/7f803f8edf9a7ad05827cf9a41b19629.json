{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst util = require('util');\n\nconst pMap = require('p-map');\n\nconst contentPath = require('./content/path');\n\nconst fixOwner = require('./util/fix-owner');\n\nconst fs = require('@npmcli/fs');\n\nconst fsm = require('fs-minipass');\n\nconst glob = util.promisify(require('glob'));\n\nconst index = require('./entry-index');\n\nconst path = require('path');\n\nconst rimraf = util.promisify(require('rimraf'));\n\nconst ssri = require('ssri');\n\nconst globify = pattern => pattern.split('\\\\').join('/');\n\nconst hasOwnProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\nconst verifyOpts = opts => ({\n  concurrency: 20,\n  log: {\n    silly() {}\n\n  },\n  ...opts\n});\n\nmodule.exports = verify;\n\nfunction verify(_x, _x2) {\n  return _verify.apply(this, arguments);\n}\n\nfunction _verify() {\n  _verify = _asyncToGenerator(function* (cache, opts) {\n    opts = verifyOpts(opts);\n    opts.log.silly('verify', 'verifying cache at', cache);\n    const steps = [markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime];\n    const stats = {};\n\n    for (const step of steps) {\n      const label = step.name;\n      const start = new Date();\n      const s = yield step(cache, opts);\n\n      if (s) {\n        Object.keys(s).forEach(k => {\n          stats[k] = s[k];\n        });\n      }\n\n      const end = new Date();\n\n      if (!stats.runTime) {\n        stats.runTime = {};\n      }\n\n      stats.runTime[label] = end - start;\n    }\n\n    stats.runTime.total = stats.endTime - stats.startTime;\n    opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`);\n    return stats;\n  });\n  return _verify.apply(this, arguments);\n}\n\nfunction markStartTime(_x3, _x4) {\n  return _markStartTime.apply(this, arguments);\n}\n\nfunction _markStartTime() {\n  _markStartTime = _asyncToGenerator(function* (cache, opts) {\n    return {\n      startTime: new Date()\n    };\n  });\n  return _markStartTime.apply(this, arguments);\n}\n\nfunction markEndTime(_x5, _x6) {\n  return _markEndTime.apply(this, arguments);\n}\n\nfunction _markEndTime() {\n  _markEndTime = _asyncToGenerator(function* (cache, opts) {\n    return {\n      endTime: new Date()\n    };\n  });\n  return _markEndTime.apply(this, arguments);\n}\n\nfunction fixPerms(_x7, _x8) {\n  return _fixPerms.apply(this, arguments);\n} // Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\n\n\nfunction _fixPerms() {\n  _fixPerms = _asyncToGenerator(function* (cache, opts) {\n    opts.log.silly('verify', 'fixing cache permissions');\n    yield fixOwner.mkdirfix(cache, cache); // TODO - fix file permissions too\n\n    yield fixOwner.chownr(cache, cache);\n    return null;\n  });\n  return _fixPerms.apply(this, arguments);\n}\n\nfunction garbageCollect(_x9, _x10) {\n  return _garbageCollect.apply(this, arguments);\n}\n\nfunction _garbageCollect() {\n  _garbageCollect = _asyncToGenerator(function* (cache, opts) {\n    opts.log.silly('verify', 'garbage collecting content');\n    const indexStream = index.lsStream(cache);\n    const liveContent = new Set();\n    indexStream.on('data', entry => {\n      if (opts.filter && !opts.filter(entry)) {\n        return;\n      }\n\n      liveContent.add(entry.integrity.toString());\n    });\n    yield new Promise((resolve, reject) => {\n      indexStream.on('end', resolve).on('error', reject);\n    });\n    const contentDir = contentPath.contentDir(cache);\n    const files = yield glob(globify(path.join(contentDir, '**')), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    });\n    const stats = {\n      verifiedContent: 0,\n      reclaimedCount: 0,\n      reclaimedSize: 0,\n      badContentCount: 0,\n      keptSize: 0\n    };\n    yield pMap(files, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (f) {\n        const split = f.split(/[/\\\\]/);\n        const digest = split.slice(split.length - 3).join('');\n        const algo = split[split.length - 4];\n        const integrity = ssri.fromHex(digest, algo);\n\n        if (liveContent.has(integrity.toString())) {\n          const info = yield verifyContent(f, integrity);\n\n          if (!info.valid) {\n            stats.reclaimedCount++;\n            stats.badContentCount++;\n            stats.reclaimedSize += info.size;\n          } else {\n            stats.verifiedContent++;\n            stats.keptSize += info.size;\n          }\n        } else {\n          // No entries refer to this content. We can delete.\n          stats.reclaimedCount++;\n          const s = yield fs.stat(f);\n          yield rimraf(f);\n          stats.reclaimedSize += s.size;\n        }\n\n        return stats;\n      });\n\n      return function (_x20) {\n        return _ref.apply(this, arguments);\n      };\n    }(), {\n      concurrency: opts.concurrency\n    });\n    return stats;\n  });\n  return _garbageCollect.apply(this, arguments);\n}\n\nfunction verifyContent(_x11, _x12) {\n  return _verifyContent.apply(this, arguments);\n}\n\nfunction _verifyContent() {\n  _verifyContent = _asyncToGenerator(function* (filepath, sri) {\n    const contentInfo = {};\n\n    try {\n      const {\n        size\n      } = yield fs.stat(filepath);\n      contentInfo.size = size;\n      contentInfo.valid = true;\n      yield ssri.checkStream(new fsm.ReadStream(filepath), sri);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return {\n          size: 0,\n          valid: false\n        };\n      }\n\n      if (err.code !== 'EINTEGRITY') {\n        throw err;\n      }\n\n      yield rimraf(filepath);\n      contentInfo.valid = false;\n    }\n\n    return contentInfo;\n  });\n  return _verifyContent.apply(this, arguments);\n}\n\nfunction rebuildIndex(_x13, _x14) {\n  return _rebuildIndex.apply(this, arguments);\n}\n\nfunction _rebuildIndex() {\n  _rebuildIndex = _asyncToGenerator(function* (cache, opts) {\n    opts.log.silly('verify', 'rebuilding index');\n    const entries = yield index.ls(cache);\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    };\n    const buckets = {};\n\n    for (const k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        const hashed = index.hashKey(k);\n        const entry = entries[k];\n        const excluded = opts.filter && !opts.filter(entry);\n        excluded && stats.rejectedEntries++;\n\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry);\n        } else if (buckets[hashed] && excluded) {// skip\n        } else if (excluded) {\n          buckets[hashed] = [];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        } else {\n          buckets[hashed] = [entry];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        }\n      }\n    }\n\n    yield pMap(Object.keys(buckets), key => {\n      return rebuildBucket(cache, buckets[key], stats, opts);\n    }, {\n      concurrency: opts.concurrency\n    });\n    return stats;\n  });\n  return _rebuildIndex.apply(this, arguments);\n}\n\nfunction rebuildBucket(_x15, _x16, _x17, _x18) {\n  return _rebuildBucket.apply(this, arguments);\n}\n\nfunction _rebuildBucket() {\n  _rebuildBucket = _asyncToGenerator(function* (cache, bucket, stats, opts) {\n    yield fs.truncate(bucket._path); // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n\n    for (const entry of bucket) {\n      const content = contentPath(cache, entry.integrity);\n\n      try {\n        yield fs.stat(content);\n        yield index.insert(cache, entry.key, entry.integrity, {\n          metadata: entry.metadata,\n          size: entry.size\n        });\n        stats.totalEntries++;\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          stats.rejectedEntries++;\n          stats.missingContent++;\n        } else {\n          throw err;\n        }\n      }\n    }\n  });\n  return _rebuildBucket.apply(this, arguments);\n}\n\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rimraf(path.join(cache, 'tmp'));\n}\n\nfunction writeVerifile(cache, opts) {\n  const verifile = path.join(cache, '_lastverified');\n  opts.log.silly('verify', 'writing verifile to ' + verifile);\n\n  try {\n    return fs.writeFile(verifile, `${Date.now()}`);\n  } finally {\n    fixOwner.chownr.sync(cache, verifile);\n  }\n}\n\nmodule.exports.lastRun = lastRun;\n\nfunction lastRun(_x19) {\n  return _lastRun.apply(this, arguments);\n}\n\nfunction _lastRun() {\n  _lastRun = _asyncToGenerator(function* (cache) {\n    const data = yield fs.readFile(path.join(cache, '_lastverified'), {\n      encoding: 'utf8'\n    });\n    return new Date(+data);\n  });\n  return _lastRun.apply(this, arguments);\n}","map":{"version":3,"names":["util","require","pMap","contentPath","fixOwner","fs","fsm","glob","promisify","index","path","rimraf","ssri","globify","pattern","split","join","hasOwnProperty","obj","key","Object","prototype","call","verifyOpts","opts","concurrency","log","silly","module","exports","verify","cache","steps","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","stats","step","label","name","start","Date","s","keys","forEach","k","end","runTime","total","endTime","startTime","mkdirfix","chownr","indexStream","lsStream","liveContent","Set","on","entry","filter","add","integrity","toString","Promise","resolve","reject","contentDir","files","follow","nodir","nosort","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","f","digest","slice","length","algo","fromHex","has","info","verifyContent","valid","size","stat","filepath","sri","contentInfo","checkStream","ReadStream","err","code","entries","ls","missingContent","rejectedEntries","totalEntries","buckets","hashed","hashKey","excluded","push","_path","bucketPath","rebuildBucket","bucket","truncate","content","insert","metadata","verifile","writeFile","now","sync","lastRun","data","readFile","encoding"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/cacache/lib/verify.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst pMap = require('p-map')\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('@npmcli/fs')\nconst fsm = require('fs-minipass')\nconst glob = util.promisify(require('glob'))\nconst index = require('./entry-index')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\n\nconst globify = pattern => pattern.split('\\\\').join('/')\n\nconst hasOwnProperty = (obj, key) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nconst verifyOpts = (opts) => ({\n  concurrency: 20,\n  log: { silly () {} },\n  ...opts,\n})\n\nmodule.exports = verify\n\nasync function verify (cache, opts) {\n  opts = verifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n\n  const steps = [\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime,\n  ]\n\n  const stats = {}\n  for (const step of steps) {\n    const label = step.name\n    const start = new Date()\n    const s = await step(cache, opts)\n    if (s) {\n      Object.keys(s).forEach((k) => {\n        stats[k] = s[k]\n      })\n    }\n    const end = new Date()\n    if (!stats.runTime) {\n      stats.runTime = {}\n    }\n    stats.runTime[label] = end - start\n  }\n  stats.runTime.total = stats.endTime - stats.startTime\n  opts.log.silly(\n    'verify',\n    'verification finished for',\n    cache,\n    'in',\n    `${stats.runTime.total}ms`\n  )\n  return stats\n}\n\nasync function markStartTime (cache, opts) {\n  return { startTime: new Date() }\n}\n\nasync function markEndTime (cache, opts) {\n  return { endTime: new Date() }\n}\n\nasync function fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  await fixOwner.mkdirfix(cache, cache)\n  // TODO - fix file permissions too\n  await fixOwner.chownr(cache, cache)\n  return null\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nasync function garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', (entry) => {\n    if (opts.filter && !opts.filter(entry)) {\n      return\n    }\n\n    liveContent.add(entry.integrity.toString())\n  })\n  await new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject)\n  })\n  const contentDir = contentPath.contentDir(cache)\n  const files = await glob(globify(path.join(contentDir, '**')), {\n    follow: false,\n    nodir: true,\n    nosort: true,\n  })\n  const stats = {\n    verifiedContent: 0,\n    reclaimedCount: 0,\n    reclaimedSize: 0,\n    badContentCount: 0,\n    keptSize: 0,\n  }\n  await pMap(\n    files,\n    async (f) => {\n      const split = f.split(/[/\\\\]/)\n      const digest = split.slice(split.length - 3).join('')\n      const algo = split[split.length - 4]\n      const integrity = ssri.fromHex(digest, algo)\n      if (liveContent.has(integrity.toString())) {\n        const info = await verifyContent(f, integrity)\n        if (!info.valid) {\n          stats.reclaimedCount++\n          stats.badContentCount++\n          stats.reclaimedSize += info.size\n        } else {\n          stats.verifiedContent++\n          stats.keptSize += info.size\n        }\n      } else {\n        // No entries refer to this content. We can delete.\n        stats.reclaimedCount++\n        const s = await fs.stat(f)\n        await rimraf(f)\n        stats.reclaimedSize += s.size\n      }\n      return stats\n    },\n    { concurrency: opts.concurrency }\n  )\n  return stats\n}\n\nasync function verifyContent (filepath, sri) {\n  const contentInfo = {}\n  try {\n    const { size } = await fs.stat(filepath)\n    contentInfo.size = size\n    contentInfo.valid = true\n    await ssri.checkStream(new fsm.ReadStream(filepath), sri)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return { size: 0, valid: false }\n    }\n    if (err.code !== 'EINTEGRITY') {\n      throw err\n    }\n\n    await rimraf(filepath)\n    contentInfo.valid = false\n  }\n  return contentInfo\n}\n\nasync function rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  const entries = await index.ls(cache)\n  const stats = {\n    missingContent: 0,\n    rejectedEntries: 0,\n    totalEntries: 0,\n  }\n  const buckets = {}\n  for (const k in entries) {\n    /* istanbul ignore else */\n    if (hasOwnProperty(entries, k)) {\n      const hashed = index.hashKey(k)\n      const entry = entries[k]\n      const excluded = opts.filter && !opts.filter(entry)\n      excluded && stats.rejectedEntries++\n      if (buckets[hashed] && !excluded) {\n        buckets[hashed].push(entry)\n      } else if (buckets[hashed] && excluded) {\n        // skip\n      } else if (excluded) {\n        buckets[hashed] = []\n        buckets[hashed]._path = index.bucketPath(cache, k)\n      } else {\n        buckets[hashed] = [entry]\n        buckets[hashed]._path = index.bucketPath(cache, k)\n      }\n    }\n  }\n  await pMap(\n    Object.keys(buckets),\n    (key) => {\n      return rebuildBucket(cache, buckets[key], stats, opts)\n    },\n    { concurrency: opts.concurrency }\n  )\n  return stats\n}\n\nasync function rebuildBucket (cache, bucket, stats, opts) {\n  await fs.truncate(bucket._path)\n  // This needs to be serialized because cacache explicitly\n  // lets very racy bucket conflicts clobber each other.\n  for (const entry of bucket) {\n    const content = contentPath(cache, entry.integrity)\n    try {\n      await fs.stat(content)\n      await index.insert(cache, entry.key, entry.integrity, {\n        metadata: entry.metadata,\n        size: entry.size,\n      })\n      stats.totalEntries++\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        stats.rejectedEntries++\n        stats.missingContent++\n      } else {\n        throw err\n      }\n    }\n  }\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rimraf(path.join(cache, 'tmp'))\n}\n\nfunction writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  try {\n    return fs.writeFile(verifile, `${Date.now()}`)\n  } finally {\n    fixOwner.chownr.sync(cache, verifile)\n  }\n}\n\nmodule.exports.lastRun = lastRun\n\nasync function lastRun (cache) {\n  const data = await fs.readFile(path.join(cache, '_lastverified'), { encoding: 'utf8' })\n  return new Date(+data)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}