{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"./utils\"); // The default Buffer size if one is not provided.\n\n\nconst DEFAULT_SMARTBUFFER_SIZE = 4096; // The default string encoding to use for reading/writing strings.\n\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\n\nclass SmartBuffer {\n  /**\n   * Creates a new SmartBuffer instance.\n   *\n   * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n   */\n  constructor(options) {\n    this.length = 0;\n    this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n    this._writeOffset = 0;\n    this._readOffset = 0;\n\n    if (SmartBuffer.isSmartBufferOptions(options)) {\n      // Checks for encoding\n      if (options.encoding) {\n        utils_1.checkEncoding(options.encoding);\n        this._encoding = options.encoding;\n      } // Checks for initial size length\n\n\n      if (options.size) {\n        if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n          this._buff = Buffer.allocUnsafe(options.size);\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n        } // Check for initial Buffer\n\n      } else if (options.buff) {\n        if (Buffer.isBuffer(options.buff)) {\n          this._buff = options.buff;\n          this.length = options.buff.length;\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n        }\n      } else {\n        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n      }\n    } else {\n      // If something was passed but it's not a SmartBufferOptions object\n      if (typeof options !== 'undefined') {\n        throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n      } // Otherwise default to sane options\n\n\n      this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n    }\n  }\n  /**\n   * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n   *\n   * @param size { Number } The size of the internal Buffer.\n   * @param encoding { String } The BufferEncoding to use for strings.\n   *\n   * @return { SmartBuffer }\n   */\n\n\n  static fromSize(size, encoding) {\n    return new this({\n      size: size,\n      encoding: encoding\n    });\n  }\n  /**\n   * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n   *\n   * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n   * @param encoding { String } The BufferEncoding to use for strings.\n   *\n   * @return { SmartBuffer }\n   */\n\n\n  static fromBuffer(buff, encoding) {\n    return new this({\n      buff: buff,\n      encoding: encoding\n    });\n  }\n  /**\n   * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n   *\n   * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n   */\n\n\n  static fromOptions(options) {\n    return new this(options);\n  }\n  /**\n   * Type checking function that determines if an object is a SmartBufferOptions object.\n   */\n\n\n  static isSmartBufferOptions(options) {\n    const castOptions = options;\n    return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n  } // Signed integers\n\n  /**\n   * Reads an Int8 value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readInt8(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n  }\n  /**\n   * Reads an Int16BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readInt16BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n  }\n  /**\n   * Reads an Int16LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readInt16LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n  }\n  /**\n   * Reads an Int32BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readInt32BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n  }\n  /**\n   * Reads an Int32LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readInt32LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n  }\n  /**\n   * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n\n\n  readBigInt64BE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n    return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n  }\n  /**\n   * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n\n\n  readBigInt64LE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n    return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n  }\n  /**\n   * Writes an Int8 value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeInt8(value, offset) {\n    this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n\n    return this;\n  }\n  /**\n   * Inserts an Int8 value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertInt8(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n  }\n  /**\n   * Writes an Int16BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeInt16BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n  }\n  /**\n   * Inserts an Int16BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertInt16BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n  }\n  /**\n   * Writes an Int16LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeInt16LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n  }\n  /**\n   * Inserts an Int16LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertInt16LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n  }\n  /**\n   * Writes an Int32BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeInt32BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n  }\n  /**\n   * Inserts an Int32BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertInt32BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n  }\n  /**\n   * Writes an Int32LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeInt32LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n  }\n  /**\n   * Inserts an Int32LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertInt32LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n  }\n  /**\n   * Writes a BigInt64BE value to the current write position (or at optional offset).\n   *\n   * @param value { BigInt } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeBigInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n    return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n  }\n  /**\n   * Inserts a BigInt64BE value at the given offset value.\n   *\n   * @param value { BigInt } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertBigInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n    return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n  }\n  /**\n   * Writes a BigInt64LE value to the current write position (or at optional offset).\n   *\n   * @param value { BigInt } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeBigInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n    return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n  }\n  /**\n   * Inserts a Int64LE value at the given offset value.\n   *\n   * @param value { BigInt } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertBigInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n    return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n  } // Unsigned Integers\n\n  /**\n   * Reads an UInt8 value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readUInt8(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n  }\n  /**\n   * Reads an UInt16BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readUInt16BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n  }\n  /**\n   * Reads an UInt16LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readUInt16LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n  }\n  /**\n   * Reads an UInt32BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readUInt32BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n  }\n  /**\n   * Reads an UInt32LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readUInt32LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n  }\n  /**\n   * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n\n\n  readBigUInt64BE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n    return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n  }\n  /**\n   * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n\n\n  readBigUInt64LE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n    return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n  }\n  /**\n   * Writes an UInt8 value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeUInt8(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n  }\n  /**\n   * Inserts an UInt8 value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertUInt8(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n  }\n  /**\n   * Writes an UInt16BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeUInt16BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n  }\n  /**\n   * Inserts an UInt16BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertUInt16BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n  }\n  /**\n   * Writes an UInt16LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeUInt16LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n  }\n  /**\n   * Inserts an UInt16LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertUInt16LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n  }\n  /**\n   * Writes an UInt32BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeUInt32BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n  }\n  /**\n   * Inserts an UInt32BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertUInt32BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n  }\n  /**\n   * Writes an UInt32LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeUInt32LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n  }\n  /**\n   * Inserts an UInt32LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertUInt32LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n  }\n  /**\n   * Writes a BigUInt64BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeBigUInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n    return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n  }\n  /**\n   * Inserts a BigUInt64BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertBigUInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n    return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n  }\n  /**\n   * Writes a BigUInt64LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeBigUInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n    return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n  }\n  /**\n   * Inserts a BigUInt64LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertBigUInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n    return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n  } // Floating Point\n\n  /**\n   * Reads an FloatBE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readFloatBE(offset) {\n    return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n  }\n  /**\n   * Reads an FloatLE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readFloatLE(offset) {\n    return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n  }\n  /**\n   * Writes a FloatBE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeFloatBE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n  }\n  /**\n   * Inserts a FloatBE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertFloatBE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n  }\n  /**\n   * Writes a FloatLE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeFloatLE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n  }\n  /**\n   * Inserts a FloatLE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertFloatLE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n  } // Double Floating Point\n\n  /**\n   * Reads an DoublEBE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readDoubleBE(offset) {\n    return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n  }\n  /**\n   * Reads an DoubleLE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n\n\n  readDoubleLE(offset) {\n    return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n  }\n  /**\n   * Writes a DoubleBE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeDoubleBE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n  }\n  /**\n   * Inserts a DoubleBE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertDoubleBE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n  }\n  /**\n   * Writes a DoubleLE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n\n\n  writeDoubleLE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n  }\n  /**\n   * Inserts a DoubleLE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n\n\n  insertDoubleLE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n  } // Strings\n\n  /**\n   * Reads a String from the current read position.\n   *\n   * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n   *             the string (Defaults to instance level encoding).\n   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n   *\n   * @return { String }\n   */\n\n\n  readString(arg1, encoding) {\n    let lengthVal; // Length provided\n\n    if (typeof arg1 === 'number') {\n      utils_1.checkLengthValue(arg1);\n      lengthVal = Math.min(arg1, this.length - this._readOffset);\n    } else {\n      encoding = arg1;\n      lengthVal = this.length - this._readOffset;\n    } // Check encoding\n\n\n    if (typeof encoding !== 'undefined') {\n      utils_1.checkEncoding(encoding);\n    }\n\n    const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n\n    this._readOffset += lengthVal;\n    return value;\n  }\n  /**\n   * Inserts a String\n   *\n   * @param value { String } The String value to insert.\n   * @param offset { Number } The offset to insert the string at.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n\n\n  insertString(value, offset, encoding) {\n    utils_1.checkOffsetValue(offset);\n    return this._handleString(value, true, offset, encoding);\n  }\n  /**\n   * Writes a String\n   *\n   * @param value { String } The String value to write.\n   * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n\n\n  writeString(value, arg2, encoding) {\n    return this._handleString(value, false, arg2, encoding);\n  }\n  /**\n   * Reads a null-terminated String from the current read position.\n   *\n   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n   *\n   * @return { String }\n   */\n\n\n  readStringNT(encoding) {\n    if (typeof encoding !== 'undefined') {\n      utils_1.checkEncoding(encoding);\n    } // Set null character position to the end SmartBuffer instance.\n\n\n    let nullPos = this.length; // Find next null character (if one is not found, default from above is used)\n\n    for (let i = this._readOffset; i < this.length; i++) {\n      if (this._buff[i] === 0x00) {\n        nullPos = i;\n        break;\n      }\n    } // Read string value\n\n\n    const value = this._buff.slice(this._readOffset, nullPos); // Increment internal Buffer read offset\n\n\n    this._readOffset = nullPos + 1;\n    return value.toString(encoding || this._encoding);\n  }\n  /**\n   * Inserts a null-terminated String.\n   *\n   * @param value { String } The String value to write.\n   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n\n\n  insertStringNT(value, offset, encoding) {\n    utils_1.checkOffsetValue(offset); // Write Values\n\n    this.insertString(value, offset, encoding);\n    this.insertUInt8(0x00, offset + value.length);\n    return this;\n  }\n  /**\n   * Writes a null-terminated String.\n   *\n   * @param value { String } The String value to write.\n   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n\n\n  writeStringNT(value, arg2, encoding) {\n    // Write Values\n    this.writeString(value, arg2, encoding);\n    this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n    return this;\n  } // Buffers\n\n  /**\n   * Reads a Buffer from the internal read position.\n   *\n   * @param length { Number } The length of data to read as a Buffer.\n   *\n   * @return { Buffer }\n   */\n\n\n  readBuffer(length) {\n    if (typeof length !== 'undefined') {\n      utils_1.checkLengthValue(length);\n    }\n\n    const lengthVal = typeof length === 'number' ? length : this.length;\n    const endPoint = Math.min(this.length, this._readOffset + lengthVal); // Read buffer value\n\n    const value = this._buff.slice(this._readOffset, endPoint); // Increment internal Buffer read offset\n\n\n    this._readOffset = endPoint;\n    return value;\n  }\n  /**\n   * Writes a Buffer to the current write position.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n\n\n  insertBuffer(value, offset) {\n    utils_1.checkOffsetValue(offset);\n    return this._handleBuffer(value, true, offset);\n  }\n  /**\n   * Writes a Buffer to the current write position.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n\n\n  writeBuffer(value, offset) {\n    return this._handleBuffer(value, false, offset);\n  }\n  /**\n   * Reads a null-terminated Buffer from the current read poisiton.\n   *\n   * @return { Buffer }\n   */\n\n\n  readBufferNT() {\n    // Set null character position to the end SmartBuffer instance.\n    let nullPos = this.length; // Find next null character (if one is not found, default from above is used)\n\n    for (let i = this._readOffset; i < this.length; i++) {\n      if (this._buff[i] === 0x00) {\n        nullPos = i;\n        break;\n      }\n    } // Read value\n\n\n    const value = this._buff.slice(this._readOffset, nullPos); // Increment internal Buffer read offset\n\n\n    this._readOffset = nullPos + 1;\n    return value;\n  }\n  /**\n   * Inserts a null-terminated Buffer.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n\n\n  insertBufferNT(value, offset) {\n    utils_1.checkOffsetValue(offset); // Write Values\n\n    this.insertBuffer(value, offset);\n    this.insertUInt8(0x00, offset + value.length);\n    return this;\n  }\n  /**\n   * Writes a null-terminated Buffer.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n\n\n  writeBufferNT(value, offset) {\n    // Checks for valid numberic value;\n    if (typeof offset !== 'undefined') {\n      utils_1.checkOffsetValue(offset);\n    } // Write Values\n\n\n    this.writeBuffer(value, offset);\n    this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n    return this;\n  }\n  /**\n   * Clears the SmartBuffer instance to its original empty state.\n   */\n\n\n  clear() {\n    this._writeOffset = 0;\n    this._readOffset = 0;\n    this.length = 0;\n    return this;\n  }\n  /**\n   * Gets the remaining data left to be read from the SmartBuffer instance.\n   *\n   * @return { Number }\n   */\n\n\n  remaining() {\n    return this.length - this._readOffset;\n  }\n  /**\n   * Gets the current read offset value of the SmartBuffer instance.\n   *\n   * @return { Number }\n   */\n\n\n  get readOffset() {\n    return this._readOffset;\n  }\n  /**\n   * Sets the read offset value of the SmartBuffer instance.\n   *\n   * @param offset { Number } - The offset value to set.\n   */\n\n\n  set readOffset(offset) {\n    utils_1.checkOffsetValue(offset); // Check for bounds.\n\n    utils_1.checkTargetOffset(offset, this);\n    this._readOffset = offset;\n  }\n  /**\n   * Gets the current write offset value of the SmartBuffer instance.\n   *\n   * @return { Number }\n   */\n\n\n  get writeOffset() {\n    return this._writeOffset;\n  }\n  /**\n   * Sets the write offset value of the SmartBuffer instance.\n   *\n   * @param offset { Number } - The offset value to set.\n   */\n\n\n  set writeOffset(offset) {\n    utils_1.checkOffsetValue(offset); // Check for bounds.\n\n    utils_1.checkTargetOffset(offset, this);\n    this._writeOffset = offset;\n  }\n  /**\n   * Gets the currently set string encoding of the SmartBuffer instance.\n   *\n   * @return { BufferEncoding } The string Buffer encoding currently set.\n   */\n\n\n  get encoding() {\n    return this._encoding;\n  }\n  /**\n   * Sets the string encoding of the SmartBuffer instance.\n   *\n   * @param encoding { BufferEncoding } The string Buffer encoding to set.\n   */\n\n\n  set encoding(encoding) {\n    utils_1.checkEncoding(encoding);\n    this._encoding = encoding;\n  }\n  /**\n   * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n   *\n   * @return { Buffer } The Buffer value.\n   */\n\n\n  get internalBuffer() {\n    return this._buff;\n  }\n  /**\n   * Gets the value of the internal managed Buffer (Includes managed data only)\n   *\n   * @param { Buffer }\n   */\n\n\n  toBuffer() {\n    return this._buff.slice(0, this.length);\n  }\n  /**\n   * Gets the String value of the internal managed Buffer\n   *\n   * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n   */\n\n\n  toString(encoding) {\n    const encodingVal = typeof encoding === 'string' ? encoding : this._encoding; // Check for invalid encoding.\n\n    utils_1.checkEncoding(encodingVal);\n    return this._buff.toString(encodingVal, 0, this.length);\n  }\n  /**\n   * Destroys the SmartBuffer instance.\n   */\n\n\n  destroy() {\n    this.clear();\n    return this;\n  }\n  /**\n   * Handles inserting and writing strings.\n   *\n   * @param value { String } The String value to insert.\n   * @param isInsert { Boolean } True if inserting a string, false if writing.\n   * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   */\n\n\n  _handleString(value, isInsert, arg3, encoding) {\n    let offsetVal = this._writeOffset;\n    let encodingVal = this._encoding; // Check for offset\n\n    if (typeof arg3 === 'number') {\n      offsetVal = arg3; // Check for encoding\n    } else if (typeof arg3 === 'string') {\n      utils_1.checkEncoding(arg3);\n      encodingVal = arg3;\n    } // Check for encoding (third param)\n\n\n    if (typeof encoding === 'string') {\n      utils_1.checkEncoding(encoding);\n      encodingVal = encoding;\n    } // Calculate bytelength of string.\n\n\n    const byteLength = Buffer.byteLength(value, encodingVal); // Ensure there is enough internal Buffer capacity.\n\n    if (isInsert) {\n      this.ensureInsertable(byteLength, offsetVal);\n    } else {\n      this._ensureWriteable(byteLength, offsetVal);\n    } // Write value\n\n\n    this._buff.write(value, offsetVal, byteLength, encodingVal); // Increment internal Buffer write offset;\n\n\n    if (isInsert) {\n      this._writeOffset += byteLength;\n    } else {\n      // If an offset was given, check to see if we wrote beyond the current writeOffset.\n      if (typeof arg3 === 'number') {\n        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n      } else {\n        // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n        this._writeOffset += byteLength;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Handles writing or insert of a Buffer.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   */\n\n\n  _handleBuffer(value, isInsert, offset) {\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure there is enough internal Buffer capacity.\n\n    if (isInsert) {\n      this.ensureInsertable(value.length, offsetVal);\n    } else {\n      this._ensureWriteable(value.length, offsetVal);\n    } // Write buffer value\n\n\n    value.copy(this._buff, offsetVal); // Increment internal Buffer write offset;\n\n    if (isInsert) {\n      this._writeOffset += value.length;\n    } else {\n      // If an offset was given, check to see if we wrote beyond the current writeOffset.\n      if (typeof offset === 'number') {\n        this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n      } else {\n        // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n        this._writeOffset += value.length;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to read data.\n   *\n   * @param length { Number } The length of the data that needs to be read.\n   * @param offset { Number } The offset of the data that needs to be read.\n   */\n\n\n  ensureReadable(length, offset) {\n    // Offset value defaults to managed read offset.\n    let offsetVal = this._readOffset; // If an offset was provided, use it.\n\n    if (typeof offset !== 'undefined') {\n      // Checks for valid numberic value;\n      utils_1.checkOffsetValue(offset); // Overide with custom offset.\n\n      offsetVal = offset;\n    } // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n\n\n    if (offsetVal < 0 || offsetVal + length > this.length) {\n      throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n    }\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to insert data.\n   *\n   * @param dataLength { Number } The length of the data that needs to be written.\n   * @param offset { Number } The offset of the data to be written.\n   */\n\n\n  ensureInsertable(dataLength, offset) {\n    // Checks for valid numberic value;\n    utils_1.checkOffsetValue(offset); // Ensure there is enough internal Buffer capacity.\n\n    this._ensureCapacity(this.length + dataLength); // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n\n\n    if (offset < this.length) {\n      this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n    } // Adjust tracked smart buffer length\n\n\n    if (offset + dataLength > this.length) {\n      this.length = offset + dataLength;\n    } else {\n      this.length += dataLength;\n    }\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to write data.\n   *\n   * @param dataLength { Number } The length of the data that needs to be written.\n   * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n   */\n\n\n  _ensureWriteable(dataLength, offset) {\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure enough capacity to write data.\n\n    this._ensureCapacity(offsetVal + dataLength); // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n\n\n    if (offsetVal + dataLength > this.length) {\n      this.length = offsetVal + dataLength;\n    }\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n   *\n   * @param minLength { Number } The minimum length of the data needs to be written.\n   */\n\n\n  _ensureCapacity(minLength) {\n    const oldLength = this._buff.length;\n\n    if (minLength > oldLength) {\n      let data = this._buff;\n      let newLength = oldLength * 3 / 2 + 1;\n\n      if (newLength < minLength) {\n        newLength = minLength;\n      }\n\n      this._buff = Buffer.allocUnsafe(newLength);\n      data.copy(this._buff, 0, 0, oldLength);\n    }\n  }\n  /**\n   * Reads a numeric number value using the provided function.\n   *\n   * @typeparam T { number | bigint } The type of the value to be read\n   *\n   * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n   * @param byteSize { Number } The number of bytes read.\n   * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n   *\n   * @returns { T } the number value\n   */\n\n\n  _readNumberValue(func, byteSize, offset) {\n    this.ensureReadable(byteSize, offset); // Call Buffer.readXXXX();\n\n    const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset); // Adjust internal read offset if an optional read offset was not provided.\n\n    if (typeof offset === 'undefined') {\n      this._readOffset += byteSize;\n    }\n\n    return value;\n  }\n  /**\n   * Inserts a numeric number value based on the given offset and value.\n   *\n   * @typeparam T { number | bigint } The type of the value to be written\n   *\n   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n   * @param byteSize { Number } The number of bytes written.\n   * @param value { T } The number value to write.\n   * @param offset { Number } the offset to write the number at (REQUIRED).\n   *\n   * @returns SmartBuffer this buffer\n   */\n\n\n  _insertNumberValue(func, byteSize, value, offset) {\n    // Check for invalid offset values.\n    utils_1.checkOffsetValue(offset); // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n\n    this.ensureInsertable(byteSize, offset); // Call buffer.writeXXXX();\n\n    func.call(this._buff, value, offset); // Adjusts internally managed write offset.\n\n    this._writeOffset += byteSize;\n    return this;\n  }\n  /**\n   * Writes a numeric number value based on the given offset and value.\n   *\n   * @typeparam T { number | bigint } The type of the value to be written\n   *\n   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n   * @param byteSize { Number } The number of bytes written.\n   * @param value { T } The number value to write.\n   * @param offset { Number } the offset to write the number at (REQUIRED).\n   *\n   * @returns SmartBuffer this buffer\n   */\n\n\n  _writeNumberValue(func, byteSize, value, offset) {\n    // If an offset was provided, validate it.\n    if (typeof offset === 'number') {\n      // Check if we're writing beyond the bounds of the managed data.\n      if (offset < 0) {\n        throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n      }\n\n      utils_1.checkOffsetValue(offset);\n    } // Default to writeOffset if no offset value was given.\n\n\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n\n    this._ensureWriteable(byteSize, offsetVal);\n\n    func.call(this._buff, value, offsetVal); // If an offset was given, check to see if we wrote beyond the current writeOffset.\n\n    if (typeof offset === 'number') {\n      this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n    } else {\n      // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n      this._writeOffset += byteSize;\n    }\n\n    return this;\n  }\n\n}\n\nexports.SmartBuffer = SmartBuffer;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils_1","require","DEFAULT_SMARTBUFFER_SIZE","DEFAULT_SMARTBUFFER_ENCODING","SmartBuffer","constructor","options","length","_encoding","_writeOffset","_readOffset","isSmartBufferOptions","encoding","checkEncoding","size","isFiniteInteger","_buff","Buffer","allocUnsafe","Error","ERRORS","INVALID_SMARTBUFFER_SIZE","buff","isBuffer","INVALID_SMARTBUFFER_BUFFER","INVALID_SMARTBUFFER_OBJECT","fromSize","fromBuffer","fromOptions","castOptions","undefined","readInt8","offset","_readNumberValue","prototype","readInt16BE","readInt16LE","readInt32BE","readInt32LE","readBigInt64BE","bigIntAndBufferInt64Check","readBigInt64LE","writeInt8","_writeNumberValue","insertInt8","_insertNumberValue","writeInt16BE","insertInt16BE","writeInt16LE","insertInt16LE","writeInt32BE","insertInt32BE","writeInt32LE","insertInt32LE","writeBigInt64BE","insertBigInt64BE","writeBigInt64LE","insertBigInt64LE","readUInt8","readUInt16BE","readUInt16LE","readUInt32BE","readUInt32LE","readBigUInt64BE","readBigUInt64LE","writeUInt8","insertUInt8","writeUInt16BE","insertUInt16BE","writeUInt16LE","insertUInt16LE","writeUInt32BE","insertUInt32BE","writeUInt32LE","insertUInt32LE","writeBigUInt64BE","insertBigUInt64BE","writeBigUInt64LE","insertBigUInt64LE","readFloatBE","readFloatLE","writeFloatBE","insertFloatBE","writeFloatLE","insertFloatLE","readDoubleBE","readDoubleLE","writeDoubleBE","insertDoubleBE","writeDoubleLE","insertDoubleLE","readString","arg1","lengthVal","checkLengthValue","Math","min","slice","toString","insertString","checkOffsetValue","_handleString","writeString","arg2","readStringNT","nullPos","i","insertStringNT","writeStringNT","writeOffset","readBuffer","endPoint","insertBuffer","_handleBuffer","writeBuffer","readBufferNT","insertBufferNT","writeBufferNT","clear","remaining","readOffset","checkTargetOffset","internalBuffer","toBuffer","encodingVal","destroy","isInsert","arg3","offsetVal","byteLength","ensureInsertable","_ensureWriteable","write","max","copy","ensureReadable","INVALID_READ_BEYOND_BOUNDS","dataLength","_ensureCapacity","minLength","oldLength","data","newLength","func","byteSize","call","INVALID_WRITE_BEYOND_BOUNDS"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/smart-buffer/build/smartbuffer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */\n    constructor(options) {\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n                // Check for initial Buffer\n            }\n            else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            }\n            else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== 'undefined') {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return (castOptions &&\n            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === 'number') {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        }\n        else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readStringNT(encoding) {\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */\n    readBuffer(length) {\n        if (typeof length !== 'undefined') {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== 'undefined') {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */\n    clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */\n    set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */\n    get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */\n    toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */\n    destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === 'number') {\n            offsetVal = arg3;\n            // Check for encoding\n        }\n        else if (typeof arg3 === 'string') {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        }\n        else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        }\n        else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */\n    ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== 'undefined') {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */\n    ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        }\n        else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */\n    _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */\n    _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = (oldLength * 3) / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */\n    _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === 'undefined') {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === 'number') {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        }\n        else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}