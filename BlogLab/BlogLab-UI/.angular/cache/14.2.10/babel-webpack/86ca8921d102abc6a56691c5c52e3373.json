{"ast":null,"code":"var _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\n// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\nconst npa = require('npm-package-arg');\n\nconst ssri = require('ssri');\n\nconst {\n  promisify\n} = require('util');\n\nconst {\n  basename,\n  dirname\n} = require('path');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst tar = require('tar');\n\nconst log = require('proc-log');\n\nconst retry = require('promise-retry');\n\nconst fsm = require('fs-minipass');\n\nconst cacache = require('cacache');\n\nconst isPackageBin = require('./util/is-package-bin.js');\n\nconst removeTrailingSlashes = require('./util/trailing-slashes.js');\n\nconst getContents = require('@npmcli/installed-package-contents');\n\nconst readPackageJsonFast = require('read-package-json-fast');\n\nconst readPackageJson = promisify(require('read-package-json'));\n\nconst Minipass = require('minipass'); // we only change ownership on unix platforms, and only if uid is 0\n\n\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid()\n} : null;\nconst chownr = selfOwner ? promisify(require('chownr')) : null;\nconst inferOwner = selfOwner ? require('infer-owner') : null;\n\nconst mkdirp = require('mkdirp');\n\nconst cacheDir = require('./util/cache-dir.js'); // Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\n\n\nconst _chown = Symbol('_chown');\n\nconst _extract = Symbol('_extract');\n\nconst _mkdir = Symbol('_mkdir');\n\nconst _empty = Symbol('_empty');\n\nconst _toFile = Symbol('_toFile');\n\nconst _tarxOptions = Symbol('_tarxOptions');\n\nconst _entryMode = Symbol('_entryMode');\n\nconst _istream = Symbol('_istream');\n\nconst _assertType = Symbol('_assertType');\n\nconst _tarballFromCache = Symbol('_tarballFromCache');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\n\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson');\n\nclass FetcherBase {\n  constructor(spec, opts) {\n    if (!opts || typeof opts !== 'object') {\n      throw new TypeError('options object is required');\n    }\n\n    this.spec = npa(spec, opts.where);\n    this.allowGitIgnore = !!opts.allowGitIgnore; // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n\n    this.from = this.spec.registry ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec;\n\n    this[_assertType](); // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n\n\n    this.opts = { ...opts\n    };\n    this.cache = opts.cache || cacheDir();\n    this.resolved = opts.resolved || null; // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512';\n\n    if (typeof opts.integrity === 'string') {\n      this.opts.integrity = ssri.parse(opts.integrity);\n    }\n\n    this.package = null;\n    this.type = this.constructor.name;\n    this.fmode = opts.fmode || 0o666;\n    this.dmode = opts.dmode || 0o777; // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n\n    this.umask = opts.umask || 0;\n    this.preferOnline = !!opts.preferOnline;\n    this.preferOffline = !!opts.preferOffline;\n    this.offline = !!opts.offline;\n    this.before = opts.before;\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata;\n    this.fullReadJson = !!opts.fullReadJson;\n\n    if (this.fullReadJson) {\n      this[_readPackageJson] = readPackageJson;\n    } else {\n      this[_readPackageJson] = readPackageJsonFast;\n    } // rrh is a registry hostname or 'never' or 'always'\n    // defaults to registry.npmjs.org\n\n\n    this.replaceRegistryHost = !opts.replaceRegistryHost || opts.replaceRegistryHost === 'npmjs' ? 'registry.npmjs.org' : opts.replaceRegistryHost;\n    this.defaultTag = opts.defaultTag || 'latest';\n    this.registry = removeTrailingSlashes(opts.registry || 'https://registry.npmjs.org'); // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n\n    this.npmBin = opts.npmBin || 'npm'; // command to install deps for preparing\n\n    this.npmInstallCmd = opts.npmInstallCmd || ['install', '--force']; // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n\n    this.npmCliConfig = opts.npmCliConfig || [`--cache=${dirname(this.cache)}`, `--prefer-offline=${!!this.preferOffline}`, `--prefer-online=${!!this.preferOnline}`, `--offline=${!!this.offline}`, ...(this.before ? [`--before=${this.before.toISOString()}`] : []), '--no-progress', '--no-save', '--no-audit', // override any omit settings from the environment\n    '--include=dev', '--include=peer', '--include=optional', // we need the actual things, not just the lockfile\n    '--no-package-lock-only', '--no-dry-run'];\n  }\n\n  get integrity() {\n    return this.opts.integrity || null;\n  }\n\n  set integrity(i) {\n    if (!i) {\n      return;\n    }\n\n    i = ssri.parse(i);\n    const current = this.opts.integrity; // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n\n    if (current) {\n      current.merge(i);\n    } else {\n      this.opts.integrity = i;\n    }\n  }\n\n  get notImplementedError() {\n    return new Error('not implemented in this fetcher type: ' + this.type);\n  } // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n\n\n  resolve() {\n    return this.resolved ? Promise.resolve(this.resolved) : Promise.reject(this.notImplementedError);\n  }\n\n  packument() {\n    return Promise.reject(this.notImplementedError);\n  } // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n\n\n  manifest() {\n    return Promise.reject(this.notImplementedError);\n  } // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n\n\n  [_tarballFromResolved]() {\n    throw this.notImplementedError;\n  } // public, should not be overridden\n\n\n  tarball() {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity);\n      data.resolved = this.resolved;\n      data.from = this.from;\n      return data;\n    }));\n  } // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n\n\n  [_tarballFromCache]() {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts);\n  }\n\n  get [_cacheFetches]() {\n    return true;\n  }\n\n  [_istream](stream) {\n    // if not caching this, just return it\n    if (!this.opts.cache || !this[_cacheFetches]) {\n      // instead of creating a new integrity stream, we only piggyback on the\n      // provided stream's events\n      if (stream.hasIntegrityEmitter) {\n        stream.on('integrity', i => this.integrity = i);\n        return stream;\n      }\n\n      const istream = ssri.integrityStream(this.opts);\n      istream.on('integrity', i => this.integrity = i);\n      stream.on('error', err => istream.emit('error', err));\n      return stream.pipe(istream);\n    } // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the middleStream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the middleStream end until the cache stream ends.\n\n\n    const middleStream = new Minipass();\n    stream.on('error', err => middleStream.emit('error', err));\n    stream.pipe(middleStream, {\n      end: false\n    });\n    const cstream = cacache.put.stream(this.opts.cache, `pacote:tarball:${this.from}`, this.opts);\n    cstream.on('integrity', i => this.integrity = i);\n    cstream.on('error', err => stream.emit('error', err));\n    stream.pipe(cstream); // eslint-disable-next-line promise/catch-or-return\n\n    cstream.promise().catch(() => {}).then(() => middleStream.end());\n    return middleStream;\n  }\n\n  pickIntegrityAlgorithm() {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts) : this.defaultIntegrityAlgorithm;\n  } // TODO: check error class, once those are rolled out to our deps\n\n\n  isDataCorruptionError(er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR';\n  } // override the types getter\n\n\n  get types() {\n    return false;\n  }\n\n  [_assertType]() {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${this.spec.type}) for ${this.constructor.name}. Supported types: ${this.types.join(', ')}`);\n    }\n  } // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n\n\n  isRetriableError(er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) || er.code === 'ENOENT' || er.code === 'EISDIR';\n  } // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n\n\n  tarballStream(streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n    const fromCache = !this.preferOnline && this.integrity && this.resolved ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        log.warn('tarball', `cached data for ${this.spec} (${this.integrity}) seems to be corrupted. Refreshing cache.`);\n        return this.cleanupCached().then(() => {\n          throw er;\n        });\n      } else {\n        throw er;\n      }\n    }) : null;\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er)) {\n          throw er;\n        }\n\n        log.silly('tarball', `no local data for ${this.spec}. Extracting by manifest.`);\n      }\n\n      return this.resolve().then(() => retry(tryAgain => streamHandler(this[_istream](this[_tarballFromResolved]())).catch(streamErr => {\n        // Most likely data integrity.  A cache ENOENT error is unlikely\n        // here, since we're definitely not reading from the cache, but it\n        // IS possible that the fetch subsystem accessed the cache, and the\n        // entry got blown away or something.  Try one more time to be sure.\n        if (this.isRetriableError(streamErr)) {\n          log.warn('tarball', `tarball data for ${this.spec} (${this.integrity}) seems to be corrupted. Trying again.`);\n          return this.cleanupCached().then(() => tryAgain(streamErr));\n        }\n\n        throw streamErr;\n      }), {\n        retries: 1,\n        minTimeout: 0,\n        maxTimeout: 0\n      }));\n    };\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved();\n  }\n\n  cleanupCached() {\n    return cacache.rm.content(this.cache, this.integrity, this.opts);\n  }\n\n  [_chown](path, uid, gid) {\n    return _asyncToGenerator(function* () {\n      return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid) ? chownr(path, uid, gid) :\n      /* istanbul ignore next - we don't test in root-owned folders */\n      null;\n    })();\n  }\n\n  [_empty](path) {\n    return getContents({\n      path,\n      depth: 1\n    }).then(contents => Promise.all(contents.map(entry => rimraf(entry))));\n  }\n\n  [_mkdir](dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({})) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => this[_empty](dest).then(() => mkdirp(dest)).then(made => {\n      // ignore the || dest part in coverage.  It's there to handle\n      // race conditions where the dir may be made by someone else\n      // after being removed by us.\n      const dir = made ||\n      /* istanbul ignore next */\n      dest;\n      return this[_chown](dir, uid, gid);\n    }).then(() => ({\n      uid,\n      gid\n    })));\n  } // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n\n\n  extract(dest) {\n    return this[_mkdir](dest).then(({\n      uid,\n      gid\n    }) => this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)));\n  }\n\n  [_toFile](dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest);\n      str.on('error', er => writer.emit('error', er));\n      writer.on('error', er => rej(er));\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from\n      }));\n      str.pipe(writer);\n    }));\n  } // don't use this[_mkdir] because we don't want to rimraf anything\n\n\n  tarballFile(dest) {\n    const dir = dirname(dest);\n    return !inferOwner ? mkdirp(dir).then(() => this[_toFile](dest)) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => mkdirp(dir).then(made => this[_toFile](dest).then(res => this[_chown](made || dir, uid, gid).then(() => res))));\n  }\n\n  [_extract](dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({\n      cwd: dest,\n      uid,\n      gid\n    }));\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from\n        });\n      });\n      extractor.on('error', er => {\n        log.warn('tar', er.message);\n        log.silly('tar', er);\n        reject(er);\n      });\n      tarball.on('error', er => reject(er));\n    });\n    tarball.pipe(extractor);\n    return p;\n  } // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n\n\n  [_entryMode](path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode : /File$/.test(type) ? this.fmode :\n    /* istanbul ignore next - should never happen in a pkg */\n    0; // make sure package bins are executable\n\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0; // always ensure that files are read/writable by the owner\n\n    return (mode | m) & ~this.umask | exe | 0o600;\n  }\n\n  [_tarxOptions]({\n    cwd,\n    uid,\n    gid\n  }) {\n    const sawIgnores = new Set();\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type)) {\n          return false;\n        }\n\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type); // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path);\n\n          if (base === '.npmignore') {\n            sawIgnores.add(entry.path);\n          } else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore');\n\n            if (sawIgnores.has(ni)) {\n              return false;\n            }\n\n            entry.path = ni;\n          }\n\n          return true;\n        }\n      },\n      strip: 1,\n      onwarn:\n      /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        log.warn('tar', code, msg);\n        log.silly('tar', code, msg, data);\n      },\n      uid,\n      gid,\n      umask: this.umask\n    };\n  }\n\n}\n\nmodule.exports = FetcherBase; // Child classes\n\nconst GitFetcher = require('./git.js');\n\nconst RegistryFetcher = require('./registry.js');\n\nconst FileFetcher = require('./file.js');\n\nconst DirFetcher = require('./dir.js');\n\nconst RemoteFetcher = require('./remote.js'); // Get an appropriate fetcher object from a spec and options\n\n\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where);\n\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts);\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts);\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts);\n\n    case 'file':\n      return new FileFetcher(spec, opts);\n\n    case 'directory':\n      return new DirFetcher(spec, opts);\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type);\n  }\n};","map":{"version":3,"names":["npa","require","ssri","promisify","basename","dirname","rimraf","tar","log","retry","fsm","cacache","isPackageBin","removeTrailingSlashes","getContents","readPackageJsonFast","readPackageJson","Minipass","selfOwner","process","getuid","uid","gid","getgid","chownr","inferOwner","mkdirp","cacheDir","_chown","Symbol","_extract","_mkdir","_empty","_toFile","_tarxOptions","_entryMode","_istream","_assertType","_tarballFromCache","_tarballFromResolved","for","_cacheFetches","_readPackageJson","FetcherBase","constructor","spec","opts","TypeError","where","allowGitIgnore","from","registry","name","rawSpec","saveSpec","cache","resolved","defaultIntegrityAlgorithm","integrity","parse","package","type","fmode","dmode","umask","preferOnline","preferOffline","offline","before","fullMetadata","fullReadJson","replaceRegistryHost","defaultTag","npmBin","npmInstallCmd","npmCliConfig","toISOString","i","current","merge","notImplementedError","Error","resolve","Promise","reject","packument","manifest","tarball","tarballStream","stream","concat","then","data","String","get","byDigest","hasIntegrityEmitter","on","istream","integrityStream","err","emit","pipe","middleStream","end","cstream","put","promise","catch","pickIntegrityAlgorithm","pickAlgorithm","isDataCorruptionError","er","code","types","includes","join","isRetriableError","streamHandler","fromCache","warn","cleanupCached","fromResolved","silly","tryAgain","streamErr","retries","minTimeout","maxTimeout","rm","content","path","depth","contents","all","map","entry","dest","made","dir","extract","str","res","rej","writer","WriteStream","tarballFile","extractor","x","cwd","p","message","mode","m","test","exe","sawIgnores","Set","noChmod","noMtime","filter","base","add","ni","replace","has","strip","onwarn","msg","module","exports","GitFetcher","RegistryFetcher","FileFetcher","DirFetcher","RemoteFetcher","subSpec"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/pacote/lib/fetcher.js"],"sourcesContent":["// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\n\nconst npa = require('npm-package-arg')\nconst ssri = require('ssri')\nconst { promisify } = require('util')\nconst { basename, dirname } = require('path')\nconst rimraf = promisify(require('rimraf'))\nconst tar = require('tar')\nconst log = require('proc-log')\nconst retry = require('promise-retry')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst isPackageBin = require('./util/is-package-bin.js')\nconst removeTrailingSlashes = require('./util/trailing-slashes.js')\nconst getContents = require('@npmcli/installed-package-contents')\nconst readPackageJsonFast = require('read-package-json-fast')\nconst readPackageJson = promisify(require('read-package-json'))\nconst Minipass = require('minipass')\n\n// we only change ownership on unix platforms, and only if uid is 0\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid(),\n} : null\nconst chownr = selfOwner ? promisify(require('chownr')) : null\nconst inferOwner = selfOwner ? require('infer-owner') : null\nconst mkdirp = require('mkdirp')\nconst cacheDir = require('./util/cache-dir.js')\n\n// Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\nconst _chown = Symbol('_chown')\nconst _extract = Symbol('_extract')\nconst _mkdir = Symbol('_mkdir')\nconst _empty = Symbol('_empty')\nconst _toFile = Symbol('_toFile')\nconst _tarxOptions = Symbol('_tarxOptions')\nconst _entryMode = Symbol('_entryMode')\nconst _istream = Symbol('_istream')\nconst _assertType = Symbol('_assertType')\nconst _tarballFromCache = Symbol('_tarballFromCache')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches')\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson')\n\nclass FetcherBase {\n  constructor (spec, opts) {\n    if (!opts || typeof opts !== 'object') {\n      throw new TypeError('options object is required')\n    }\n    this.spec = npa(spec, opts.where)\n\n    this.allowGitIgnore = !!opts.allowGitIgnore\n\n    // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n    this.from = this.spec.registry\n      ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec\n\n    this[_assertType]()\n    // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n    this.opts = { ...opts }\n\n    this.cache = opts.cache || cacheDir()\n    this.resolved = opts.resolved || null\n\n    // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512'\n\n    if (typeof opts.integrity === 'string') {\n      this.opts.integrity = ssri.parse(opts.integrity)\n    }\n\n    this.package = null\n    this.type = this.constructor.name\n    this.fmode = opts.fmode || 0o666\n    this.dmode = opts.dmode || 0o777\n    // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n    this.umask = opts.umask || 0\n\n    this.preferOnline = !!opts.preferOnline\n    this.preferOffline = !!opts.preferOffline\n    this.offline = !!opts.offline\n\n    this.before = opts.before\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata\n    this.fullReadJson = !!opts.fullReadJson\n    if (this.fullReadJson) {\n      this[_readPackageJson] = readPackageJson\n    } else {\n      this[_readPackageJson] = readPackageJsonFast\n    }\n\n    // rrh is a registry hostname or 'never' or 'always'\n    // defaults to registry.npmjs.org\n    this.replaceRegistryHost = (!opts.replaceRegistryHost || opts.replaceRegistryHost === 'npmjs') ?\n      'registry.npmjs.org' : opts.replaceRegistryHost\n\n    this.defaultTag = opts.defaultTag || 'latest'\n    this.registry = removeTrailingSlashes(opts.registry || 'https://registry.npmjs.org')\n\n    // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n    this.npmBin = opts.npmBin || 'npm'\n\n    // command to install deps for preparing\n    this.npmInstallCmd = opts.npmInstallCmd || ['install', '--force']\n\n    // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n    this.npmCliConfig = opts.npmCliConfig || [\n      `--cache=${dirname(this.cache)}`,\n      `--prefer-offline=${!!this.preferOffline}`,\n      `--prefer-online=${!!this.preferOnline}`,\n      `--offline=${!!this.offline}`,\n      ...(this.before ? [`--before=${this.before.toISOString()}`] : []),\n      '--no-progress',\n      '--no-save',\n      '--no-audit',\n      // override any omit settings from the environment\n      '--include=dev',\n      '--include=peer',\n      '--include=optional',\n      // we need the actual things, not just the lockfile\n      '--no-package-lock-only',\n      '--no-dry-run',\n    ]\n  }\n\n  get integrity () {\n    return this.opts.integrity || null\n  }\n\n  set integrity (i) {\n    if (!i) {\n      return\n    }\n\n    i = ssri.parse(i)\n    const current = this.opts.integrity\n\n    // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n    if (current) {\n      current.merge(i)\n    } else {\n      this.opts.integrity = i\n    }\n  }\n\n  get notImplementedError () {\n    return new Error('not implemented in this fetcher type: ' + this.type)\n  }\n\n  // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n  resolve () {\n    return this.resolved ? Promise.resolve(this.resolved)\n      : Promise.reject(this.notImplementedError)\n  }\n\n  packument () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n  manifest () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // private, should be overridden.\n  // Note that they should *not* calculate or check integrity or cache,\n  // but *just*  return the raw tarball data stream.\n  [_tarballFromResolved] () {\n    throw this.notImplementedError\n  }\n\n  // public, should not be overridden\n  tarball () {\n    return this.tarballStream(stream => stream.concat().then(data => {\n      data.integrity = this.integrity && String(this.integrity)\n      data.resolved = this.resolved\n      data.from = this.from\n      return data\n    }))\n  }\n\n  // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n  [_tarballFromCache] () {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts)\n  }\n\n  get [_cacheFetches] () {\n    return true\n  }\n\n  [_istream] (stream) {\n    // if not caching this, just return it\n    if (!this.opts.cache || !this[_cacheFetches]) {\n      // instead of creating a new integrity stream, we only piggyback on the\n      // provided stream's events\n      if (stream.hasIntegrityEmitter) {\n        stream.on('integrity', i => this.integrity = i)\n        return stream\n      }\n\n      const istream = ssri.integrityStream(this.opts)\n      istream.on('integrity', i => this.integrity = i)\n      stream.on('error', err => istream.emit('error', err))\n      return stream.pipe(istream)\n    }\n\n    // we have to return a stream that gets ALL the data, and proxies errors,\n    // but then pipe from the original tarball stream into the cache as well.\n    // To do this without losing any data, and since the cacache put stream\n    // is not a passthrough, we have to pipe from the original stream into\n    // the cache AFTER we pipe into the middleStream.  Since the cache stream\n    // has an asynchronous flush to write its contents to disk, we need to\n    // defer the middleStream end until the cache stream ends.\n    const middleStream = new Minipass()\n    stream.on('error', err => middleStream.emit('error', err))\n    stream.pipe(middleStream, { end: false })\n    const cstream = cacache.put.stream(\n      this.opts.cache,\n      `pacote:tarball:${this.from}`,\n      this.opts\n    )\n    cstream.on('integrity', i => this.integrity = i)\n    cstream.on('error', err => stream.emit('error', err))\n    stream.pipe(cstream)\n\n    // eslint-disable-next-line promise/catch-or-return\n    cstream.promise().catch(() => {}).then(() => middleStream.end())\n    return middleStream\n  }\n\n  pickIntegrityAlgorithm () {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts)\n      : this.defaultIntegrityAlgorithm\n  }\n\n  // TODO: check error class, once those are rolled out to our deps\n  isDataCorruptionError (er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR'\n  }\n\n  // override the types getter\n  get types () {\n    return false\n  }\n\n  [_assertType] () {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${\n        this.spec.type\n      }) for ${\n        this.constructor.name\n      }. Supported types: ${this.types.join(', ')}`)\n    }\n  }\n\n  // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n  isRetriableError (er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) ||\n      er.code === 'ENOENT' ||\n      er.code === 'EISDIR'\n  }\n\n  // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n  tarballStream (streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n\n    const fromCache = (\n      !this.preferOnline &&\n      this.integrity &&\n      this.resolved\n    ) ? streamHandler(this[_tarballFromCache]()).catch(er => {\n        if (this.isDataCorruptionError(er)) {\n          log.warn('tarball', `cached data for ${\n          this.spec\n        } (${this.integrity}) seems to be corrupted. Refreshing cache.`)\n          return this.cleanupCached().then(() => {\n            throw er\n          })\n        } else {\n          throw er\n        }\n      }) : null\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er)) {\n          throw er\n        }\n        log.silly('tarball', `no local data for ${\n          this.spec\n        }. Extracting by manifest.`)\n      }\n      return this.resolve().then(() => retry(tryAgain =>\n        streamHandler(this[_istream](this[_tarballFromResolved]()))\n          .catch(streamErr => {\n          // Most likely data integrity.  A cache ENOENT error is unlikely\n          // here, since we're definitely not reading from the cache, but it\n          // IS possible that the fetch subsystem accessed the cache, and the\n          // entry got blown away or something.  Try one more time to be sure.\n            if (this.isRetriableError(streamErr)) {\n              log.warn('tarball', `tarball data for ${\n              this.spec\n            } (${this.integrity}) seems to be corrupted. Trying again.`)\n              return this.cleanupCached().then(() => tryAgain(streamErr))\n            }\n            throw streamErr\n          }), { retries: 1, minTimeout: 0, maxTimeout: 0 }))\n    }\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved()\n  }\n\n  cleanupCached () {\n    return cacache.rm.content(this.cache, this.integrity, this.opts)\n  }\n\n  async [_chown] (path, uid, gid) {\n    return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid)\n      ? chownr(path, uid, gid)\n      : /* istanbul ignore next - we don't test in root-owned folders */ null\n  }\n\n  [_empty] (path) {\n    return getContents({ path, depth: 1 }).then(contents => Promise.all(\n      contents.map(entry => rimraf(entry))))\n  }\n\n  [_mkdir] (dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner\n      ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({}))\n      : inferOwner(dest).then(({ uid, gid }) =>\n        this[_empty](dest)\n          .then(() => mkdirp(dest))\n          .then(made => {\n            // ignore the || dest part in coverage.  It's there to handle\n            // race conditions where the dir may be made by someone else\n            // after being removed by us.\n            const dir = made || /* istanbul ignore next */ dest\n            return this[_chown](dir, uid, gid)\n          })\n          .then(() => ({ uid, gid })))\n  }\n\n  // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n  extract (dest) {\n    return this[_mkdir](dest).then(({ uid, gid }) =>\n      this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)))\n  }\n\n  [_toFile] (dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest)\n      str.on('error', er => writer.emit('error', er))\n      writer.on('error', er => rej(er))\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from,\n      }))\n      str.pipe(writer)\n    }))\n  }\n\n  // don't use this[_mkdir] because we don't want to rimraf anything\n  tarballFile (dest) {\n    const dir = dirname(dest)\n    return !inferOwner\n      ? mkdirp(dir).then(() => this[_toFile](dest))\n      : inferOwner(dest).then(({ uid, gid }) =>\n        mkdirp(dir).then(made => this[_toFile](dest)\n          .then(res => this[_chown](made || dir, uid, gid)\n            .then(() => res))))\n  }\n\n  [_extract] (dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({ cwd: dest, uid, gid }))\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from,\n        })\n      })\n\n      extractor.on('error', er => {\n        log.warn('tar', er.message)\n        log.silly('tar', er)\n        reject(er)\n      })\n\n      tarball.on('error', er => reject(er))\n    })\n\n    tarball.pipe(extractor)\n    return p\n  }\n\n  // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n  [_entryMode] (path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode\n      : /File$/.test(type) ? this.fmode\n      : /* istanbul ignore next - should never happen in a pkg */ 0\n\n    // make sure package bins are executable\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0\n    // always ensure that files are read/writable by the owner\n    return ((mode | m) & ~this.umask) | exe | 0o600\n  }\n\n  [_tarxOptions] ({ cwd, uid, gid }) {\n    const sawIgnores = new Set()\n    return {\n      cwd,\n      noChmod: true,\n      noMtime: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type)) {\n          return false\n        }\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type)\n        // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path)\n          if (base === '.npmignore') {\n            sawIgnores.add(entry.path)\n          } else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore')\n            if (sawIgnores.has(ni)) {\n              return false\n            }\n            entry.path = ni\n          }\n          return true\n        }\n      },\n      strip: 1,\n      onwarn: /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        log.warn('tar', code, msg)\n        log.silly('tar', code, msg, data)\n      },\n      uid,\n      gid,\n      umask: this.umask,\n    }\n  }\n}\n\nmodule.exports = FetcherBase\n\n// Child classes\nconst GitFetcher = require('./git.js')\nconst RegistryFetcher = require('./registry.js')\nconst FileFetcher = require('./file.js')\nconst DirFetcher = require('./dir.js')\nconst RemoteFetcher = require('./remote.js')\n\n// Get an appropriate fetcher object from a spec and options\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where)\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts)\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts)\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts)\n\n    case 'file':\n      return new FileFetcher(spec, opts)\n\n    case 'directory':\n      return new DirFetcher(spec, opts)\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}