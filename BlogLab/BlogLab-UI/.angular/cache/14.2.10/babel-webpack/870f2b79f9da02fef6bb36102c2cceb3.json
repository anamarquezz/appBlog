{"ast":null,"code":"'use strict'; // The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0;\n\n  function hasMore() {\n    return index < tokens.length;\n  }\n\n  function token() {\n    return hasMore() ? tokens[index] : null;\n  }\n\n  function next() {\n    if (!hasMore()) {\n      throw new Error();\n    }\n\n    index++;\n  }\n\n  function parseOperator(operator) {\n    var t = token();\n\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next();\n      return t.string;\n    }\n  }\n\n  function parseWith() {\n    if (parseOperator('WITH')) {\n      var t = token();\n\n      if (t && t.type === 'EXCEPTION') {\n        next();\n        return t.string;\n      }\n\n      throw new Error('Expected exception after `WITH`');\n    }\n  }\n\n  function parseLicenseRef() {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index;\n    var string = '';\n    var t = token();\n\n    if (t.type === 'DOCUMENTREF') {\n      next();\n      string += 'DocumentRef-' + t.string + ':';\n\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`');\n      }\n    }\n\n    t = token();\n\n    if (t.type === 'LICENSEREF') {\n      next();\n      string += 'LicenseRef-' + t.string;\n      return {\n        license: string\n      };\n    }\n\n    index = begin;\n  }\n\n  function parseLicense() {\n    var t = token();\n\n    if (t && t.type === 'LICENSE') {\n      next();\n      var node = {\n        license: t.string\n      };\n\n      if (parseOperator('+')) {\n        node.plus = true;\n      }\n\n      var exception = parseWith();\n\n      if (exception) {\n        node.exception = exception;\n      }\n\n      return node;\n    }\n  }\n\n  function parseParenthesizedExpression() {\n    var left = parseOperator('(');\n\n    if (!left) {\n      return;\n    }\n\n    var expr = parseExpression();\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`');\n    }\n\n    return expr;\n  }\n\n  function parseAtom() {\n    return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();\n  }\n\n  function makeBinaryOpParser(operator, nextParser) {\n    return function parseBinaryOp() {\n      var left = nextParser();\n\n      if (!left) {\n        return;\n      }\n\n      if (!parseOperator(operator)) {\n        return left;\n      }\n\n      var right = parseBinaryOp();\n\n      if (!right) {\n        throw new Error('Expected expression');\n      }\n\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      };\n    };\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom);\n  var parseExpression = makeBinaryOpParser('OR', parseAnd);\n  var node = parseExpression();\n\n  if (!node || hasMore()) {\n    throw new Error('Syntax error');\n  }\n\n  return node;\n};","map":{"version":3,"names":["module","exports","tokens","index","hasMore","length","token","next","Error","parseOperator","operator","t","type","string","parseWith","parseLicenseRef","begin","license","parseLicense","node","plus","exception","parseParenthesizedExpression","left","expr","parseExpression","parseAtom","makeBinaryOpParser","nextParser","parseBinaryOp","right","conjunction","toLowerCase","parseAnd"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/spdx-expression-parse/parse.js"],"sourcesContent":["'use strict'\n\n// The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0\n\n  function hasMore () {\n    return index < tokens.length\n  }\n\n  function token () {\n    return hasMore() ? tokens[index] : null\n  }\n\n  function next () {\n    if (!hasMore()) {\n      throw new Error()\n    }\n    index++\n  }\n\n  function parseOperator (operator) {\n    var t = token()\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next()\n      return t.string\n    }\n  }\n\n  function parseWith () {\n    if (parseOperator('WITH')) {\n      var t = token()\n      if (t && t.type === 'EXCEPTION') {\n        next()\n        return t.string\n      }\n      throw new Error('Expected exception after `WITH`')\n    }\n  }\n\n  function parseLicenseRef () {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index\n    var string = ''\n    var t = token()\n    if (t.type === 'DOCUMENTREF') {\n      next()\n      string += 'DocumentRef-' + t.string + ':'\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`')\n      }\n    }\n    t = token()\n    if (t.type === 'LICENSEREF') {\n      next()\n      string += 'LicenseRef-' + t.string\n      return { license: string }\n    }\n    index = begin\n  }\n\n  function parseLicense () {\n    var t = token()\n    if (t && t.type === 'LICENSE') {\n      next()\n      var node = { license: t.string }\n      if (parseOperator('+')) {\n        node.plus = true\n      }\n      var exception = parseWith()\n      if (exception) {\n        node.exception = exception\n      }\n      return node\n    }\n  }\n\n  function parseParenthesizedExpression () {\n    var left = parseOperator('(')\n    if (!left) {\n      return\n    }\n\n    var expr = parseExpression()\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`')\n    }\n\n    return expr\n  }\n\n  function parseAtom () {\n    return (\n      parseParenthesizedExpression() ||\n      parseLicenseRef() ||\n      parseLicense()\n    )\n  }\n\n  function makeBinaryOpParser (operator, nextParser) {\n    return function parseBinaryOp () {\n      var left = nextParser()\n      if (!left) {\n        return\n      }\n\n      if (!parseOperator(operator)) {\n        return left\n      }\n\n      var right = parseBinaryOp()\n      if (!right) {\n        throw new Error('Expected expression')\n      }\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      }\n    }\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom)\n  var parseExpression = makeBinaryOpParser('OR', parseAnd)\n\n  var node = parseExpression()\n  if (!node || hasMore()) {\n    throw new Error('Syntax error')\n  }\n  return node\n}\n"],"mappings":"AAAA,a,CAEA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,UAAUC,MAAV,EAAkB;EACjC,IAAIC,KAAK,GAAG,CAAZ;;EAEA,SAASC,OAAT,GAAoB;IAClB,OAAOD,KAAK,GAAGD,MAAM,CAACG,MAAtB;EACD;;EAED,SAASC,KAAT,GAAkB;IAChB,OAAOF,OAAO,KAAKF,MAAM,CAACC,KAAD,CAAX,GAAqB,IAAnC;EACD;;EAED,SAASI,IAAT,GAAiB;IACf,IAAI,CAACH,OAAO,EAAZ,EAAgB;MACd,MAAM,IAAII,KAAJ,EAAN;IACD;;IACDL,KAAK;EACN;;EAED,SAASM,aAAT,CAAwBC,QAAxB,EAAkC;IAChC,IAAIC,CAAC,GAAGL,KAAK,EAAb;;IACA,IAAIK,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAW,UAAhB,IAA8BF,QAAQ,KAAKC,CAAC,CAACE,MAAjD,EAAyD;MACvDN,IAAI;MACJ,OAAOI,CAAC,CAACE,MAAT;IACD;EACF;;EAED,SAASC,SAAT,GAAsB;IACpB,IAAIL,aAAa,CAAC,MAAD,CAAjB,EAA2B;MACzB,IAAIE,CAAC,GAAGL,KAAK,EAAb;;MACA,IAAIK,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAW,WAApB,EAAiC;QAC/BL,IAAI;QACJ,OAAOI,CAAC,CAACE,MAAT;MACD;;MACD,MAAM,IAAIL,KAAJ,CAAU,iCAAV,CAAN;IACD;EACF;;EAED,SAASO,eAAT,GAA4B;IAC1B;IACA;IACA;IACA,IAAIC,KAAK,GAAGb,KAAZ;IACA,IAAIU,MAAM,GAAG,EAAb;IACA,IAAIF,CAAC,GAAGL,KAAK,EAAb;;IACA,IAAIK,CAAC,CAACC,IAAF,KAAW,aAAf,EAA8B;MAC5BL,IAAI;MACJM,MAAM,IAAI,iBAAiBF,CAAC,CAACE,MAAnB,GAA4B,GAAtC;;MACA,IAAI,CAACJ,aAAa,CAAC,GAAD,CAAlB,EAAyB;QACvB,MAAM,IAAID,KAAJ,CAAU,sCAAV,CAAN;MACD;IACF;;IACDG,CAAC,GAAGL,KAAK,EAAT;;IACA,IAAIK,CAAC,CAACC,IAAF,KAAW,YAAf,EAA6B;MAC3BL,IAAI;MACJM,MAAM,IAAI,gBAAgBF,CAAC,CAACE,MAA5B;MACA,OAAO;QAAEI,OAAO,EAAEJ;MAAX,CAAP;IACD;;IACDV,KAAK,GAAGa,KAAR;EACD;;EAED,SAASE,YAAT,GAAyB;IACvB,IAAIP,CAAC,GAAGL,KAAK,EAAb;;IACA,IAAIK,CAAC,IAAIA,CAAC,CAACC,IAAF,KAAW,SAApB,EAA+B;MAC7BL,IAAI;MACJ,IAAIY,IAAI,GAAG;QAAEF,OAAO,EAAEN,CAAC,CAACE;MAAb,CAAX;;MACA,IAAIJ,aAAa,CAAC,GAAD,CAAjB,EAAwB;QACtBU,IAAI,CAACC,IAAL,GAAY,IAAZ;MACD;;MACD,IAAIC,SAAS,GAAGP,SAAS,EAAzB;;MACA,IAAIO,SAAJ,EAAe;QACbF,IAAI,CAACE,SAAL,GAAiBA,SAAjB;MACD;;MACD,OAAOF,IAAP;IACD;EACF;;EAED,SAASG,4BAAT,GAAyC;IACvC,IAAIC,IAAI,GAAGd,aAAa,CAAC,GAAD,CAAxB;;IACA,IAAI,CAACc,IAAL,EAAW;MACT;IACD;;IAED,IAAIC,IAAI,GAAGC,eAAe,EAA1B;;IAEA,IAAI,CAAChB,aAAa,CAAC,GAAD,CAAlB,EAAyB;MACvB,MAAM,IAAID,KAAJ,CAAU,cAAV,CAAN;IACD;;IAED,OAAOgB,IAAP;EACD;;EAED,SAASE,SAAT,GAAsB;IACpB,OACEJ,4BAA4B,MAC5BP,eAAe,EADf,IAEAG,YAAY,EAHd;EAKD;;EAED,SAASS,kBAAT,CAA6BjB,QAA7B,EAAuCkB,UAAvC,EAAmD;IACjD,OAAO,SAASC,aAAT,GAA0B;MAC/B,IAAIN,IAAI,GAAGK,UAAU,EAArB;;MACA,IAAI,CAACL,IAAL,EAAW;QACT;MACD;;MAED,IAAI,CAACd,aAAa,CAACC,QAAD,CAAlB,EAA8B;QAC5B,OAAOa,IAAP;MACD;;MAED,IAAIO,KAAK,GAAGD,aAAa,EAAzB;;MACA,IAAI,CAACC,KAAL,EAAY;QACV,MAAM,IAAItB,KAAJ,CAAU,qBAAV,CAAN;MACD;;MACD,OAAO;QACLe,IAAI,EAAEA,IADD;QAELQ,WAAW,EAAErB,QAAQ,CAACsB,WAAT,EAFR;QAGLF,KAAK,EAAEA;MAHF,CAAP;IAKD,CAnBD;EAoBD;;EAED,IAAIG,QAAQ,GAAGN,kBAAkB,CAAC,KAAD,EAAQD,SAAR,CAAjC;EACA,IAAID,eAAe,GAAGE,kBAAkB,CAAC,IAAD,EAAOM,QAAP,CAAxC;EAEA,IAAId,IAAI,GAAGM,eAAe,EAA1B;;EACA,IAAI,CAACN,IAAD,IAASf,OAAO,EAApB,EAAwB;IACtB,MAAM,IAAII,KAAJ,CAAU,cAAV,CAAN;EACD;;EACD,OAAOW,IAAP;AACD,CAlID"},"metadata":{},"sourceType":"script"}