{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpdateCommandModule = void 0;\n\nconst schematics_1 = require(\"@angular-devkit/schematics\");\n\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs_1 = require(\"fs\");\n\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\n\nconst npm_pick_manifest_1 = __importDefault(require(\"npm-pick-manifest\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst path_1 = require(\"path\");\n\nconst semver = __importStar(require(\"semver\"));\n\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\n\nconst command_module_1 = require(\"../../command-builder/command-module\");\n\nconst schematic_engine_host_1 = require(\"../../command-builder/utilities/schematic-engine-host\");\n\nconst schematic_workflow_1 = require(\"../../command-builder/utilities/schematic-workflow\");\n\nconst color_1 = require(\"../../utilities/color\");\n\nconst environment_options_1 = require(\"../../utilities/environment-options\");\n\nconst error_1 = require(\"../../utilities/error\");\n\nconst log_file_1 = require(\"../../utilities/log-file\");\n\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\n\nconst package_tree_1 = require(\"../../utilities/package-tree\");\n\nconst version_1 = require(\"../../utilities/version\");\n\nconst ANGULAR_PACKAGES_REGEXP = /^@(?:angular|nguniversal)\\//;\nconst UPDATE_SCHEMATIC_COLLECTION = path.join(__dirname, 'schematic/collection.json');\n\nclass UpdateCommandModule extends command_module_1.CommandModule {\n  constructor() {\n    super(...arguments);\n    this.scope = command_module_1.CommandScope.In;\n    this.shouldReportAnalytics = false;\n    this.command = 'update [packages..]';\n    this.describe = 'Updates your workspace and its dependencies. See https://update.angular.io/.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n  }\n\n  builder(localYargs) {\n    return localYargs.positional('packages', {\n      description: 'The names of package(s) to update.',\n      type: 'string',\n      array: true\n    }).option('force', {\n      description: 'Ignore peer dependency version mismatches.',\n      type: 'boolean',\n      default: false\n    }).option('next', {\n      description: 'Use the prerelease version, including beta and RCs.',\n      type: 'boolean',\n      default: false\n    }).option('migrate-only', {\n      description: 'Only perform a migration, do not update the installed version.',\n      type: 'boolean'\n    }).option('name', {\n      description: 'The name of the migration to run. ' + `Only available with a single package being updated, and only with 'migrate-only' option.`,\n      type: 'string',\n      implies: ['migrate-only'],\n      conflicts: ['to', 'from']\n    }).option('from', {\n      description: 'Version from which to migrate from. ' + `Only available with a single package being updated, and only with 'migrate-only'.`,\n      type: 'string',\n      implies: ['to', 'migrate-only'],\n      conflicts: ['name']\n    }).option('to', {\n      describe: 'Version up to which to apply migrations. Only available with a single package being updated, ' + `and only with 'migrate-only' option. Requires 'from' to be specified. Default to the installed version detected.`,\n      type: 'string',\n      implies: ['from', 'migrate-only'],\n      conflicts: ['name']\n    }).option('allow-dirty', {\n      describe: 'Whether to allow updating when the repository contains modified or untracked files.',\n      type: 'boolean',\n      default: false\n    }).option('verbose', {\n      describe: 'Display additional details about internal operations during execution.',\n      type: 'boolean',\n      default: false\n    }).option('create-commits', {\n      describe: 'Create source control commits for updates and migrations.',\n      type: 'boolean',\n      alias: ['C'],\n      default: false\n    }).check(({\n      packages,\n      'allow-dirty': allowDirty,\n      'migrate-only': migrateOnly\n    }) => {\n      const {\n        logger\n      } = this.context; // This allows the user to easily reset any changes from the update.\n\n      if ((packages === null || packages === void 0 ? void 0 : packages.length) && !this.checkCleanGit()) {\n        if (allowDirty) {\n          logger.warn('Repository is not clean. Update changes will be mixed with pre-existing changes.');\n        } else {\n          throw new command_module_1.CommandModuleError('Repository is not clean. Please commit or stash any changes before updating.');\n        }\n      }\n\n      if (migrateOnly) {\n        if ((packages === null || packages === void 0 ? void 0 : packages.length) !== 1) {\n          throw new command_module_1.CommandModuleError(`A single package must be specified when using the 'migrate-only' option.`);\n        }\n      }\n\n      return true;\n    }).strict();\n  }\n\n  run(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n\n      const {\n        logger,\n        packageManager\n      } = _this.context;\n      packageManager.ensureCompatibility(); // Check if the current installed CLI version is older than the latest compatible version.\n      // Skip when running `ng update` without a package name as this will not trigger an actual update.\n\n      if (!environment_options_1.disableVersionCheck && ((_a = options.packages) === null || _a === void 0 ? void 0 : _a.length)) {\n        const cliVersionToInstall = yield _this.checkCLIVersion(options.packages, options.verbose, options.next);\n\n        if (cliVersionToInstall) {\n          logger.warn('The installed Angular CLI version is outdated.\\n' + `Installing a temporary Angular CLI versioned ${cliVersionToInstall} to perform the update.`);\n          return _this.runTempBinary(`@angular/cli@${cliVersionToInstall}`, process.argv.slice(2));\n        }\n      }\n\n      const packages = [];\n\n      for (const request of (_b = options.packages) !== null && _b !== void 0 ? _b : []) {\n        try {\n          const packageIdentifier = (0, npm_package_arg_1.default)(request); // only registry identifiers are supported\n\n          if (!packageIdentifier.registry) {\n            logger.error(`Package '${request}' is not a registry package identifer.`);\n            return 1;\n          }\n\n          if (packages.some(v => v.name === packageIdentifier.name)) {\n            logger.error(`Duplicate package '${packageIdentifier.name}' specified.`);\n            return 1;\n          }\n\n          if (options.migrateOnly && packageIdentifier.rawSpec) {\n            logger.warn('Package specifier has no effect when using \"migrate-only\" option.');\n          } // If next option is used and no specifier supplied, use next tag\n\n\n          if (options.next && !packageIdentifier.rawSpec) {\n            packageIdentifier.fetchSpec = 'next';\n          }\n\n          packages.push(packageIdentifier);\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(e.message);\n          return 1;\n        }\n      }\n\n      logger.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n      logger.info('Collecting installed dependencies...');\n      const rootDependencies = yield (0, package_tree_1.getProjectDependencies)(_this.context.root);\n      logger.info(`Found ${rootDependencies.size} dependencies.`);\n      const workflow = new tools_1.NodeWorkflow(_this.context.root, {\n        packageManager: packageManager.name,\n        packageManagerForce: _this.packageManagerForce(options.verbose),\n        // __dirname -> favor @schematics/update from this package\n        // Otherwise, use packages from the active workspace (migrations)\n        resolvePaths: [__dirname, _this.context.root],\n        schemaValidation: true,\n        engineHostCreator: options => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths)\n      });\n\n      if (packages.length === 0) {\n        // Show status\n        const {\n          success\n        } = yield _this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n          force: options.force,\n          next: options.next,\n          verbose: options.verbose,\n          packageManager: packageManager.name,\n          packages: []\n        });\n        return success ? 0 : 1;\n      }\n\n      return options.migrateOnly ? _this.migrateOnly(workflow, ((_c = options.packages) !== null && _c !== void 0 ? _c : [])[0], rootDependencies, options) : _this.updatePackagesAndMigrate(workflow, rootDependencies, options, packages);\n    })();\n  }\n\n  executeSchematic(workflow, collection, schematic, options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this2.context;\n      const workflowSubscription = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger); // TODO: Allow passing a schematic instance directly\n\n      try {\n        yield workflow.execute({\n          collection,\n          schematic,\n          options,\n          logger\n        }).toPromise();\n        return {\n          success: !workflowSubscription.error,\n          files: workflowSubscription.files\n        };\n      } catch (e) {\n        if (e instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n          logger.error(`${color_1.colors.symbols.cross} Migration failed. See above for further details.\\n`);\n        } else {\n          (0, error_1.assertIsError)(e);\n          const logPath = (0, log_file_1.writeErrorToLogFile)(e);\n          logger.fatal(`${color_1.colors.symbols.cross} Migration failed: ${e.message}\\n` + `  See \"${logPath}\" for further details.\\n`);\n        }\n\n        return {\n          success: false,\n          files: workflowSubscription.files\n        };\n      } finally {\n        workflowSubscription.unsubscribe();\n      }\n    })();\n  }\n  /**\n   * @return Whether or not the migration was performed successfully.\n   */\n\n\n  executeMigration(workflow, packageName, collectionPath, migrationName, commit) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this3.context;\n      const collection = workflow.engine.createCollection(collectionPath);\n      const name = collection.listSchematicNames().find(name => name === migrationName);\n\n      if (!name) {\n        logger.error(`Cannot find migration '${migrationName}' in '${packageName}'.`);\n        return 1;\n      }\n\n      logger.info(color_1.colors.cyan(`** Executing '${migrationName}' of package '${packageName}' **\\n`));\n      const schematic = workflow.engine.createSchematic(name, collection);\n      return _this3.executePackageMigrations(workflow, [schematic.description], packageName, commit);\n    })();\n  }\n  /**\n   * @return Whether or not the migrations were performed successfully.\n   */\n\n\n  executeMigrations(workflow, packageName, collectionPath, from, to, commit) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const collection = workflow.engine.createCollection(collectionPath);\n      const migrationRange = new semver.Range('>' + (semver.prerelease(from) ? from.split('-')[0] + '-0' : from) + ' <=' + to.split('-')[0]);\n      const migrations = [];\n\n      for (const name of collection.listSchematicNames()) {\n        const schematic = workflow.engine.createSchematic(name, collection);\n        const description = schematic.description;\n        description.version = coerceVersionNumber(description.version);\n\n        if (!description.version) {\n          continue;\n        }\n\n        if (semver.satisfies(description.version, migrationRange, {\n          includePrerelease: true\n        })) {\n          migrations.push(description);\n        }\n      }\n\n      if (migrations.length === 0) {\n        return 0;\n      }\n\n      migrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n\n      _this4.context.logger.info(color_1.colors.cyan(`** Executing migrations of package '${packageName}' **\\n`));\n\n      return _this4.executePackageMigrations(workflow, migrations, packageName, commit);\n    })();\n  }\n\n  executePackageMigrations(workflow, migrations, packageName, commit = false) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this5.context;\n\n      for (const migration of migrations) {\n        const [title, ...description] = migration.description.split('. ');\n        logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) + ' ' + color_1.colors.bold(title.endsWith('.') ? title : title + '.'));\n\n        if (description.length) {\n          logger.info('  ' + description.join('.\\n  '));\n        }\n\n        const result = yield _this5.executeSchematic(workflow, migration.collection.name, migration.name);\n\n        if (!result.success) {\n          return 1;\n        }\n\n        logger.info('  Migration completed.'); // Commit migration\n\n        if (commit) {\n          const commitPrefix = `${packageName} migration - ${migration.name}`;\n          const commitMessage = migration.description ? `${commitPrefix}\\n\\n${migration.description}` : commitPrefix;\n\n          const committed = _this5.commit(commitMessage);\n\n          if (!committed) {\n            // Failed to commit, something went wrong. Abort the update.\n            return 1;\n          }\n        }\n\n        logger.info(''); // Extra trailing newline.\n      }\n\n      return 0;\n    })();\n  }\n\n  migrateOnly(workflow, packageName, rootDependencies, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this6.context;\n      const packageDependency = rootDependencies.get(packageName);\n      let packagePath = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.path;\n      let packageNode = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.package;\n\n      if (packageDependency && !packageNode) {\n        logger.error('Package found in package.json but is not installed.');\n        return 1;\n      } else if (!packageDependency) {\n        // Allow running migrations on transitively installed dependencies\n        // There can technically be nested multiple versions\n        // TODO: If multiple, this should find all versions and ask which one to use\n        const packageJson = (0, package_tree_1.findPackageJson)(_this6.context.root, packageName);\n\n        if (packageJson) {\n          packagePath = path.dirname(packageJson);\n          packageNode = yield (0, package_tree_1.readPackageJson)(packageJson);\n        }\n      }\n\n      if (!packageNode || !packagePath) {\n        logger.error('Package is not installed.');\n        return 1;\n      }\n\n      const updateMetadata = packageNode['ng-update'];\n      let migrations = updateMetadata === null || updateMetadata === void 0 ? void 0 : updateMetadata.migrations;\n\n      if (migrations === undefined) {\n        logger.error('Package does not provide migrations.');\n        return 1;\n      } else if (typeof migrations !== 'string') {\n        logger.error('Package contains a malformed migrations field.');\n        return 1;\n      } else if (path.posix.isAbsolute(migrations) || path.win32.isAbsolute(migrations)) {\n        logger.error('Package contains an invalid migrations field. Absolute paths are not permitted.');\n        return 1;\n      } // Normalize slashes\n\n\n      migrations = migrations.replace(/\\\\/g, '/');\n\n      if (migrations.startsWith('../')) {\n        logger.error('Package contains an invalid migrations field. Paths outside the package root are not permitted.');\n        return 1;\n      } // Check if it is a package-local location\n\n\n      const localMigrations = path.join(packagePath, migrations);\n\n      if ((0, fs_1.existsSync)(localMigrations)) {\n        migrations = localMigrations;\n      } else {\n        // Try to resolve from package location.\n        // This avoids issues with package hoisting.\n        try {\n          migrations = require.resolve(migrations, {\n            paths: [packagePath]\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n\n          if (e.code === 'MODULE_NOT_FOUND') {\n            logger.error('Migrations for package were not found.');\n          } else {\n            logger.error(`Unable to resolve migrations for package.  [${e.message}]`);\n          }\n\n          return 1;\n        }\n      }\n\n      if (options.name) {\n        return _this6.executeMigration(workflow, packageName, migrations, options.name, options.createCommits);\n      }\n\n      const from = coerceVersionNumber(options.from);\n\n      if (!from) {\n        logger.error(`\"from\" value [${options.from}] is not a valid version.`);\n        return 1;\n      }\n\n      return _this6.executeMigrations(workflow, packageName, migrations, from, options.to || packageNode.version, options.createCommits);\n    })();\n  } // eslint-disable-next-line max-lines-per-function\n\n\n  updatePackagesAndMigrate(workflow, rootDependencies, options, packages) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        logger\n      } = _this7.context;\n\n      const logVerbose = message => {\n        if (options.verbose) {\n          logger.info(message);\n        }\n      };\n\n      const requests = []; // Validate packages actually are part of the workspace\n\n      for (const pkg of packages) {\n        const node = rootDependencies.get(pkg.name);\n\n        if (!(node === null || node === void 0 ? void 0 : node.package)) {\n          logger.error(`Package '${pkg.name}' is not a dependency.`);\n          return 1;\n        } // If a specific version is requested and matches the installed version, skip.\n\n\n        if (pkg.type === 'version' && node.package.version === pkg.fetchSpec) {\n          logger.info(`Package '${pkg.name}' is already at '${pkg.fetchSpec}'.`);\n          continue;\n        }\n\n        requests.push({\n          identifier: pkg,\n          node\n        });\n      }\n\n      if (requests.length === 0) {\n        return 0;\n      }\n\n      logger.info('Fetching dependency metadata from registry...');\n      const packagesToUpdate = [];\n\n      for (const {\n        identifier: requestIdentifier,\n        node\n      } of requests) {\n        const packageName = requestIdentifier.name;\n        let metadata;\n\n        try {\n          // Metadata requests are internally cached; multiple requests for same name\n          // does not result in additional network traffic\n          metadata = yield (0, package_metadata_1.fetchPackageMetadata)(packageName, logger, {\n            verbose: options.verbose\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(`Error fetching metadata for '${packageName}': ` + e.message);\n          return 1;\n        } // Try to find a package version based on the user requested package specifier\n        // registry specifier types are either version, range, or tag\n\n\n        let manifest;\n\n        if (requestIdentifier.type === 'version' || requestIdentifier.type === 'range' || requestIdentifier.type === 'tag') {\n          try {\n            manifest = (0, npm_pick_manifest_1.default)(metadata, requestIdentifier.fetchSpec);\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n\n            if (e.code === 'ETARGET') {\n              // If not found and next was used and user did not provide a specifier, try latest.\n              // Package may not have a next tag.\n              if (requestIdentifier.type === 'tag' && requestIdentifier.fetchSpec === 'next' && !requestIdentifier.rawSpec) {\n                try {\n                  manifest = (0, npm_pick_manifest_1.default)(metadata, 'latest');\n                } catch (e) {\n                  (0, error_1.assertIsError)(e);\n\n                  if (e.code !== 'ETARGET' && e.code !== 'ENOVERSIONS') {\n                    throw e;\n                  }\n                }\n              }\n            } else if (e.code !== 'ENOVERSIONS') {\n              throw e;\n            }\n          }\n        }\n\n        if (!manifest) {\n          logger.error(`Package specified by '${requestIdentifier.raw}' does not exist within the registry.`);\n          return 1;\n        }\n\n        if (manifest.version === ((_a = node.package) === null || _a === void 0 ? void 0 : _a.version)) {\n          logger.info(`Package '${packageName}' is already up to date.`);\n          continue;\n        }\n\n        if (node.package && ANGULAR_PACKAGES_REGEXP.test(node.package.name)) {\n          const {\n            name,\n            version\n          } = node.package;\n          const toBeInstalledMajorVersion = +manifest.version.split('.')[0];\n          const currentMajorVersion = +version.split('.')[0];\n\n          if (toBeInstalledMajorVersion - currentMajorVersion > 1) {\n            // Only allow updating a single version at a time.\n            if (currentMajorVersion < 6) {\n              // Before version 6, the major versions were not always sequential.\n              // Example @angular/core skipped version 3, @angular/cli skipped versions 2-5.\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `For more information about the update process, see https://update.angular.io/.`);\n            } else {\n              const nextMajorVersionFromCurrent = currentMajorVersion + 1;\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `Run 'ng update ${name}@${nextMajorVersionFromCurrent}' in your workspace directory ` + `to update to latest '${nextMajorVersionFromCurrent}.x' version of '${name}'.\\n\\n` + `For more information about the update process, see https://update.angular.io/?v=${currentMajorVersion}.0-${nextMajorVersionFromCurrent}.0`);\n            }\n\n            return 1;\n          }\n        }\n\n        packagesToUpdate.push(requestIdentifier.toString());\n      }\n\n      if (packagesToUpdate.length === 0) {\n        return 0;\n      }\n\n      const {\n        success\n      } = yield _this7.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n        verbose: options.verbose,\n        force: options.force,\n        next: options.next,\n        packageManager: _this7.context.packageManager.name,\n        packages: packagesToUpdate\n      });\n\n      if (success) {\n        try {\n          yield fs_1.promises.rm(path.join(_this7.context.root, 'node_modules'), {\n            force: true,\n            recursive: true,\n            maxRetries: 3\n          });\n        } catch {}\n\n        const installationSuccess = yield _this7.context.packageManager.installAll(_this7.packageManagerForce(options.verbose) ? ['--force'] : [], _this7.context.root);\n\n        if (!installationSuccess) {\n          return 1;\n        }\n      }\n\n      if (success && options.createCommits) {\n        if (!_this7.commit(`Angular CLI update for packages - ${packagesToUpdate.join(', ')}`)) {\n          return 1;\n        }\n      } // This is a temporary workaround to allow data to be passed back from the update schematic\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const migrations = global.externalMigrations;\n\n      if (success && migrations) {\n        for (const migration of migrations) {\n          // Resolve the package from the workspace root, as otherwise it will be resolved from the temp\n          // installed CLI version.\n          let packagePath;\n          logVerbose(`Resolving migration package '${migration.package}' from '${_this7.context.root}'...`);\n\n          try {\n            try {\n              packagePath = path.dirname( // This may fail if the `package.json` is not exported as an entry point\n              require.resolve(path.join(migration.package, 'package.json'), {\n                paths: [_this7.context.root]\n              }));\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n\n              if (e.code === 'MODULE_NOT_FOUND') {\n                // Fallback to trying to resolve the package's main entry point\n                packagePath = require.resolve(migration.package, {\n                  paths: [_this7.context.root]\n                });\n              } else {\n                throw e;\n              }\n            }\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n\n            if (e.code === 'MODULE_NOT_FOUND') {\n              logVerbose(e.toString());\n              logger.error(`Migrations for package (${migration.package}) were not found.` + ' The package could not be found in the workspace.');\n            } else {\n              logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n            }\n\n            return 1;\n          }\n\n          let migrations; // Check if it is a package-local location\n\n          const localMigrations = path.join(packagePath, migration.collection);\n\n          if ((0, fs_1.existsSync)(localMigrations)) {\n            migrations = localMigrations;\n          } else {\n            // Try to resolve from package location.\n            // This avoids issues with package hoisting.\n            try {\n              migrations = require.resolve(migration.collection, {\n                paths: [packagePath]\n              });\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n\n              if (e.code === 'MODULE_NOT_FOUND') {\n                logger.error(`Migrations for package (${migration.package}) were not found.`);\n              } else {\n                logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n              }\n\n              return 1;\n            }\n          }\n\n          const result = yield _this7.executeMigrations(workflow, migration.package, migrations, migration.from, migration.to, options.createCommits); // A non-zero value is a failure for the package's migrations\n\n          if (result !== 0) {\n            return result;\n          }\n        }\n      }\n\n      return success ? 0 : 1;\n    })();\n  }\n  /**\n   * @return Whether or not the commit was successful.\n   */\n\n\n  commit(message) {\n    const {\n      logger\n    } = this.context; // Check if a commit is needed.\n\n    let commitNeeded;\n\n    try {\n      commitNeeded = hasChangesToCommit();\n    } catch (err) {\n      logger.error(`  Failed to read Git tree:\\n${err.stderr}`);\n      return false;\n    }\n\n    if (!commitNeeded) {\n      logger.info('  No changes to commit after migration.');\n      return true;\n    } // Commit changes and abort on error.\n\n\n    try {\n      createCommit(message);\n    } catch (err) {\n      logger.error(`Failed to commit update (${message}):\\n${err.stderr}`);\n      return false;\n    } // Notify user of the commit.\n\n\n    const hash = findCurrentGitSha();\n    const shortMessage = message.split('\\n')[0];\n\n    if (hash) {\n      logger.info(`  Committed migration step (${getShortHash(hash)}): ${shortMessage}.`);\n    } else {\n      // Commit was successful, but reading the hash was not. Something weird happened,\n      // but nothing that would stop the update. Just log the weirdness and continue.\n      logger.info(`  Committed migration step: ${shortMessage}.`);\n      logger.warn('  Failed to look up hash of most recent commit, continuing anyways.');\n    }\n\n    return true;\n  }\n\n  checkCleanGit() {\n    try {\n      const topLevel = (0, child_process_1.execSync)('git rev-parse --show-toplevel', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      const result = (0, child_process_1.execSync)('git status --porcelain', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n\n      if (result.trim().length === 0) {\n        return true;\n      } // Only files inside the workspace root are relevant\n\n\n      for (const entry of result.split('\\n')) {\n        const relativeEntry = path.relative(path.resolve(this.context.root), path.resolve(topLevel.trim(), entry.slice(3).trim()));\n\n        if (!relativeEntry.startsWith('..') && !path.isAbsolute(relativeEntry)) {\n          return false;\n        }\n      }\n    } catch {}\n\n    return true;\n  }\n  /**\n   * Checks if the current installed CLI version is older or newer than a compatible version.\n   * @returns the version to install or null when there is no update to install.\n   */\n\n\n  checkCLIVersion(packagesToUpdate, verbose = false, next = false) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        version\n      } = yield (0, package_metadata_1.fetchPackageManifest)(`@angular/cli@${_this8.getCLIUpdateRunnerVersion(packagesToUpdate, next)}`, _this8.context.logger, {\n        verbose,\n        usingYarn: _this8.context.packageManager.name === workspace_schema_1.PackageManager.Yarn\n      });\n      return version_1.VERSION.full === version ? null : version;\n    })();\n  }\n\n  getCLIUpdateRunnerVersion(packagesToUpdate, next) {\n    var _a, _b;\n\n    if (next) {\n      return 'next';\n    }\n\n    const updatingAngularPackage = packagesToUpdate === null || packagesToUpdate === void 0 ? void 0 : packagesToUpdate.find(r => ANGULAR_PACKAGES_REGEXP.test(r));\n\n    if (updatingAngularPackage) {\n      // If we are updating any Angular package we can update the CLI to the target version because\n      // migrations for @angular/core@13 can be executed using Angular/cli@13.\n      // This is same behaviour as `npx @angular/cli@13 update @angular/core@13`.\n      // `@angular/cli@13` -> ['', 'angular/cli', '13']\n      // `@angular/cli` -> ['', 'angular/cli']\n      const tempVersion = coerceVersionNumber(updatingAngularPackage.split('@')[2]);\n      return (_b = (_a = semver.parse(tempVersion)) === null || _a === void 0 ? void 0 : _a.major) !== null && _b !== void 0 ? _b : 'latest';\n    } // When not updating an Angular package we cannot determine which schematic runtime the migration should to be executed in.\n    // Typically, we can assume that the `@angular/cli` was updated previously.\n    // Example: Angular official packages are typically updated prior to NGRX etc...\n    // Therefore, we only update to the latest patch version of the installed major version of the Angular CLI.\n    // This is important because we might end up in a scenario where locally Angular v12 is installed, updating NGRX from 11 to 12.\n    // We end up using Angular ClI v13 to run the migrations if we run the migrations using the CLI installed major version + 1 logic.\n\n\n    return version_1.VERSION.major;\n  }\n\n  runTempBinary(packageName, args = []) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        success,\n        tempNodeModules\n      } = yield _this9.context.packageManager.installTemp(packageName);\n\n      if (!success) {\n        return 1;\n      } // Remove version/tag etc... from package name\n      // Ex: @angular/cli@latest -> @angular/cli\n\n\n      const packageNameNoVersion = packageName.substring(0, packageName.lastIndexOf('@'));\n      const pkgLocation = (0, path_1.join)(tempNodeModules, packageNameNoVersion);\n      const packageJsonPath = (0, path_1.join)(pkgLocation, 'package.json'); // Get a binary location for this package\n\n      let binPath;\n\n      if ((0, fs_1.existsSync)(packageJsonPath)) {\n        const content = yield fs_1.promises.readFile(packageJsonPath, 'utf-8');\n\n        if (content) {\n          const {\n            bin = {}\n          } = JSON.parse(content);\n          const binKeys = Object.keys(bin);\n\n          if (binKeys.length) {\n            binPath = (0, path_1.resolve)(pkgLocation, bin[binKeys[0]]);\n          }\n        }\n      }\n\n      if (!binPath) {\n        throw new Error(`Cannot locate bin for temporary package: ${packageNameNoVersion}.`);\n      }\n\n      const {\n        status,\n        error\n      } = (0, child_process_1.spawnSync)(process.execPath, [binPath, ...args], {\n        stdio: 'inherit',\n        env: { ...process.env,\n          NG_DISABLE_VERSION_CHECK: 'true',\n          NG_CLI_ANALYTICS: 'false'\n        }\n      });\n\n      if (status === null && error) {\n        throw error;\n      }\n\n      return status !== null && status !== void 0 ? status : 0;\n    })();\n  }\n\n  packageManagerForce(verbose) {\n    // npm 7+ can fail due to it incorrectly resolving peer dependencies that have valid SemVer\n    // ranges during an update. Update will set correct versions of dependencies within the\n    // package.json file. The force option is set to workaround these errors.\n    // Example error:\n    // npm ERR! Conflicting peer dependency: @angular/compiler-cli@14.0.0-rc.0\n    // npm ERR! node_modules/@angular/compiler-cli\n    // npm ERR!   peer @angular/compiler-cli@\"^14.0.0 || ^14.0.0-rc\" from @angular-devkit/build-angular@14.0.0-rc.0\n    // npm ERR!   node_modules/@angular-devkit/build-angular\n    // npm ERR!     dev @angular-devkit/build-angular@\"~14.0.0-rc.0\" from the root project\n    if (this.context.packageManager.name === workspace_schema_1.PackageManager.Npm && this.context.packageManager.version && semver.gte(this.context.packageManager.version, '7.0.0')) {\n      if (verbose) {\n        this.context.logger.info('NPM 7+ detected -- enabling force option for package installation');\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.UpdateCommandModule = UpdateCommandModule;\n/**\n * @return Whether or not the working directory has Git changes to commit.\n */\n\nfunction hasChangesToCommit() {\n  // List all modified files not covered by .gitignore.\n  // If any files are returned, then there must be something to commit.\n  return (0, child_process_1.execSync)('git ls-files -m -d -o --exclude-standard').toString() !== '';\n}\n/**\n * Precondition: Must have pending changes to commit, they do not need to be staged.\n * Postcondition: The Git working tree is committed and the repo is clean.\n * @param message The commit message to use.\n */\n\n\nfunction createCommit(message) {\n  // Stage entire working tree for commit.\n  (0, child_process_1.execSync)('git add -A', {\n    encoding: 'utf8',\n    stdio: 'pipe'\n  }); // Commit with the message passed via stdin to avoid bash escaping issues.\n\n  (0, child_process_1.execSync)('git commit --no-verify -F -', {\n    encoding: 'utf8',\n    stdio: 'pipe',\n    input: message\n  });\n}\n/**\n * @return The Git SHA hash of the HEAD commit. Returns null if unable to retrieve the hash.\n */\n\n\nfunction findCurrentGitSha() {\n  try {\n    return (0, child_process_1.execSync)('git rev-parse HEAD', {\n      encoding: 'utf8',\n      stdio: 'pipe'\n    }).trim();\n  } catch {\n    return null;\n  }\n}\n\nfunction getShortHash(commitHash) {\n  return commitHash.slice(0, 9);\n}\n\nfunction coerceVersionNumber(version) {\n  var _a;\n\n  if (!version) {\n    return undefined;\n  }\n\n  if (!/^\\d{1,30}\\.\\d{1,30}\\.\\d{1,30}/.test(version)) {\n    const match = version.match(/^\\d{1,30}(\\.\\d{1,30})*/);\n\n    if (!match) {\n      return undefined;\n    }\n\n    if (!match[1]) {\n      version = version.substring(0, match[0].length) + '.0.0' + version.substring(match[0].length);\n    } else if (!match[2]) {\n      version = version.substring(0, match[0].length) + '.0' + version.substring(match[0].length);\n    } else {\n      return undefined;\n    }\n  }\n\n  return (_a = semver.valid(version)) !== null && _a !== void 0 ? _a : undefined;\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","UpdateCommandModule","schematics_1","require","tools_1","child_process_1","fs_1","npm_package_arg_1","npm_pick_manifest_1","path","path_1","semver","workspace_schema_1","command_module_1","schematic_engine_host_1","schematic_workflow_1","color_1","environment_options_1","error_1","log_file_1","package_metadata_1","package_tree_1","version_1","ANGULAR_PACKAGES_REGEXP","UPDATE_SCHEMATIC_COLLECTION","join","__dirname","CommandModule","constructor","arguments","scope","CommandScope","In","shouldReportAnalytics","command","describe","longDescriptionPath","builder","localYargs","positional","description","type","array","option","default","implies","conflicts","alias","check","packages","allowDirty","migrateOnly","logger","context","length","checkCleanGit","warn","CommandModuleError","strict","run","options","_a","_b","_c","packageManager","ensureCompatibility","disableVersionCheck","cliVersionToInstall","checkCLIVersion","verbose","next","runTempBinary","process","argv","slice","request","packageIdentifier","registry","error","some","name","rawSpec","fetchSpec","push","e","assertIsError","message","info","colors","grey","rootDependencies","getProjectDependencies","root","size","workflow","NodeWorkflow","packageManagerForce","resolvePaths","schemaValidation","engineHostCreator","SchematicEngineHost","success","executeSchematic","force","updatePackagesAndMigrate","collection","schematic","workflowSubscription","subscribeToWorkflow","execute","toPromise","files","UnsuccessfulWorkflowExecution","symbols","cross","logPath","writeErrorToLogFile","fatal","unsubscribe","executeMigration","packageName","collectionPath","migrationName","commit","engine","createCollection","listSchematicNames","find","cyan","createSchematic","executePackageMigrations","executeMigrations","from","to","migrationRange","Range","prerelease","split","migrations","version","coerceVersionNumber","satisfies","includePrerelease","sort","a","b","compare","localeCompare","migration","title","pointer","bold","endsWith","commitPrefix","commitMessage","committed","packageDependency","packagePath","packageNode","package","packageJson","findPackageJson","dirname","readPackageJson","updateMetadata","posix","isAbsolute","win32","replace","startsWith","localMigrations","existsSync","resolve","paths","code","createCommits","logVerbose","requests","pkg","node","identifier","packagesToUpdate","requestIdentifier","metadata","fetchPackageMetadata","manifest","raw","test","toBeInstalledMajorVersion","currentMajorVersion","nextMajorVersionFromCurrent","toString","promises","rm","recursive","maxRetries","installationSuccess","installAll","global","externalMigrations","commitNeeded","hasChangesToCommit","err","stderr","createCommit","hash","findCurrentGitSha","shortMessage","getShortHash","topLevel","execSync","encoding","stdio","trim","entry","relativeEntry","relative","fetchPackageManifest","getCLIUpdateRunnerVersion","usingYarn","PackageManager","Yarn","VERSION","full","updatingAngularPackage","r","tempVersion","parse","major","args","tempNodeModules","installTemp","packageNameNoVersion","substring","lastIndexOf","pkgLocation","packageJsonPath","binPath","content","readFile","bin","JSON","binKeys","keys","Error","status","spawnSync","execPath","env","NG_DISABLE_VERSION_CHECK","NG_CLI_ANALYTICS","Npm","gte","input","commitHash","match","valid"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular/cli/src/commands/update/cli.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdateCommandModule = void 0;\nconst schematics_1 = require(\"@angular-devkit/schematics\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\nconst npm_pick_manifest_1 = __importDefault(require(\"npm-pick-manifest\"));\nconst path = __importStar(require(\"path\"));\nconst path_1 = require(\"path\");\nconst semver = __importStar(require(\"semver\"));\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematic_engine_host_1 = require(\"../../command-builder/utilities/schematic-engine-host\");\nconst schematic_workflow_1 = require(\"../../command-builder/utilities/schematic-workflow\");\nconst color_1 = require(\"../../utilities/color\");\nconst environment_options_1 = require(\"../../utilities/environment-options\");\nconst error_1 = require(\"../../utilities/error\");\nconst log_file_1 = require(\"../../utilities/log-file\");\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\nconst package_tree_1 = require(\"../../utilities/package-tree\");\nconst version_1 = require(\"../../utilities/version\");\nconst ANGULAR_PACKAGES_REGEXP = /^@(?:angular|nguniversal)\\//;\nconst UPDATE_SCHEMATIC_COLLECTION = path.join(__dirname, 'schematic/collection.json');\nclass UpdateCommandModule extends command_module_1.CommandModule {\n    constructor() {\n        super(...arguments);\n        this.scope = command_module_1.CommandScope.In;\n        this.shouldReportAnalytics = false;\n        this.command = 'update [packages..]';\n        this.describe = 'Updates your workspace and its dependencies. See https://update.angular.io/.';\n        this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n    }\n    builder(localYargs) {\n        return localYargs\n            .positional('packages', {\n            description: 'The names of package(s) to update.',\n            type: 'string',\n            array: true,\n        })\n            .option('force', {\n            description: 'Ignore peer dependency version mismatches.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('next', {\n            description: 'Use the prerelease version, including beta and RCs.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('migrate-only', {\n            description: 'Only perform a migration, do not update the installed version.',\n            type: 'boolean',\n        })\n            .option('name', {\n            description: 'The name of the migration to run. ' +\n                `Only available with a single package being updated, and only with 'migrate-only' option.`,\n            type: 'string',\n            implies: ['migrate-only'],\n            conflicts: ['to', 'from'],\n        })\n            .option('from', {\n            description: 'Version from which to migrate from. ' +\n                `Only available with a single package being updated, and only with 'migrate-only'.`,\n            type: 'string',\n            implies: ['to', 'migrate-only'],\n            conflicts: ['name'],\n        })\n            .option('to', {\n            describe: 'Version up to which to apply migrations. Only available with a single package being updated, ' +\n                `and only with 'migrate-only' option. Requires 'from' to be specified. Default to the installed version detected.`,\n            type: 'string',\n            implies: ['from', 'migrate-only'],\n            conflicts: ['name'],\n        })\n            .option('allow-dirty', {\n            describe: 'Whether to allow updating when the repository contains modified or untracked files.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('verbose', {\n            describe: 'Display additional details about internal operations during execution.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('create-commits', {\n            describe: 'Create source control commits for updates and migrations.',\n            type: 'boolean',\n            alias: ['C'],\n            default: false,\n        })\n            .check(({ packages, 'allow-dirty': allowDirty, 'migrate-only': migrateOnly }) => {\n            const { logger } = this.context;\n            // This allows the user to easily reset any changes from the update.\n            if ((packages === null || packages === void 0 ? void 0 : packages.length) && !this.checkCleanGit()) {\n                if (allowDirty) {\n                    logger.warn('Repository is not clean. Update changes will be mixed with pre-existing changes.');\n                }\n                else {\n                    throw new command_module_1.CommandModuleError('Repository is not clean. Please commit or stash any changes before updating.');\n                }\n            }\n            if (migrateOnly) {\n                if ((packages === null || packages === void 0 ? void 0 : packages.length) !== 1) {\n                    throw new command_module_1.CommandModuleError(`A single package must be specified when using the 'migrate-only' option.`);\n                }\n            }\n            return true;\n        })\n            .strict();\n    }\n    async run(options) {\n        var _a, _b, _c;\n        const { logger, packageManager } = this.context;\n        packageManager.ensureCompatibility();\n        // Check if the current installed CLI version is older than the latest compatible version.\n        // Skip when running `ng update` without a package name as this will not trigger an actual update.\n        if (!environment_options_1.disableVersionCheck && ((_a = options.packages) === null || _a === void 0 ? void 0 : _a.length)) {\n            const cliVersionToInstall = await this.checkCLIVersion(options.packages, options.verbose, options.next);\n            if (cliVersionToInstall) {\n                logger.warn('The installed Angular CLI version is outdated.\\n' +\n                    `Installing a temporary Angular CLI versioned ${cliVersionToInstall} to perform the update.`);\n                return this.runTempBinary(`@angular/cli@${cliVersionToInstall}`, process.argv.slice(2));\n            }\n        }\n        const packages = [];\n        for (const request of (_b = options.packages) !== null && _b !== void 0 ? _b : []) {\n            try {\n                const packageIdentifier = (0, npm_package_arg_1.default)(request);\n                // only registry identifiers are supported\n                if (!packageIdentifier.registry) {\n                    logger.error(`Package '${request}' is not a registry package identifer.`);\n                    return 1;\n                }\n                if (packages.some((v) => v.name === packageIdentifier.name)) {\n                    logger.error(`Duplicate package '${packageIdentifier.name}' specified.`);\n                    return 1;\n                }\n                if (options.migrateOnly && packageIdentifier.rawSpec) {\n                    logger.warn('Package specifier has no effect when using \"migrate-only\" option.');\n                }\n                // If next option is used and no specifier supplied, use next tag\n                if (options.next && !packageIdentifier.rawSpec) {\n                    packageIdentifier.fetchSpec = 'next';\n                }\n                packages.push(packageIdentifier);\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                logger.error(e.message);\n                return 1;\n            }\n        }\n        logger.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n        logger.info('Collecting installed dependencies...');\n        const rootDependencies = await (0, package_tree_1.getProjectDependencies)(this.context.root);\n        logger.info(`Found ${rootDependencies.size} dependencies.`);\n        const workflow = new tools_1.NodeWorkflow(this.context.root, {\n            packageManager: packageManager.name,\n            packageManagerForce: this.packageManagerForce(options.verbose),\n            // __dirname -> favor @schematics/update from this package\n            // Otherwise, use packages from the active workspace (migrations)\n            resolvePaths: [__dirname, this.context.root],\n            schemaValidation: true,\n            engineHostCreator: (options) => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths),\n        });\n        if (packages.length === 0) {\n            // Show status\n            const { success } = await this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n                force: options.force,\n                next: options.next,\n                verbose: options.verbose,\n                packageManager: packageManager.name,\n                packages: [],\n            });\n            return success ? 0 : 1;\n        }\n        return options.migrateOnly\n            ? this.migrateOnly(workflow, ((_c = options.packages) !== null && _c !== void 0 ? _c : [])[0], rootDependencies, options)\n            : this.updatePackagesAndMigrate(workflow, rootDependencies, options, packages);\n    }\n    async executeSchematic(workflow, collection, schematic, options = {}) {\n        const { logger } = this.context;\n        const workflowSubscription = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger);\n        // TODO: Allow passing a schematic instance directly\n        try {\n            await workflow\n                .execute({\n                collection,\n                schematic,\n                options,\n                logger,\n            })\n                .toPromise();\n            return { success: !workflowSubscription.error, files: workflowSubscription.files };\n        }\n        catch (e) {\n            if (e instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n                logger.error(`${color_1.colors.symbols.cross} Migration failed. See above for further details.\\n`);\n            }\n            else {\n                (0, error_1.assertIsError)(e);\n                const logPath = (0, log_file_1.writeErrorToLogFile)(e);\n                logger.fatal(`${color_1.colors.symbols.cross} Migration failed: ${e.message}\\n` +\n                    `  See \"${logPath}\" for further details.\\n`);\n            }\n            return { success: false, files: workflowSubscription.files };\n        }\n        finally {\n            workflowSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @return Whether or not the migration was performed successfully.\n     */\n    async executeMigration(workflow, packageName, collectionPath, migrationName, commit) {\n        const { logger } = this.context;\n        const collection = workflow.engine.createCollection(collectionPath);\n        const name = collection.listSchematicNames().find((name) => name === migrationName);\n        if (!name) {\n            logger.error(`Cannot find migration '${migrationName}' in '${packageName}'.`);\n            return 1;\n        }\n        logger.info(color_1.colors.cyan(`** Executing '${migrationName}' of package '${packageName}' **\\n`));\n        const schematic = workflow.engine.createSchematic(name, collection);\n        return this.executePackageMigrations(workflow, [schematic.description], packageName, commit);\n    }\n    /**\n     * @return Whether or not the migrations were performed successfully.\n     */\n    async executeMigrations(workflow, packageName, collectionPath, from, to, commit) {\n        const collection = workflow.engine.createCollection(collectionPath);\n        const migrationRange = new semver.Range('>' + (semver.prerelease(from) ? from.split('-')[0] + '-0' : from) + ' <=' + to.split('-')[0]);\n        const migrations = [];\n        for (const name of collection.listSchematicNames()) {\n            const schematic = workflow.engine.createSchematic(name, collection);\n            const description = schematic.description;\n            description.version = coerceVersionNumber(description.version);\n            if (!description.version) {\n                continue;\n            }\n            if (semver.satisfies(description.version, migrationRange, { includePrerelease: true })) {\n                migrations.push(description);\n            }\n        }\n        if (migrations.length === 0) {\n            return 0;\n        }\n        migrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n        this.context.logger.info(color_1.colors.cyan(`** Executing migrations of package '${packageName}' **\\n`));\n        return this.executePackageMigrations(workflow, migrations, packageName, commit);\n    }\n    async executePackageMigrations(workflow, migrations, packageName, commit = false) {\n        const { logger } = this.context;\n        for (const migration of migrations) {\n            const [title, ...description] = migration.description.split('. ');\n            logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) +\n                ' ' +\n                color_1.colors.bold(title.endsWith('.') ? title : title + '.'));\n            if (description.length) {\n                logger.info('  ' + description.join('.\\n  '));\n            }\n            const result = await this.executeSchematic(workflow, migration.collection.name, migration.name);\n            if (!result.success) {\n                return 1;\n            }\n            logger.info('  Migration completed.');\n            // Commit migration\n            if (commit) {\n                const commitPrefix = `${packageName} migration - ${migration.name}`;\n                const commitMessage = migration.description\n                    ? `${commitPrefix}\\n\\n${migration.description}`\n                    : commitPrefix;\n                const committed = this.commit(commitMessage);\n                if (!committed) {\n                    // Failed to commit, something went wrong. Abort the update.\n                    return 1;\n                }\n            }\n            logger.info(''); // Extra trailing newline.\n        }\n        return 0;\n    }\n    async migrateOnly(workflow, packageName, rootDependencies, options) {\n        const { logger } = this.context;\n        const packageDependency = rootDependencies.get(packageName);\n        let packagePath = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.path;\n        let packageNode = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.package;\n        if (packageDependency && !packageNode) {\n            logger.error('Package found in package.json but is not installed.');\n            return 1;\n        }\n        else if (!packageDependency) {\n            // Allow running migrations on transitively installed dependencies\n            // There can technically be nested multiple versions\n            // TODO: If multiple, this should find all versions and ask which one to use\n            const packageJson = (0, package_tree_1.findPackageJson)(this.context.root, packageName);\n            if (packageJson) {\n                packagePath = path.dirname(packageJson);\n                packageNode = await (0, package_tree_1.readPackageJson)(packageJson);\n            }\n        }\n        if (!packageNode || !packagePath) {\n            logger.error('Package is not installed.');\n            return 1;\n        }\n        const updateMetadata = packageNode['ng-update'];\n        let migrations = updateMetadata === null || updateMetadata === void 0 ? void 0 : updateMetadata.migrations;\n        if (migrations === undefined) {\n            logger.error('Package does not provide migrations.');\n            return 1;\n        }\n        else if (typeof migrations !== 'string') {\n            logger.error('Package contains a malformed migrations field.');\n            return 1;\n        }\n        else if (path.posix.isAbsolute(migrations) || path.win32.isAbsolute(migrations)) {\n            logger.error('Package contains an invalid migrations field. Absolute paths are not permitted.');\n            return 1;\n        }\n        // Normalize slashes\n        migrations = migrations.replace(/\\\\/g, '/');\n        if (migrations.startsWith('../')) {\n            logger.error('Package contains an invalid migrations field. Paths outside the package root are not permitted.');\n            return 1;\n        }\n        // Check if it is a package-local location\n        const localMigrations = path.join(packagePath, migrations);\n        if ((0, fs_1.existsSync)(localMigrations)) {\n            migrations = localMigrations;\n        }\n        else {\n            // Try to resolve from package location.\n            // This avoids issues with package hoisting.\n            try {\n                migrations = require.resolve(migrations, { paths: [packagePath] });\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                if (e.code === 'MODULE_NOT_FOUND') {\n                    logger.error('Migrations for package were not found.');\n                }\n                else {\n                    logger.error(`Unable to resolve migrations for package.  [${e.message}]`);\n                }\n                return 1;\n            }\n        }\n        if (options.name) {\n            return this.executeMigration(workflow, packageName, migrations, options.name, options.createCommits);\n        }\n        const from = coerceVersionNumber(options.from);\n        if (!from) {\n            logger.error(`\"from\" value [${options.from}] is not a valid version.`);\n            return 1;\n        }\n        return this.executeMigrations(workflow, packageName, migrations, from, options.to || packageNode.version, options.createCommits);\n    }\n    // eslint-disable-next-line max-lines-per-function\n    async updatePackagesAndMigrate(workflow, rootDependencies, options, packages) {\n        var _a;\n        const { logger } = this.context;\n        const logVerbose = (message) => {\n            if (options.verbose) {\n                logger.info(message);\n            }\n        };\n        const requests = [];\n        // Validate packages actually are part of the workspace\n        for (const pkg of packages) {\n            const node = rootDependencies.get(pkg.name);\n            if (!(node === null || node === void 0 ? void 0 : node.package)) {\n                logger.error(`Package '${pkg.name}' is not a dependency.`);\n                return 1;\n            }\n            // If a specific version is requested and matches the installed version, skip.\n            if (pkg.type === 'version' && node.package.version === pkg.fetchSpec) {\n                logger.info(`Package '${pkg.name}' is already at '${pkg.fetchSpec}'.`);\n                continue;\n            }\n            requests.push({ identifier: pkg, node });\n        }\n        if (requests.length === 0) {\n            return 0;\n        }\n        logger.info('Fetching dependency metadata from registry...');\n        const packagesToUpdate = [];\n        for (const { identifier: requestIdentifier, node } of requests) {\n            const packageName = requestIdentifier.name;\n            let metadata;\n            try {\n                // Metadata requests are internally cached; multiple requests for same name\n                // does not result in additional network traffic\n                metadata = await (0, package_metadata_1.fetchPackageMetadata)(packageName, logger, {\n                    verbose: options.verbose,\n                });\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                logger.error(`Error fetching metadata for '${packageName}': ` + e.message);\n                return 1;\n            }\n            // Try to find a package version based on the user requested package specifier\n            // registry specifier types are either version, range, or tag\n            let manifest;\n            if (requestIdentifier.type === 'version' ||\n                requestIdentifier.type === 'range' ||\n                requestIdentifier.type === 'tag') {\n                try {\n                    manifest = (0, npm_pick_manifest_1.default)(metadata, requestIdentifier.fetchSpec);\n                }\n                catch (e) {\n                    (0, error_1.assertIsError)(e);\n                    if (e.code === 'ETARGET') {\n                        // If not found and next was used and user did not provide a specifier, try latest.\n                        // Package may not have a next tag.\n                        if (requestIdentifier.type === 'tag' &&\n                            requestIdentifier.fetchSpec === 'next' &&\n                            !requestIdentifier.rawSpec) {\n                            try {\n                                manifest = (0, npm_pick_manifest_1.default)(metadata, 'latest');\n                            }\n                            catch (e) {\n                                (0, error_1.assertIsError)(e);\n                                if (e.code !== 'ETARGET' && e.code !== 'ENOVERSIONS') {\n                                    throw e;\n                                }\n                            }\n                        }\n                    }\n                    else if (e.code !== 'ENOVERSIONS') {\n                        throw e;\n                    }\n                }\n            }\n            if (!manifest) {\n                logger.error(`Package specified by '${requestIdentifier.raw}' does not exist within the registry.`);\n                return 1;\n            }\n            if (manifest.version === ((_a = node.package) === null || _a === void 0 ? void 0 : _a.version)) {\n                logger.info(`Package '${packageName}' is already up to date.`);\n                continue;\n            }\n            if (node.package && ANGULAR_PACKAGES_REGEXP.test(node.package.name)) {\n                const { name, version } = node.package;\n                const toBeInstalledMajorVersion = +manifest.version.split('.')[0];\n                const currentMajorVersion = +version.split('.')[0];\n                if (toBeInstalledMajorVersion - currentMajorVersion > 1) {\n                    // Only allow updating a single version at a time.\n                    if (currentMajorVersion < 6) {\n                        // Before version 6, the major versions were not always sequential.\n                        // Example @angular/core skipped version 3, @angular/cli skipped versions 2-5.\n                        logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` +\n                            `For more information about the update process, see https://update.angular.io/.`);\n                    }\n                    else {\n                        const nextMajorVersionFromCurrent = currentMajorVersion + 1;\n                        logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` +\n                            `Run 'ng update ${name}@${nextMajorVersionFromCurrent}' in your workspace directory ` +\n                            `to update to latest '${nextMajorVersionFromCurrent}.x' version of '${name}'.\\n\\n` +\n                            `For more information about the update process, see https://update.angular.io/?v=${currentMajorVersion}.0-${nextMajorVersionFromCurrent}.0`);\n                    }\n                    return 1;\n                }\n            }\n            packagesToUpdate.push(requestIdentifier.toString());\n        }\n        if (packagesToUpdate.length === 0) {\n            return 0;\n        }\n        const { success } = await this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n            verbose: options.verbose,\n            force: options.force,\n            next: options.next,\n            packageManager: this.context.packageManager.name,\n            packages: packagesToUpdate,\n        });\n        if (success) {\n            try {\n                await fs_1.promises.rm(path.join(this.context.root, 'node_modules'), {\n                    force: true,\n                    recursive: true,\n                    maxRetries: 3,\n                });\n            }\n            catch { }\n            const installationSuccess = await this.context.packageManager.installAll(this.packageManagerForce(options.verbose) ? ['--force'] : [], this.context.root);\n            if (!installationSuccess) {\n                return 1;\n            }\n        }\n        if (success && options.createCommits) {\n            if (!this.commit(`Angular CLI update for packages - ${packagesToUpdate.join(', ')}`)) {\n                return 1;\n            }\n        }\n        // This is a temporary workaround to allow data to be passed back from the update schematic\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const migrations = global.externalMigrations;\n        if (success && migrations) {\n            for (const migration of migrations) {\n                // Resolve the package from the workspace root, as otherwise it will be resolved from the temp\n                // installed CLI version.\n                let packagePath;\n                logVerbose(`Resolving migration package '${migration.package}' from '${this.context.root}'...`);\n                try {\n                    try {\n                        packagePath = path.dirname(\n                        // This may fail if the `package.json` is not exported as an entry point\n                        require.resolve(path.join(migration.package, 'package.json'), {\n                            paths: [this.context.root],\n                        }));\n                    }\n                    catch (e) {\n                        (0, error_1.assertIsError)(e);\n                        if (e.code === 'MODULE_NOT_FOUND') {\n                            // Fallback to trying to resolve the package's main entry point\n                            packagePath = require.resolve(migration.package, { paths: [this.context.root] });\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                }\n                catch (e) {\n                    (0, error_1.assertIsError)(e);\n                    if (e.code === 'MODULE_NOT_FOUND') {\n                        logVerbose(e.toString());\n                        logger.error(`Migrations for package (${migration.package}) were not found.` +\n                            ' The package could not be found in the workspace.');\n                    }\n                    else {\n                        logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n                    }\n                    return 1;\n                }\n                let migrations;\n                // Check if it is a package-local location\n                const localMigrations = path.join(packagePath, migration.collection);\n                if ((0, fs_1.existsSync)(localMigrations)) {\n                    migrations = localMigrations;\n                }\n                else {\n                    // Try to resolve from package location.\n                    // This avoids issues with package hoisting.\n                    try {\n                        migrations = require.resolve(migration.collection, { paths: [packagePath] });\n                    }\n                    catch (e) {\n                        (0, error_1.assertIsError)(e);\n                        if (e.code === 'MODULE_NOT_FOUND') {\n                            logger.error(`Migrations for package (${migration.package}) were not found.`);\n                        }\n                        else {\n                            logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n                        }\n                        return 1;\n                    }\n                }\n                const result = await this.executeMigrations(workflow, migration.package, migrations, migration.from, migration.to, options.createCommits);\n                // A non-zero value is a failure for the package's migrations\n                if (result !== 0) {\n                    return result;\n                }\n            }\n        }\n        return success ? 0 : 1;\n    }\n    /**\n     * @return Whether or not the commit was successful.\n     */\n    commit(message) {\n        const { logger } = this.context;\n        // Check if a commit is needed.\n        let commitNeeded;\n        try {\n            commitNeeded = hasChangesToCommit();\n        }\n        catch (err) {\n            logger.error(`  Failed to read Git tree:\\n${err.stderr}`);\n            return false;\n        }\n        if (!commitNeeded) {\n            logger.info('  No changes to commit after migration.');\n            return true;\n        }\n        // Commit changes and abort on error.\n        try {\n            createCommit(message);\n        }\n        catch (err) {\n            logger.error(`Failed to commit update (${message}):\\n${err.stderr}`);\n            return false;\n        }\n        // Notify user of the commit.\n        const hash = findCurrentGitSha();\n        const shortMessage = message.split('\\n')[0];\n        if (hash) {\n            logger.info(`  Committed migration step (${getShortHash(hash)}): ${shortMessage}.`);\n        }\n        else {\n            // Commit was successful, but reading the hash was not. Something weird happened,\n            // but nothing that would stop the update. Just log the weirdness and continue.\n            logger.info(`  Committed migration step: ${shortMessage}.`);\n            logger.warn('  Failed to look up hash of most recent commit, continuing anyways.');\n        }\n        return true;\n    }\n    checkCleanGit() {\n        try {\n            const topLevel = (0, child_process_1.execSync)('git rev-parse --show-toplevel', {\n                encoding: 'utf8',\n                stdio: 'pipe',\n            });\n            const result = (0, child_process_1.execSync)('git status --porcelain', { encoding: 'utf8', stdio: 'pipe' });\n            if (result.trim().length === 0) {\n                return true;\n            }\n            // Only files inside the workspace root are relevant\n            for (const entry of result.split('\\n')) {\n                const relativeEntry = path.relative(path.resolve(this.context.root), path.resolve(topLevel.trim(), entry.slice(3).trim()));\n                if (!relativeEntry.startsWith('..') && !path.isAbsolute(relativeEntry)) {\n                    return false;\n                }\n            }\n        }\n        catch { }\n        return true;\n    }\n    /**\n     * Checks if the current installed CLI version is older or newer than a compatible version.\n     * @returns the version to install or null when there is no update to install.\n     */\n    async checkCLIVersion(packagesToUpdate, verbose = false, next = false) {\n        const { version } = await (0, package_metadata_1.fetchPackageManifest)(`@angular/cli@${this.getCLIUpdateRunnerVersion(packagesToUpdate, next)}`, this.context.logger, {\n            verbose,\n            usingYarn: this.context.packageManager.name === workspace_schema_1.PackageManager.Yarn,\n        });\n        return version_1.VERSION.full === version ? null : version;\n    }\n    getCLIUpdateRunnerVersion(packagesToUpdate, next) {\n        var _a, _b;\n        if (next) {\n            return 'next';\n        }\n        const updatingAngularPackage = packagesToUpdate === null || packagesToUpdate === void 0 ? void 0 : packagesToUpdate.find((r) => ANGULAR_PACKAGES_REGEXP.test(r));\n        if (updatingAngularPackage) {\n            // If we are updating any Angular package we can update the CLI to the target version because\n            // migrations for @angular/core@13 can be executed using Angular/cli@13.\n            // This is same behaviour as `npx @angular/cli@13 update @angular/core@13`.\n            // `@angular/cli@13` -> ['', 'angular/cli', '13']\n            // `@angular/cli` -> ['', 'angular/cli']\n            const tempVersion = coerceVersionNumber(updatingAngularPackage.split('@')[2]);\n            return (_b = (_a = semver.parse(tempVersion)) === null || _a === void 0 ? void 0 : _a.major) !== null && _b !== void 0 ? _b : 'latest';\n        }\n        // When not updating an Angular package we cannot determine which schematic runtime the migration should to be executed in.\n        // Typically, we can assume that the `@angular/cli` was updated previously.\n        // Example: Angular official packages are typically updated prior to NGRX etc...\n        // Therefore, we only update to the latest patch version of the installed major version of the Angular CLI.\n        // This is important because we might end up in a scenario where locally Angular v12 is installed, updating NGRX from 11 to 12.\n        // We end up using Angular ClI v13 to run the migrations if we run the migrations using the CLI installed major version + 1 logic.\n        return version_1.VERSION.major;\n    }\n    async runTempBinary(packageName, args = []) {\n        const { success, tempNodeModules } = await this.context.packageManager.installTemp(packageName);\n        if (!success) {\n            return 1;\n        }\n        // Remove version/tag etc... from package name\n        // Ex: @angular/cli@latest -> @angular/cli\n        const packageNameNoVersion = packageName.substring(0, packageName.lastIndexOf('@'));\n        const pkgLocation = (0, path_1.join)(tempNodeModules, packageNameNoVersion);\n        const packageJsonPath = (0, path_1.join)(pkgLocation, 'package.json');\n        // Get a binary location for this package\n        let binPath;\n        if ((0, fs_1.existsSync)(packageJsonPath)) {\n            const content = await fs_1.promises.readFile(packageJsonPath, 'utf-8');\n            if (content) {\n                const { bin = {} } = JSON.parse(content);\n                const binKeys = Object.keys(bin);\n                if (binKeys.length) {\n                    binPath = (0, path_1.resolve)(pkgLocation, bin[binKeys[0]]);\n                }\n            }\n        }\n        if (!binPath) {\n            throw new Error(`Cannot locate bin for temporary package: ${packageNameNoVersion}.`);\n        }\n        const { status, error } = (0, child_process_1.spawnSync)(process.execPath, [binPath, ...args], {\n            stdio: 'inherit',\n            env: {\n                ...process.env,\n                NG_DISABLE_VERSION_CHECK: 'true',\n                NG_CLI_ANALYTICS: 'false',\n            },\n        });\n        if (status === null && error) {\n            throw error;\n        }\n        return status !== null && status !== void 0 ? status : 0;\n    }\n    packageManagerForce(verbose) {\n        // npm 7+ can fail due to it incorrectly resolving peer dependencies that have valid SemVer\n        // ranges during an update. Update will set correct versions of dependencies within the\n        // package.json file. The force option is set to workaround these errors.\n        // Example error:\n        // npm ERR! Conflicting peer dependency: @angular/compiler-cli@14.0.0-rc.0\n        // npm ERR! node_modules/@angular/compiler-cli\n        // npm ERR!   peer @angular/compiler-cli@\"^14.0.0 || ^14.0.0-rc\" from @angular-devkit/build-angular@14.0.0-rc.0\n        // npm ERR!   node_modules/@angular-devkit/build-angular\n        // npm ERR!     dev @angular-devkit/build-angular@\"~14.0.0-rc.0\" from the root project\n        if (this.context.packageManager.name === workspace_schema_1.PackageManager.Npm &&\n            this.context.packageManager.version &&\n            semver.gte(this.context.packageManager.version, '7.0.0')) {\n            if (verbose) {\n                this.context.logger.info('NPM 7+ detected -- enabling force option for package installation');\n            }\n            return true;\n        }\n        return false;\n    }\n}\nexports.UpdateCommandModule = UpdateCommandModule;\n/**\n * @return Whether or not the working directory has Git changes to commit.\n */\nfunction hasChangesToCommit() {\n    // List all modified files not covered by .gitignore.\n    // If any files are returned, then there must be something to commit.\n    return (0, child_process_1.execSync)('git ls-files -m -d -o --exclude-standard').toString() !== '';\n}\n/**\n * Precondition: Must have pending changes to commit, they do not need to be staged.\n * Postcondition: The Git working tree is committed and the repo is clean.\n * @param message The commit message to use.\n */\nfunction createCommit(message) {\n    // Stage entire working tree for commit.\n    (0, child_process_1.execSync)('git add -A', { encoding: 'utf8', stdio: 'pipe' });\n    // Commit with the message passed via stdin to avoid bash escaping issues.\n    (0, child_process_1.execSync)('git commit --no-verify -F -', { encoding: 'utf8', stdio: 'pipe', input: message });\n}\n/**\n * @return The Git SHA hash of the HEAD commit. Returns null if unable to retrieve the hash.\n */\nfunction findCurrentGitSha() {\n    try {\n        return (0, child_process_1.execSync)('git rev-parse HEAD', { encoding: 'utf8', stdio: 'pipe' }).trim();\n    }\n    catch {\n        return null;\n    }\n}\nfunction getShortHash(commitHash) {\n    return commitHash.slice(0, 9);\n}\nfunction coerceVersionNumber(version) {\n    var _a;\n    if (!version) {\n        return undefined;\n    }\n    if (!/^\\d{1,30}\\.\\d{1,30}\\.\\d{1,30}/.test(version)) {\n        const match = version.match(/^\\d{1,30}(\\.\\d{1,30})*/);\n        if (!match) {\n            return undefined;\n        }\n        if (!match[1]) {\n            version = version.substring(0, match[0].length) + '.0.0' + version.substring(match[0].length);\n        }\n        else if (!match[2]) {\n            version = version.substring(0, match[0].length) + '.0' + version.substring(match[0].length);\n        }\n        else {\n            return undefined;\n        }\n    }\n    return (_a = semver.valid(version)) !== null && _a !== void 0 ? _a : undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}