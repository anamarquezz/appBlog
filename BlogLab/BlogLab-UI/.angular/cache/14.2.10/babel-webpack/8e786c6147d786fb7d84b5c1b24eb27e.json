{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst net_1 = __importDefault(require(\"net\"));\n\nconst tls_1 = __importDefault(require(\"tls\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst agent_base_1 = require(\"agent-base\");\n\nconst parse_proxy_response_1 = __importDefault(require(\"./parse-proxy-response\"));\n\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\n\nclass HttpsProxyAgent extends agent_base_1.Agent {\n  constructor(_opts) {\n    let opts;\n\n    if (typeof _opts === 'string') {\n      opts = url_1.default.parse(_opts);\n    } else {\n      opts = _opts;\n    }\n\n    if (!opts) {\n      throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n    }\n\n    debug('creating new HttpsProxyAgent instance: %o', opts);\n    super(opts);\n    const proxy = Object.assign({}, opts); // If `true`, then connect to the proxy server over TLS.\n    // Defaults to `false`.\n\n    this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol); // Prefer `hostname` over `host`, and set the `port` if needed.\n\n    proxy.host = proxy.hostname || proxy.host;\n\n    if (typeof proxy.port === 'string') {\n      proxy.port = parseInt(proxy.port, 10);\n    }\n\n    if (!proxy.port && proxy.host) {\n      proxy.port = this.secureProxy ? 443 : 80;\n    } // ALPN is supported by Node.js >= v5.\n    // attempt to negotiate http/1.1 for proxy servers that support http/2\n\n\n    if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n      proxy.ALPNProtocols = ['http 1.1'];\n    }\n\n    if (proxy.host && proxy.path) {\n      // If both a `host` and `path` are specified then it's most likely\n      // the result of a `url.parse()` call... we need to remove the\n      // `path` portion so that `net.connect()` doesn't attempt to open\n      // that as a Unix socket file.\n      delete proxy.path;\n      delete proxy.pathname;\n    }\n\n    this.proxy = proxy;\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   *\n   * @api protected\n   */\n\n\n  callback(req, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        proxy,\n        secureProxy\n      } = this; // Create a socket connection to the proxy server.\n\n      let socket;\n\n      if (secureProxy) {\n        debug('Creating `tls.Socket`: %o', proxy);\n        socket = tls_1.default.connect(proxy);\n      } else {\n        debug('Creating `net.Socket`: %o', proxy);\n        socket = net_1.default.connect(proxy);\n      }\n\n      const headers = Object.assign({}, proxy.headers);\n      const hostname = `${opts.host}:${opts.port}`;\n      let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`; // Inject the `Proxy-Authorization` header if necessary.\n\n      if (proxy.auth) {\n        headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n      } // The `Host` header should only include the port\n      // number when it is not the default port.\n\n\n      let {\n        host,\n        port,\n        secureEndpoint\n      } = opts;\n\n      if (!isDefaultPort(port, secureEndpoint)) {\n        host += `:${port}`;\n      }\n\n      headers.Host = host;\n      headers.Connection = 'close';\n\n      for (const name of Object.keys(headers)) {\n        payload += `${name}: ${headers[name]}\\r\\n`;\n      }\n\n      const proxyResponsePromise = parse_proxy_response_1.default(socket);\n      socket.write(`${payload}\\r\\n`);\n      const {\n        statusCode,\n        buffered\n      } = yield proxyResponsePromise;\n\n      if (statusCode === 200) {\n        req.once('socket', resume);\n\n        if (opts.secureEndpoint) {\n          // The proxy is connecting to a TLS server, so upgrade\n          // this socket connection to a TLS connection.\n          debug('Upgrading socket connection to TLS');\n          const servername = opts.servername || opts.host;\n          return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), {\n            socket,\n            servername\n          }));\n        }\n\n        return socket;\n      } // Some other status code that's not 200... need to re-play the HTTP\n      // header \"data\" events onto the socket once the HTTP machinery is\n      // attached so that the node core `http` can parse and handle the\n      // error status code.\n      // Close the original socket, and a new \"fake\" socket is returned\n      // instead, so that the proxy doesn't get the HTTP request\n      // written to it (which may contain `Authorization` headers or other\n      // sensitive data).\n      //\n      // See: https://hackerone.com/reports/541502\n\n\n      socket.destroy();\n      const fakeSocket = new net_1.default.Socket({\n        writable: false\n      });\n      fakeSocket.readable = true; // Need to wait for the \"socket\" event to re-play the \"data\" events.\n\n      req.once('socket', s => {\n        debug('replaying proxy buffer for failed request');\n        assert_1.default(s.listenerCount('data') > 0); // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n        // this point the HTTP module machinery has been hooked up for\n        // the user.\n\n        s.push(buffered);\n        s.push(null);\n      });\n      return fakeSocket;\n    });\n  }\n\n}\n\nexports.default = HttpsProxyAgent;\n\nfunction resume(socket) {\n  socket.resume();\n}\n\nfunction isDefaultPort(port, secure) {\n  return Boolean(!secure && port === 80 || secure && port === 443);\n}\n\nfunction isHTTPS(protocol) {\n  return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n\nfunction omit(obj, ...keys) {\n  const ret = {};\n  let key;\n\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n\n  return ret;\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","net_1","require","tls_1","url_1","assert_1","debug_1","agent_base_1","parse_proxy_response_1","debug","default","HttpsProxyAgent","Agent","constructor","_opts","opts","parse","Error","proxy","assign","secureProxy","isHTTPS","protocol","host","hostname","port","parseInt","ALPNProtocols","path","pathname","callback","req","socket","connect","headers","payload","auth","Buffer","from","toString","secureEndpoint","isDefaultPort","Host","Connection","name","keys","proxyResponsePromise","write","statusCode","buffered","once","resume","servername","omit","destroy","fakeSocket","Socket","writable","readable","s","listenerCount","push","secure","Boolean","test","obj","ret","key","includes"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/https-proxy-agent/dist/agent.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = __importDefault(require(\"net\"));\nconst tls_1 = __importDefault(require(\"tls\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst agent_base_1 = require(\"agent-base\");\nconst parse_proxy_response_1 = __importDefault(require(\"./parse-proxy-response\"));\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('creating new HttpsProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n            proxy.ALPNProtocols = ['http 1.1'];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = 'close';\n            for (const name of Object.keys(headers)) {\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once('socket', resume);\n                if (opts.secureEndpoint) {\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug('Upgrading socket connection to TLS');\n                    const servername = opts.servername || opts.host;\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,\n                        servername }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket({ writable: false });\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once('socket', (s) => {\n                debug('replaying proxy buffer for failed request');\n                assert_1.default(s.listenerCount('data') > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports.default = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean((!secure && port === 80) || (secure && port === 443));\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}