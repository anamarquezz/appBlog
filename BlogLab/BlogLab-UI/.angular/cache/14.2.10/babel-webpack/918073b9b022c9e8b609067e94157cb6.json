{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst FileFetcher = require('./file.js');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst pacoteVersion = require('../package.json').version;\n\nconst fetch = require('npm-registry-fetch');\n\nconst Minipass = require('minipass');\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\n\nconst _headers = Symbol('_headers');\n\nclass RemoteFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n    this.resolved = this.spec.fetchSpec;\n    const resolvedURL = new URL(this.resolved);\n\n    if (this.replaceRegistryHost !== 'never' && (this.replaceRegistryHost === 'always' || this.replaceRegistryHost === resolvedURL.host)) {\n      this.resolved = new URL(resolvedURL.pathname, this.registry).href;\n    } // nam is a fermented pork sausage that is good to eat\n\n\n    const nameat = this.spec.name ? `${this.spec.name}@` : '';\n    this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`;\n  } // Don't need to cache tarball fetches in pacote, because make-fetch-happen\n  // will write into cacache anyway.\n\n\n  get [_cacheFetches]() {\n    return false;\n  }\n\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.hasIntegrityEmitter = true;\n    const fetchOpts = { ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      integrity: this.integrity,\n      algorithms: [this.pickIntegrityAlgorithm()]\n    }; // eslint-disable-next-line promise/always-return\n\n    fetch(this.resolved, fetchOpts).then(res => {\n      res.body.on('error',\n      /* istanbul ignore next - exceedingly rare and hard to simulate */\n      er => stream.emit('error', er));\n      res.body.on('integrity', i => {\n        this.integrity = i;\n        stream.emit('integrity', i);\n      });\n      res.body.pipe(stream);\n    }).catch(er => stream.emit('error', er));\n    return stream;\n  }\n\n  [_headers]() {\n    return {\n      // npm will override this, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'tarball',\n      'pacote-pkg-id': this.pkgid,\n      ...(this.integrity ? {\n        'pacote-integrity': String(this.integrity)\n      } : {}),\n      ...(this.opts.headers || {})\n    };\n  }\n\n  get types() {\n    return ['remote'];\n  } // getting a packument and/or manifest is the same as with a file: spec.\n  // unpack the tarball stream, and then read from the package.json file.\n\n\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n\n  manifest() {\n    return FileFetcher.prototype.manifest.apply(this);\n  }\n\n}\n\nmodule.exports = RemoteFetcher;","map":{"version":3,"names":["Fetcher","require","FileFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","fetch","Minipass","_cacheFetches","_headers","RemoteFetcher","constructor","spec","opts","resolved","fetchSpec","resolvedURL","URL","replaceRegistryHost","host","pathname","registry","href","nameat","name","pkgid","stream","hasIntegrityEmitter","fetchOpts","headers","integrity","algorithms","pickIntegrityAlgorithm","then","res","body","on","er","emit","i","pipe","catch","userAgent","process","String","types","packument","prototype","apply","manifest","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/pacote/lib/remote.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst FileFetcher = require('./file.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst fetch = require('npm-registry-fetch')\nconst Minipass = require('minipass')\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches')\nconst _headers = Symbol('_headers')\nclass RemoteFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n    this.resolved = this.spec.fetchSpec\n    const resolvedURL = new URL(this.resolved)\n    if (this.replaceRegistryHost !== 'never'\n      && (this.replaceRegistryHost === 'always'\n      || this.replaceRegistryHost === resolvedURL.host)) {\n      this.resolved = new URL(resolvedURL.pathname, this.registry).href\n    }\n\n    // nam is a fermented pork sausage that is good to eat\n    const nameat = this.spec.name ? `${this.spec.name}@` : ''\n    this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`\n  }\n\n  // Don't need to cache tarball fetches in pacote, because make-fetch-happen\n  // will write into cacache anyway.\n  get [_cacheFetches] () {\n    return false\n  }\n\n  [_tarballFromResolved] () {\n    const stream = new Minipass()\n    stream.hasIntegrityEmitter = true\n\n    const fetchOpts = {\n      ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      integrity: this.integrity,\n      algorithms: [this.pickIntegrityAlgorithm()],\n    }\n\n    // eslint-disable-next-line promise/always-return\n    fetch(this.resolved, fetchOpts).then(res => {\n      res.body.on('error',\n        /* istanbul ignore next - exceedingly rare and hard to simulate */\n        er => stream.emit('error', er)\n      )\n\n      res.body.on('integrity', i => {\n        this.integrity = i\n        stream.emit('integrity', i)\n      })\n\n      res.body.pipe(stream)\n    }).catch(er => stream.emit('error', er))\n\n    return stream\n  }\n\n  [_headers] () {\n    return {\n      // npm will override this, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'tarball',\n      'pacote-pkg-id': this.pkgid,\n      ...(this.integrity ? { 'pacote-integrity': String(this.integrity) }\n      : {}),\n      ...(this.opts.headers || {}),\n    }\n  }\n\n  get types () {\n    return ['remote']\n  }\n\n  // getting a packument and/or manifest is the same as with a file: spec.\n  // unpack the tarball stream, and then read from the package.json file.\n  packument () {\n    return FileFetcher.prototype.packument.apply(this)\n  }\n\n  manifest () {\n    return FileFetcher.prototype.manifest.apply(this)\n  }\n}\nmodule.exports = RemoteFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}