{"ast":null,"code":"var _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Fetcher = require('./fetcher.js');\n\nconst FileFetcher = require('./file.js');\n\nconst RemoteFetcher = require('./remote.js');\n\nconst DirFetcher = require('./dir.js');\n\nconst hashre = /^[a-f0-9]{40}$/;\n\nconst git = require('@npmcli/git');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst npa = require('npm-package-arg');\n\nconst Minipass = require('minipass');\n\nconst cacache = require('cacache');\n\nconst log = require('proc-log');\n\nconst npm = require('./util/npm.js');\n\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo');\n\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted');\n\nconst _resolvedFromClone = Symbol('_resolvedFromClone');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _addGitSha = Symbol('_addGitSha');\n\nconst addGitSha = require('./util/add-git-sha.js');\n\nconst _clone = Symbol('_clone');\n\nconst _cloneHosted = Symbol('_cloneHosted');\n\nconst _cloneRepo = Symbol('_cloneRepo');\n\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha');\n\nconst _prepareDir = Symbol('_prepareDir');\n\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson'); // get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\n\n\nconst repoUrl = (h, opts) => h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) || h.https && addGitPlus(h.https(opts)); // add git+ to the url, but only one time.\n\n\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+');\n\nclass GitFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // we never want to compare integrity for git dependencies: npm/rfcs#525\n\n    if (this.opts.integrity) {\n      delete this.opts.integrity;\n      log.warn(`skipping integrity check for git dependency ${this.spec.fetchSpec}`);\n    }\n\n    this.resolvedRef = null;\n\n    if (this.spec.hosted) {\n      this.from = this.spec.hosted.shortcut({\n        noCommittish: false\n      });\n    } // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n\n\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish; // use hosted.tarball() when we shell to RemoteFetcher later\n\n      this.resolved = this.spec.hosted ? repoUrl(this.spec.hosted, {\n        noCommittish: false\n      }) : this.spec.rawSpec;\n    } else {\n      this.resolvedSha = '';\n    }\n  } // just exposed to make it easier to test all the combinations\n\n\n  static repoUrl(hosted, opts) {\n    return repoUrl(hosted, opts);\n  }\n\n  get types() {\n    return ['git'];\n  }\n\n  resolve() {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved) {\n      return super.resolve();\n    } // fetch the git repo and then look at the current hash\n\n\n    const h = this.spec.hosted; // try to use ssh, fall back to git.\n\n    return h ? this[_resolvedFromHosted](h) : this[_resolvedFromRepo](this.spec.fetchSpec);\n  } // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n\n\n  [_resolvedFromHosted](hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https()).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) {\n        throw er;\n      }\n\n      const ssh = hosted.sshurl && hosted.sshurl(); // no fallthrough if we can't fall through or have https auth\n\n      if (!ssh || hosted.auth) {\n        throw er;\n      }\n\n      return this[_resolvedFromRepo](ssh);\n    });\n  }\n\n  [_resolvedFromRepo](gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote) {\n      return Promise.reject(new Error(`No git url for ${this.spec}`));\n    }\n\n    const gitRange = this.spec.gitRange;\n    const name = this.spec.name;\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name\n      }, gitRange, this.opts) : this.spec.gitCommittish ? remoteRefs.refs[this.spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]] : remoteRefs.refs.HEAD; // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha) {\n        return this[_resolvedFromClone]();\n      }\n\n      this.resolvedRef = revDoc;\n      this.resolvedSha = revDoc.sha;\n\n      this[_addGitSha](revDoc.sha);\n\n      return this.resolved;\n    });\n  }\n\n  [_setResolvedWithSha](withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha : repoUrl(npa(withSha).hosted, {\n      noCommittish: false\n    });\n  } // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n\n\n  [_addGitSha](sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha));\n  }\n\n  [_resolvedFromClone]() {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved);\n  }\n\n  [_prepareDir](dir) {\n    return this[_readPackageJson](dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts;\n\n      if (!mani.workspaces && (!scripts || !(scripts.postinstall || scripts.build || scripts.preinstall || scripts.install || scripts.prepack || scripts.prepare))) {\n        return;\n      } // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n\n\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? [] : process.env._PACOTE_NO_PREPARE_.split('\\n');\n\n      if (noPrepare.includes(this.resolved)) {\n        log.info('prepare', 'skip prepare, already seen', this.resolved);\n        return;\n      }\n\n      noPrepare.push(this.resolved); // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n\n      return npm(this.npmBin, [].concat(this.npmInstallCmd).concat(this.npmCliConfig), dir, { ...process.env,\n        _PACOTE_NO_PREPARE_: noPrepare.join('\\n')\n      }, {\n        message: 'git dep preparation failed'\n      });\n    });\n  }\n\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.resolved = this.resolved;\n    stream.from = this.from; // check it out and then shell out to the DirFetcher tarball packer\n\n    this[_clone](dir => this[_prepareDir](dir).then(() => new Promise((res, rej) => {\n      const df = new DirFetcher(`file:${dir}`, { ...this.opts,\n        resolved: null,\n        integrity: null\n      });\n\n      const dirStream = df[_tarballFromResolved]();\n\n      dirStream.on('error', rej);\n      dirStream.on('end', res);\n      dirStream.pipe(stream);\n    }))).catch(\n    /* istanbul ignore next: very unlikely and hard to test */\n    er => stream.emit('error', er));\n\n    return stream;\n  } // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n\n\n  [_clone](handler, tarballOk = true) {\n    var _this = this;\n\n    const o = {\n      tmpPrefix: 'git-clone'\n    };\n    const ref = this.resolvedSha || this.spec.gitCommittish;\n    const h = this.spec.hosted;\n    const resolved = this.resolved; // can be set manually to false to fall back to actual git clone\n\n    tarballOk = tarballOk && h && resolved === repoUrl(h, {\n      noCommittish: false\n    }) && h.tarball;\n    return cacache.tmp.withTmp(this.cache, o, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (tmp) {\n        // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n        if (tarballOk) {\n          const nameat = _this.spec.name ? `${_this.spec.name}@` : '';\n          return new RemoteFetcher(h.tarball({\n            noCommittish: false\n          }), { ..._this.opts,\n            allowGitIgnore: true,\n            pkgid: `git:${nameat}${_this.resolved}`,\n            resolved: _this.resolved,\n            integrity: null // it'll always be different, if we have one\n\n          }).extract(tmp).then(() => handler(tmp), er => {\n            // fall back to ssh download if tarball fails\n            if (er.constructor.name.match(/^Http/)) {\n              return _this[_clone](handler, false);\n            } else {\n              throw er;\n            }\n          });\n        }\n\n        const sha = yield h ? _this[_cloneHosted](ref, tmp) : _this[_cloneRepo](_this.spec.fetchSpec, ref, tmp);\n        _this.resolvedSha = sha;\n\n        if (!_this.resolved) {\n          yield _this[_addGitSha](sha);\n        }\n\n        return handler(tmp);\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  } // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n\n\n  [_cloneHosted](ref, tmp) {\n    const hosted = this.spec.hosted;\n    return this[_cloneRepo](hosted.https({\n      noCommittish: true\n    }), ref, tmp).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) {\n        throw er;\n      }\n\n      const ssh = hosted.sshurl && hosted.sshurl({\n        noCommittish: true\n      }); // no fallthrough if we can't fall through or have https auth\n\n      if (!ssh || hosted.auth) {\n        throw er;\n      }\n\n      return this[_cloneRepo](ssh, ref, tmp);\n    });\n  }\n\n  [_cloneRepo](repo, ref, tmp) {\n    const {\n      opts,\n      spec\n    } = this;\n    return git.clone(repo, ref, tmp, { ...opts,\n      spec\n    });\n  }\n\n  manifest() {\n    if (this.package) {\n      return Promise.resolve(this.package);\n    }\n\n    return this.spec.hosted && this.resolved ? FileFetcher.prototype.manifest.apply(this) : this[_clone](dir => this[_readPackageJson](dir + '/package.json').then(mani => this.package = { ...mani,\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n\n}\n\nmodule.exports = GitFetcher;","map":{"version":3,"names":["Fetcher","require","FileFetcher","RemoteFetcher","DirFetcher","hashre","git","pickManifest","npa","Minipass","cacache","log","npm","_resolvedFromRepo","Symbol","_resolvedFromHosted","_resolvedFromClone","_tarballFromResolved","for","_addGitSha","addGitSha","_clone","_cloneHosted","_cloneRepo","_setResolvedWithSha","_prepareDir","_readPackageJson","repoUrl","h","opts","sshurl","https","auth","addGitPlus","url","replace","GitFetcher","constructor","spec","integrity","warn","fetchSpec","resolvedRef","hosted","from","shortcut","noCommittish","gitCommittish","test","resolvedSha","resolved","rawSpec","types","resolve","catch","er","errors","GitPathspecError","ssh","gitRemote","Promise","reject","Error","gitRange","name","revs","then","remoteRefs","versions","refs","shas","HEAD","revDoc","sha","withSha","dir","mani","scripts","workspaces","postinstall","build","preinstall","install","prepack","prepare","noPrepare","process","env","_PACOTE_NO_PREPARE_","split","includes","info","push","npmBin","concat","npmInstallCmd","npmCliConfig","join","message","stream","res","rej","df","dirStream","on","pipe","emit","handler","tarballOk","o","tmpPrefix","ref","tarball","tmp","withTmp","cache","nameat","allowGitIgnore","pkgid","extract","match","repo","clone","manifest","package","prototype","apply","_resolved","_from","packument","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/pacote/lib/git.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst FileFetcher = require('./file.js')\nconst RemoteFetcher = require('./remote.js')\nconst DirFetcher = require('./dir.js')\nconst hashre = /^[a-f0-9]{40}$/\nconst git = require('@npmcli/git')\nconst pickManifest = require('npm-pick-manifest')\nconst npa = require('npm-package-arg')\nconst Minipass = require('minipass')\nconst cacache = require('cacache')\nconst log = require('proc-log')\nconst npm = require('./util/npm.js')\n\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo')\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted')\nconst _resolvedFromClone = Symbol('_resolvedFromClone')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst _addGitSha = Symbol('_addGitSha')\nconst addGitSha = require('./util/add-git-sha.js')\nconst _clone = Symbol('_clone')\nconst _cloneHosted = Symbol('_cloneHosted')\nconst _cloneRepo = Symbol('_cloneRepo')\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha')\nconst _prepareDir = Symbol('_prepareDir')\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson')\n\n// get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\nconst repoUrl = (h, opts) =>\n  h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) ||\n  h.https && addGitPlus(h.https(opts))\n\n// add git+ to the url, but only one time.\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+')\n\nclass GitFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // we never want to compare integrity for git dependencies: npm/rfcs#525\n    if (this.opts.integrity) {\n      delete this.opts.integrity\n      log.warn(`skipping integrity check for git dependency ${this.spec.fetchSpec}`)\n    }\n\n    this.resolvedRef = null\n    if (this.spec.hosted) {\n      this.from = this.spec.hosted.shortcut({ noCommittish: false })\n    }\n\n    // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish\n      // use hosted.tarball() when we shell to RemoteFetcher later\n      this.resolved = this.spec.hosted\n        ? repoUrl(this.spec.hosted, { noCommittish: false })\n        : this.spec.rawSpec\n    } else {\n      this.resolvedSha = ''\n    }\n  }\n\n  // just exposed to make it easier to test all the combinations\n  static repoUrl (hosted, opts) {\n    return repoUrl(hosted, opts)\n  }\n\n  get types () {\n    return ['git']\n  }\n\n  resolve () {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved) {\n      return super.resolve()\n    }\n\n    // fetch the git repo and then look at the current hash\n    const h = this.spec.hosted\n    // try to use ssh, fall back to git.\n    return h ? this[_resolvedFromHosted](h)\n      : this[_resolvedFromRepo](this.spec.fetchSpec)\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_resolvedFromHosted] (hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https())\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError) {\n          throw er\n        }\n        const ssh = hosted.sshurl && hosted.sshurl()\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth) {\n          throw er\n        }\n        return this[_resolvedFromRepo](ssh)\n      })\n  }\n\n  [_resolvedFromRepo] (gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote) {\n      return Promise.reject(new Error(`No git url for ${this.spec}`))\n    }\n    const gitRange = this.spec.gitRange\n    const name = this.spec.name\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name,\n      }, gitRange, this.opts)\n        : this.spec.gitCommittish ?\n          remoteRefs.refs[this.spec.gitCommittish] ||\n          remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]]\n          : remoteRefs.refs.HEAD // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha) {\n        return this[_resolvedFromClone]()\n      }\n\n      this.resolvedRef = revDoc\n      this.resolvedSha = revDoc.sha\n      this[_addGitSha](revDoc.sha)\n      return this.resolved\n    })\n  }\n\n  [_setResolvedWithSha] (withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha\n      : repoUrl(npa(withSha).hosted, { noCommittish: false })\n  }\n\n  // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n  [_addGitSha] (sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha))\n  }\n\n  [_resolvedFromClone] () {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved)\n  }\n\n  [_prepareDir] (dir) {\n    return this[_readPackageJson](dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts\n      if (!mani.workspaces && (!scripts || !(\n        scripts.postinstall ||\n          scripts.build ||\n          scripts.preinstall ||\n          scripts.install ||\n          scripts.prepack ||\n          scripts.prepare))) {\n        return\n      }\n\n      // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? []\n        : process.env._PACOTE_NO_PREPARE_.split('\\n')\n      if (noPrepare.includes(this.resolved)) {\n        log.info('prepare', 'skip prepare, already seen', this.resolved)\n        return\n      }\n      noPrepare.push(this.resolved)\n\n      // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n      return npm(\n        this.npmBin,\n        [].concat(this.npmInstallCmd).concat(this.npmCliConfig),\n        dir,\n        { ...process.env, _PACOTE_NO_PREPARE_: noPrepare.join('\\n') },\n        { message: 'git dep preparation failed' }\n      )\n    })\n  }\n\n  [_tarballFromResolved] () {\n    const stream = new Minipass()\n    stream.resolved = this.resolved\n    stream.from = this.from\n\n    // check it out and then shell out to the DirFetcher tarball packer\n    this[_clone](dir => this[_prepareDir](dir)\n      .then(() => new Promise((res, rej) => {\n        const df = new DirFetcher(`file:${dir}`, {\n          ...this.opts,\n          resolved: null,\n          integrity: null,\n        })\n        const dirStream = df[_tarballFromResolved]()\n        dirStream.on('error', rej)\n        dirStream.on('end', res)\n        dirStream.pipe(stream)\n      }))).catch(\n      /* istanbul ignore next: very unlikely and hard to test */\n      er => stream.emit('error', er)\n    )\n    return stream\n  }\n\n  // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n  [_clone] (handler, tarballOk = true) {\n    const o = { tmpPrefix: 'git-clone' }\n    const ref = this.resolvedSha || this.spec.gitCommittish\n    const h = this.spec.hosted\n    const resolved = this.resolved\n\n    // can be set manually to false to fall back to actual git clone\n    tarballOk = tarballOk &&\n      h && resolved === repoUrl(h, { noCommittish: false }) && h.tarball\n\n    return cacache.tmp.withTmp(this.cache, o, async tmp => {\n      // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n      if (tarballOk) {\n        const nameat = this.spec.name ? `${this.spec.name}@` : ''\n        return new RemoteFetcher(h.tarball({ noCommittish: false }), {\n          ...this.opts,\n          allowGitIgnore: true,\n          pkgid: `git:${nameat}${this.resolved}`,\n          resolved: this.resolved,\n          integrity: null, // it'll always be different, if we have one\n        }).extract(tmp).then(() => handler(tmp), er => {\n          // fall back to ssh download if tarball fails\n          if (er.constructor.name.match(/^Http/)) {\n            return this[_clone](handler, false)\n          } else {\n            throw er\n          }\n        })\n      }\n\n      const sha = await (\n        h ? this[_cloneHosted](ref, tmp)\n        : this[_cloneRepo](this.spec.fetchSpec, ref, tmp)\n      )\n      this.resolvedSha = sha\n      if (!this.resolved) {\n        await this[_addGitSha](sha)\n      }\n      return handler(tmp)\n    })\n  }\n\n  // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n  [_cloneHosted] (ref, tmp) {\n    const hosted = this.spec.hosted\n    return this[_cloneRepo](hosted.https({ noCommittish: true }), ref, tmp)\n      .catch(er => {\n        // Throw early since we know pathspec errors will fail again if retried\n        if (er instanceof git.errors.GitPathspecError) {\n          throw er\n        }\n        const ssh = hosted.sshurl && hosted.sshurl({ noCommittish: true })\n        // no fallthrough if we can't fall through or have https auth\n        if (!ssh || hosted.auth) {\n          throw er\n        }\n        return this[_cloneRepo](ssh, ref, tmp)\n      })\n  }\n\n  [_cloneRepo] (repo, ref, tmp) {\n    const { opts, spec } = this\n    return git.clone(repo, ref, tmp, { ...opts, spec })\n  }\n\n  manifest () {\n    if (this.package) {\n      return Promise.resolve(this.package)\n    }\n\n    return this.spec.hosted && this.resolved\n      ? FileFetcher.prototype.manifest.apply(this)\n      : this[_clone](dir =>\n        this[_readPackageJson](dir + '/package.json')\n          .then(mani => this.package = {\n            ...mani,\n            _resolved: this.resolved,\n            _from: this.from,\n          }))\n  }\n\n  packument () {\n    return FileFetcher.prototype.packument.apply(this)\n  }\n}\nmodule.exports = GitFetcher\n"],"mappings":";;AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,WAAD,CAA3B;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,aAAD,CAA7B;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,UAAD,CAA1B;;AACA,MAAMI,MAAM,GAAG,gBAAf;;AACA,MAAMC,GAAG,GAAGL,OAAO,CAAC,aAAD,CAAnB;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,mBAAD,CAA5B;;AACA,MAAMO,GAAG,GAAGP,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMS,OAAO,GAAGT,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMU,GAAG,GAAGV,OAAO,CAAC,UAAD,CAAnB;;AACA,MAAMW,GAAG,GAAGX,OAAO,CAAC,eAAD,CAAnB;;AAEA,MAAMY,iBAAiB,GAAGC,MAAM,CAAC,mBAAD,CAAhC;;AACA,MAAMC,mBAAmB,GAAGD,MAAM,CAAC,qBAAD,CAAlC;;AACA,MAAME,kBAAkB,GAAGF,MAAM,CAAC,oBAAD,CAAjC;;AACA,MAAMG,oBAAoB,GAAGH,MAAM,CAACI,GAAP,CAAW,qCAAX,CAA7B;;AACA,MAAMC,UAAU,GAAGL,MAAM,CAAC,YAAD,CAAzB;;AACA,MAAMM,SAAS,GAAGnB,OAAO,CAAC,uBAAD,CAAzB;;AACA,MAAMoB,MAAM,GAAGP,MAAM,CAAC,QAAD,CAArB;;AACA,MAAMQ,YAAY,GAAGR,MAAM,CAAC,cAAD,CAA3B;;AACA,MAAMS,UAAU,GAAGT,MAAM,CAAC,YAAD,CAAzB;;AACA,MAAMU,mBAAmB,GAAGV,MAAM,CAAC,qBAAD,CAAlC;;AACA,MAAMW,WAAW,GAAGX,MAAM,CAAC,aAAD,CAA1B;;AACA,MAAMY,gBAAgB,GAAGZ,MAAM,CAACI,GAAP,CAAW,kCAAX,CAAzB,C,CAEA;AACA;AACA;AACA;;;AACA,MAAMS,OAAO,GAAG,CAACC,CAAD,EAAIC,IAAJ,KACdD,CAAC,CAACE,MAAF,IAAY,EAAEF,CAAC,CAACG,KAAF,IAAWH,CAAC,CAACI,IAAf,CAAZ,IAAoCC,UAAU,CAACL,CAAC,CAACE,MAAF,CAASD,IAAT,CAAD,CAA9C,IACAD,CAAC,CAACG,KAAF,IAAWE,UAAU,CAACL,CAAC,CAACG,KAAF,CAAQF,IAAR,CAAD,CAFvB,C,CAIA;;;AACA,MAAMI,UAAU,GAAGC,GAAG,IAAIA,GAAG,IAAK,OAAMA,GAAI,EAAX,CAAaC,OAAb,CAAqB,WAArB,EAAkC,MAAlC,CAAjC;;AAEA,MAAMC,UAAN,SAAyBpC,OAAzB,CAAiC;EAC/BqC,WAAW,CAAEC,IAAF,EAAQT,IAAR,EAAc;IACvB,MAAMS,IAAN,EAAYT,IAAZ,EADuB,CAGvB;;IACA,IAAI,KAAKA,IAAL,CAAUU,SAAd,EAAyB;MACvB,OAAO,KAAKV,IAAL,CAAUU,SAAjB;MACA5B,GAAG,CAAC6B,IAAJ,CAAU,+CAA8C,KAAKF,IAAL,CAAUG,SAAU,EAA5E;IACD;;IAED,KAAKC,WAAL,GAAmB,IAAnB;;IACA,IAAI,KAAKJ,IAAL,CAAUK,MAAd,EAAsB;MACpB,KAAKC,IAAL,GAAY,KAAKN,IAAL,CAAUK,MAAV,CAAiBE,QAAjB,CAA0B;QAAEC,YAAY,EAAE;MAAhB,CAA1B,CAAZ;IACD,CAZsB,CAcvB;IACA;;;IACA,IAAI,KAAKR,IAAL,CAAUS,aAAV,IAA2B1C,MAAM,CAAC2C,IAAP,CAAY,KAAKV,IAAL,CAAUS,aAAtB,CAA/B,EAAqE;MACnE,KAAKE,WAAL,GAAmB,KAAKX,IAAL,CAAUS,aAA7B,CADmE,CAEnE;;MACA,KAAKG,QAAL,GAAgB,KAAKZ,IAAL,CAAUK,MAAV,GACZhB,OAAO,CAAC,KAAKW,IAAL,CAAUK,MAAX,EAAmB;QAAEG,YAAY,EAAE;MAAhB,CAAnB,CADK,GAEZ,KAAKR,IAAL,CAAUa,OAFd;IAGD,CAND,MAMO;MACL,KAAKF,WAAL,GAAmB,EAAnB;IACD;EACF,CA1B8B,CA4B/B;;;EACc,OAAPtB,OAAO,CAAEgB,MAAF,EAAUd,IAAV,EAAgB;IAC5B,OAAOF,OAAO,CAACgB,MAAD,EAASd,IAAT,CAAd;EACD;;EAEQ,IAALuB,KAAK,GAAI;IACX,OAAO,CAAC,KAAD,CAAP;EACD;;EAEDC,OAAO,GAAI;IACT;IACA;IACA,IAAI,KAAKH,QAAT,EAAmB;MACjB,OAAO,MAAMG,OAAN,EAAP;IACD,CALQ,CAOT;;;IACA,MAAMzB,CAAC,GAAG,KAAKU,IAAL,CAAUK,MAApB,CARS,CAST;;IACA,OAAOf,CAAC,GAAG,KAAKb,mBAAL,EAA0Ba,CAA1B,CAAH,GACJ,KAAKf,iBAAL,EAAwB,KAAKyB,IAAL,CAAUG,SAAlC,CADJ;EAED,CAjD8B,CAmD/B;EACA;EACA;EACA;EACA;;;EACoB,CAAnB1B,mBAAmB,EAAG4B,MAAH,EAAW;IAC7B,OAAO,KAAK9B,iBAAL,EAAwB8B,MAAM,CAACZ,KAAP,IAAgBY,MAAM,CAACZ,KAAP,EAAxC,EACJuB,KADI,CACEC,EAAE,IAAI;MACX;MACA,IAAIA,EAAE,YAAYjD,GAAG,CAACkD,MAAJ,CAAWC,gBAA7B,EAA+C;QAC7C,MAAMF,EAAN;MACD;;MACD,MAAMG,GAAG,GAAGf,MAAM,CAACb,MAAP,IAAiBa,MAAM,CAACb,MAAP,EAA7B,CALW,CAMX;;MACA,IAAI,CAAC4B,GAAD,IAAQf,MAAM,CAACX,IAAnB,EAAyB;QACvB,MAAMuB,EAAN;MACD;;MACD,OAAO,KAAK1C,iBAAL,EAAwB6C,GAAxB,CAAP;IACD,CAZI,CAAP;EAaD;;EAEiB,CAAjB7C,iBAAiB,EAAG8C,SAAH,EAAc;IAC9B;IACA,IAAI,CAACA,SAAL,EAAgB;MACd,OAAOC,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAW,kBAAiB,KAAKxB,IAAK,EAAtC,CAAf,CAAP;IACD;;IACD,MAAMyB,QAAQ,GAAG,KAAKzB,IAAL,CAAUyB,QAA3B;IACA,MAAMC,IAAI,GAAG,KAAK1B,IAAL,CAAU0B,IAAvB;IACA,OAAO1D,GAAG,CAAC2D,IAAJ,CAASN,SAAT,EAAoB,KAAK9B,IAAzB,EAA+BqC,IAA/B,CAAoCC,UAAU,IAAI;MACvD,OAAOJ,QAAQ,GAAGxD,YAAY,CAAC;QAC7B6D,QAAQ,EAAED,UAAU,CAACC,QADQ;QAE7B,aAAaD,UAAU,CAAC,WAAD,CAFM;QAG7BH;MAH6B,CAAD,EAI3BD,QAJ2B,EAIjB,KAAKlC,IAJY,CAAf,GAKX,KAAKS,IAAL,CAAUS,aAAV,GACAoB,UAAU,CAACE,IAAX,CAAgB,KAAK/B,IAAL,CAAUS,aAA1B,KACAoB,UAAU,CAACE,IAAX,CAAgBF,UAAU,CAACG,IAAX,CAAgB,KAAKhC,IAAL,CAAUS,aAA1B,CAAhB,CAFA,GAGEoB,UAAU,CAACE,IAAX,CAAgBE,IARtB,CADuD,CAS5B;IAC5B,CAVM,EAUJL,IAVI,CAUCM,MAAM,IAAI;MAChB;MACA;MACA,IAAI,CAACA,MAAD,IAAW,CAACA,MAAM,CAACC,GAAvB,EAA4B;QAC1B,OAAO,KAAKzD,kBAAL,GAAP;MACD;;MAED,KAAK0B,WAAL,GAAmB8B,MAAnB;MACA,KAAKvB,WAAL,GAAmBuB,MAAM,CAACC,GAA1B;;MACA,KAAKtD,UAAL,EAAiBqD,MAAM,CAACC,GAAxB;;MACA,OAAO,KAAKvB,QAAZ;IACD,CArBM,CAAP;EAsBD;;EAEmB,CAAnB1B,mBAAmB,EAAGkD,OAAH,EAAY;IAC9B;IACA;IACA,KAAKxB,QAAL,GAAgB,CAAC,KAAKZ,IAAL,CAAUK,MAAX,GAAoB+B,OAApB,GACZ/C,OAAO,CAACnB,GAAG,CAACkE,OAAD,CAAH,CAAa/B,MAAd,EAAsB;MAAEG,YAAY,EAAE;IAAhB,CAAtB,CADX;EAED,CA5G8B,CA8G/B;EACA;;;EACW,CAAV3B,UAAU,EAAGsD,GAAH,EAAQ;IACjB,KAAKjD,mBAAL,EAA0BJ,SAAS,CAAC,KAAKkB,IAAN,EAAYmC,GAAZ,CAAnC;EACD;;EAEkB,CAAlBzD,kBAAkB,IAAK;IACtB;IACA;IACA,OAAO,KAAKK,MAAL,EAAasD,GAAG,IAAI,KAAKzB,QAAzB,CAAP;EACD;;EAEW,CAAXzB,WAAW,EAAGkD,GAAH,EAAQ;IAClB,OAAO,KAAKjD,gBAAL,EAAuBiD,GAAG,GAAG,eAA7B,EAA8CT,IAA9C,CAAmDU,IAAI,IAAI;MAChE;MACA,MAAMC,OAAO,GAAGD,IAAI,CAACC,OAArB;;MACA,IAAI,CAACD,IAAI,CAACE,UAAN,KAAqB,CAACD,OAAD,IAAY,EACnCA,OAAO,CAACE,WAAR,IACEF,OAAO,CAACG,KADV,IAEEH,OAAO,CAACI,UAFV,IAGEJ,OAAO,CAACK,OAHV,IAIEL,OAAO,CAACM,OAJV,IAKEN,OAAO,CAACO,OANyB,CAAjC,CAAJ,EAMuB;QACrB;MACD,CAX+D,CAahE;MACA;MACA;MACA;MACA;MACA;MACA;;;MACA,MAAMC,SAAS,GAAG,CAACC,OAAO,CAACC,GAAR,CAAYC,mBAAb,GAAmC,EAAnC,GACdF,OAAO,CAACC,GAAR,CAAYC,mBAAZ,CAAgCC,KAAhC,CAAsC,IAAtC,CADJ;;MAEA,IAAIJ,SAAS,CAACK,QAAV,CAAmB,KAAKxC,QAAxB,CAAJ,EAAuC;QACrCvC,GAAG,CAACgF,IAAJ,CAAS,SAAT,EAAoB,4BAApB,EAAkD,KAAKzC,QAAvD;QACA;MACD;;MACDmC,SAAS,CAACO,IAAV,CAAe,KAAK1C,QAApB,EA1BgE,CA4BhE;MACA;;MACA,OAAOtC,GAAG,CACR,KAAKiF,MADG,EAER,GAAGC,MAAH,CAAU,KAAKC,aAAf,EAA8BD,MAA9B,CAAqC,KAAKE,YAA1C,CAFQ,EAGRrB,GAHQ,EAIR,EAAE,GAAGW,OAAO,CAACC,GAAb;QAAkBC,mBAAmB,EAAEH,SAAS,CAACY,IAAV,CAAe,IAAf;MAAvC,CAJQ,EAKR;QAAEC,OAAO,EAAE;MAAX,CALQ,CAAV;IAOD,CArCM,CAAP;EAsCD;;EAEoB,CAApBjF,oBAAoB,IAAK;IACxB,MAAMkF,MAAM,GAAG,IAAI1F,QAAJ,EAAf;IACA0F,MAAM,CAACjD,QAAP,GAAkB,KAAKA,QAAvB;IACAiD,MAAM,CAACvD,IAAP,GAAc,KAAKA,IAAnB,CAHwB,CAKxB;;IACA,KAAKvB,MAAL,EAAasD,GAAG,IAAI,KAAKlD,WAAL,EAAkBkD,GAAlB,EACjBT,IADiB,CACZ,MAAM,IAAIN,OAAJ,CAAY,CAACwC,GAAD,EAAMC,GAAN,KAAc;MACpC,MAAMC,EAAE,GAAG,IAAIlG,UAAJ,CAAgB,QAAOuE,GAAI,EAA3B,EAA8B,EACvC,GAAG,KAAK9C,IAD+B;QAEvCqB,QAAQ,EAAE,IAF6B;QAGvCX,SAAS,EAAE;MAH4B,CAA9B,CAAX;;MAKA,MAAMgE,SAAS,GAAGD,EAAE,CAACrF,oBAAD,CAAF,EAAlB;;MACAsF,SAAS,CAACC,EAAV,CAAa,OAAb,EAAsBH,GAAtB;MACAE,SAAS,CAACC,EAAV,CAAa,KAAb,EAAoBJ,GAApB;MACAG,SAAS,CAACE,IAAV,CAAeN,MAAf;IACD,CAVW,CADM,CAApB,EAWO7C,KAXP;IAYE;IACAC,EAAE,IAAI4C,MAAM,CAACO,IAAP,CAAY,OAAZ,EAAqBnD,EAArB,CAbR;;IAeA,OAAO4C,MAAP;EACD,CAzL8B,CA2L/B;EACA;EACA;EACA;EACA;EACA;EACA;;;EACO,CAAN9E,MAAM,EAAGsF,OAAH,EAAYC,SAAS,GAAG,IAAxB,EAA8B;IAAA;;IACnC,MAAMC,CAAC,GAAG;MAAEC,SAAS,EAAE;IAAb,CAAV;IACA,MAAMC,GAAG,GAAG,KAAK9D,WAAL,IAAoB,KAAKX,IAAL,CAAUS,aAA1C;IACA,MAAMnB,CAAC,GAAG,KAAKU,IAAL,CAAUK,MAApB;IACA,MAAMO,QAAQ,GAAG,KAAKA,QAAtB,CAJmC,CAMnC;;IACA0D,SAAS,GAAGA,SAAS,IACnBhF,CADU,IACLsB,QAAQ,KAAKvB,OAAO,CAACC,CAAD,EAAI;MAAEkB,YAAY,EAAE;IAAhB,CAAJ,CADf,IAC+ClB,CAAC,CAACoF,OAD7D;IAGA,OAAOtG,OAAO,CAACuG,GAAR,CAAYC,OAAZ,CAAoB,KAAKC,KAAzB,EAAgCN,CAAhC;MAAA,6BAAmC,WAAMI,GAAN,EAAa;QACrD;QACA,IAAIL,SAAJ,EAAe;UACb,MAAMQ,MAAM,GAAG,KAAI,CAAC9E,IAAL,CAAU0B,IAAV,GAAkB,GAAE,KAAI,CAAC1B,IAAL,CAAU0B,IAAK,GAAnC,GAAwC,EAAvD;UACA,OAAO,IAAI7D,aAAJ,CAAkByB,CAAC,CAACoF,OAAF,CAAU;YAAElE,YAAY,EAAE;UAAhB,CAAV,CAAlB,EAAsD,EAC3D,GAAG,KAAI,CAACjB,IADmD;YAE3DwF,cAAc,EAAE,IAF2C;YAG3DC,KAAK,EAAG,OAAMF,MAAO,GAAE,KAAI,CAAClE,QAAS,EAHsB;YAI3DA,QAAQ,EAAE,KAAI,CAACA,QAJ4C;YAK3DX,SAAS,EAAE,IALgD,CAK1C;;UAL0C,CAAtD,EAMJgF,OANI,CAMIN,GANJ,EAMS/C,IANT,CAMc,MAAMyC,OAAO,CAACM,GAAD,CAN3B,EAMkC1D,EAAE,IAAI;YAC7C;YACA,IAAIA,EAAE,CAAClB,WAAH,CAAe2B,IAAf,CAAoBwD,KAApB,CAA0B,OAA1B,CAAJ,EAAwC;cACtC,OAAO,KAAI,CAACnG,MAAD,CAAJ,CAAasF,OAAb,EAAsB,KAAtB,CAAP;YACD,CAFD,MAEO;cACL,MAAMpD,EAAN;YACD;UACF,CAbM,CAAP;QAcD;;QAED,MAAMkB,GAAG,SACP7C,CAAC,GAAG,KAAI,CAACN,YAAD,CAAJ,CAAmByF,GAAnB,EAAwBE,GAAxB,CAAH,GACC,KAAI,CAAC1F,UAAD,CAAJ,CAAiB,KAAI,CAACe,IAAL,CAAUG,SAA3B,EAAsCsE,GAAtC,EAA2CE,GAA3C,CAFJ;QAIA,KAAI,CAAChE,WAAL,GAAmBwB,GAAnB;;QACA,IAAI,CAAC,KAAI,CAACvB,QAAV,EAAoB;UAClB,MAAM,KAAI,CAAC/B,UAAD,CAAJ,CAAiBsD,GAAjB,CAAN;QACD;;QACD,OAAOkC,OAAO,CAACM,GAAD,CAAd;MACD,CA7BM;;MAAA;QAAA;MAAA;IAAA,IAAP;EA8BD,CA1O8B,CA4O/B;EACA;EACA;EACA;EACA;;;EACa,CAAZ3F,YAAY,EAAGyF,GAAH,EAAQE,GAAR,EAAa;IACxB,MAAMtE,MAAM,GAAG,KAAKL,IAAL,CAAUK,MAAzB;IACA,OAAO,KAAKpB,UAAL,EAAiBoB,MAAM,CAACZ,KAAP,CAAa;MAAEe,YAAY,EAAE;IAAhB,CAAb,CAAjB,EAAuDiE,GAAvD,EAA4DE,GAA5D,EACJ3D,KADI,CACEC,EAAE,IAAI;MACX;MACA,IAAIA,EAAE,YAAYjD,GAAG,CAACkD,MAAJ,CAAWC,gBAA7B,EAA+C;QAC7C,MAAMF,EAAN;MACD;;MACD,MAAMG,GAAG,GAAGf,MAAM,CAACb,MAAP,IAAiBa,MAAM,CAACb,MAAP,CAAc;QAAEgB,YAAY,EAAE;MAAhB,CAAd,CAA7B,CALW,CAMX;;MACA,IAAI,CAACY,GAAD,IAAQf,MAAM,CAACX,IAAnB,EAAyB;QACvB,MAAMuB,EAAN;MACD;;MACD,OAAO,KAAKhC,UAAL,EAAiBmC,GAAjB,EAAsBqD,GAAtB,EAA2BE,GAA3B,CAAP;IACD,CAZI,CAAP;EAaD;;EAEU,CAAV1F,UAAU,EAAGkG,IAAH,EAASV,GAAT,EAAcE,GAAd,EAAmB;IAC5B,MAAM;MAAEpF,IAAF;MAAQS;IAAR,IAAiB,IAAvB;IACA,OAAOhC,GAAG,CAACoH,KAAJ,CAAUD,IAAV,EAAgBV,GAAhB,EAAqBE,GAArB,EAA0B,EAAE,GAAGpF,IAAL;MAAWS;IAAX,CAA1B,CAAP;EACD;;EAEDqF,QAAQ,GAAI;IACV,IAAI,KAAKC,OAAT,EAAkB;MAChB,OAAOhE,OAAO,CAACP,OAAR,CAAgB,KAAKuE,OAArB,CAAP;IACD;;IAED,OAAO,KAAKtF,IAAL,CAAUK,MAAV,IAAoB,KAAKO,QAAzB,GACHhD,WAAW,CAAC2H,SAAZ,CAAsBF,QAAtB,CAA+BG,KAA/B,CAAqC,IAArC,CADG,GAEH,KAAKzG,MAAL,EAAasD,GAAG,IAChB,KAAKjD,gBAAL,EAAuBiD,GAAG,GAAG,eAA7B,EACGT,IADH,CACQU,IAAI,IAAI,KAAKgD,OAAL,GAAe,EAC3B,GAAGhD,IADwB;MAE3BmD,SAAS,EAAE,KAAK7E,QAFW;MAG3B8E,KAAK,EAAE,KAAKpF;IAHe,CAD/B,CADA,CAFJ;EASD;;EAEDqF,SAAS,GAAI;IACX,OAAO/H,WAAW,CAAC2H,SAAZ,CAAsBI,SAAtB,CAAgCH,KAAhC,CAAsC,IAAtC,CAAP;EACD;;AAzR8B;;AA2RjCI,MAAM,CAACC,OAAP,GAAiB/F,UAAjB"},"metadata":{},"sourceType":"script"}