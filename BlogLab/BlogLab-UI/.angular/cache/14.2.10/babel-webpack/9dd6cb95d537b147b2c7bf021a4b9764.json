{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.strategy = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst json_1 = require(\"../../json\");\n\nconst api_1 = require(\"./api\"); // eslint-disable-next-line @typescript-eslint/no-namespace\n\n\nvar strategy;\n\n(function (strategy) {\n  /**\n   * Creates a JobStrategy that serializes every call. This strategy can be mixed between jobs.\n   */\n  function serialize() {\n    let latest = (0, rxjs_1.of)();\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        const previous = latest;\n        latest = (0, rxjs_1.concat)(previous.pipe((0, operators_1.ignoreElements)()), new rxjs_1.Observable(o => handler(argument, context).subscribe(o))).pipe((0, operators_1.shareReplay)(0));\n        return latest;\n      };\n\n      return Object.assign(newHandler, {\n        jobDescription: Object.assign({}, handler.jobDescription, options)\n      });\n    };\n  }\n\n  strategy.serialize = serialize;\n  /**\n   * Creates a JobStrategy that will always reuse a running job, and restart it if the job ended.\n   * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n   * is.\n   */\n\n  function reuse(replayMessages = false) {\n    let inboundBus = new rxjs_1.Subject();\n    let run = null;\n    let state = null;\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        // Forward inputs.\n        const subscription = context.inboundBus.subscribe(inboundBus);\n\n        if (run) {\n          return (0, rxjs_1.concat)( // Update state.\n          (0, rxjs_1.of)(state), run).pipe((0, operators_1.finalize)(() => subscription.unsubscribe()));\n        }\n\n        run = handler(argument, { ...context,\n          inboundBus: inboundBus.asObservable()\n        }).pipe((0, operators_1.tap)(message => {\n          if (message.kind == api_1.JobOutboundMessageKind.Start || message.kind == api_1.JobOutboundMessageKind.OnReady || message.kind == api_1.JobOutboundMessageKind.End) {\n            state = message;\n          }\n        }, undefined, () => {\n          subscription.unsubscribe();\n          inboundBus = new rxjs_1.Subject();\n          run = null;\n        }), replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n        return run;\n      };\n\n      return Object.assign(newHandler, handler, options || {});\n    };\n  }\n\n  strategy.reuse = reuse;\n  /**\n   * Creates a JobStrategy that will reuse a running job if the argument matches.\n   * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n   * is.\n   */\n\n  function memoize(replayMessages = false) {\n    const runs = new Map();\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        const argumentJson = JSON.stringify((0, json_1.isJsonObject)(argument) ? Object.keys(argument).sort().reduce((result, key) => {\n          result[key] = argument[key];\n          return result;\n        }, {}) : argument);\n        const maybeJob = runs.get(argumentJson);\n\n        if (maybeJob) {\n          return maybeJob;\n        }\n\n        const run = handler(argument, context).pipe(replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n        runs.set(argumentJson, run);\n        return run;\n      };\n\n      return Object.assign(newHandler, handler, options || {});\n    };\n  }\n\n  strategy.memoize = memoize;\n})(strategy = exports.strategy || (exports.strategy = {}));","map":{"version":3,"names":["Object","defineProperty","exports","value","strategy","rxjs_1","require","operators_1","json_1","api_1","serialize","latest","of","handler","options","newHandler","argument","context","previous","concat","pipe","ignoreElements","Observable","o","subscribe","shareReplay","assign","jobDescription","reuse","replayMessages","inboundBus","Subject","run","state","subscription","finalize","unsubscribe","asObservable","tap","message","kind","JobOutboundMessageKind","Start","OnReady","End","undefined","share","memoize","runs","Map","argumentJson","JSON","stringify","isJsonObject","keys","sort","reduce","result","key","maybeJob","get","set"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/experimental/jobs/strategy.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.strategy = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst json_1 = require(\"../../json\");\nconst api_1 = require(\"./api\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar strategy;\n(function (strategy) {\n    /**\n     * Creates a JobStrategy that serializes every call. This strategy can be mixed between jobs.\n     */\n    function serialize() {\n        let latest = (0, rxjs_1.of)();\n        return (handler, options) => {\n            const newHandler = (argument, context) => {\n                const previous = latest;\n                latest = (0, rxjs_1.concat)(previous.pipe((0, operators_1.ignoreElements)()), new rxjs_1.Observable((o) => handler(argument, context).subscribe(o))).pipe((0, operators_1.shareReplay)(0));\n                return latest;\n            };\n            return Object.assign(newHandler, {\n                jobDescription: Object.assign({}, handler.jobDescription, options),\n            });\n        };\n    }\n    strategy.serialize = serialize;\n    /**\n     * Creates a JobStrategy that will always reuse a running job, and restart it if the job ended.\n     * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n     * is.\n     */\n    function reuse(replayMessages = false) {\n        let inboundBus = new rxjs_1.Subject();\n        let run = null;\n        let state = null;\n        return (handler, options) => {\n            const newHandler = (argument, context) => {\n                // Forward inputs.\n                const subscription = context.inboundBus.subscribe(inboundBus);\n                if (run) {\n                    return (0, rxjs_1.concat)(\n                    // Update state.\n                    (0, rxjs_1.of)(state), run).pipe((0, operators_1.finalize)(() => subscription.unsubscribe()));\n                }\n                run = handler(argument, { ...context, inboundBus: inboundBus.asObservable() }).pipe((0, operators_1.tap)((message) => {\n                    if (message.kind == api_1.JobOutboundMessageKind.Start ||\n                        message.kind == api_1.JobOutboundMessageKind.OnReady ||\n                        message.kind == api_1.JobOutboundMessageKind.End) {\n                        state = message;\n                    }\n                }, undefined, () => {\n                    subscription.unsubscribe();\n                    inboundBus = new rxjs_1.Subject();\n                    run = null;\n                }), replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n                return run;\n            };\n            return Object.assign(newHandler, handler, options || {});\n        };\n    }\n    strategy.reuse = reuse;\n    /**\n     * Creates a JobStrategy that will reuse a running job if the argument matches.\n     * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n     * is.\n     */\n    function memoize(replayMessages = false) {\n        const runs = new Map();\n        return (handler, options) => {\n            const newHandler = (argument, context) => {\n                const argumentJson = JSON.stringify((0, json_1.isJsonObject)(argument)\n                    ? Object.keys(argument)\n                        .sort()\n                        .reduce((result, key) => {\n                        result[key] = argument[key];\n                        return result;\n                    }, {})\n                    : argument);\n                const maybeJob = runs.get(argumentJson);\n                if (maybeJob) {\n                    return maybeJob;\n                }\n                const run = handler(argument, context).pipe(replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n                runs.set(argumentJson, run);\n                return run;\n            };\n            return Object.assign(newHandler, handler, options || {});\n        };\n    }\n    strategy.memoize = memoize;\n})(strategy = exports.strategy || (exports.strategy = {}));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,QAAR,GAAmB,KAAK,CAAxB;;AACA,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,YAAD,CAAtB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB,C,CACA;;;AACA,IAAIF,QAAJ;;AACA,CAAC,UAAUA,QAAV,EAAoB;EACjB;AACJ;AACA;EACI,SAASM,SAAT,GAAqB;IACjB,IAAIC,MAAM,GAAG,CAAC,GAAGN,MAAM,CAACO,EAAX,GAAb;IACA,OAAO,CAACC,OAAD,EAAUC,OAAV,KAAsB;MACzB,MAAMC,UAAU,GAAG,CAACC,QAAD,EAAWC,OAAX,KAAuB;QACtC,MAAMC,QAAQ,GAAGP,MAAjB;QACAA,MAAM,GAAG,CAAC,GAAGN,MAAM,CAACc,MAAX,EAAmBD,QAAQ,CAACE,IAAT,CAAc,CAAC,GAAGb,WAAW,CAACc,cAAhB,GAAd,CAAnB,EAAqE,IAAIhB,MAAM,CAACiB,UAAX,CAAuBC,CAAD,IAAOV,OAAO,CAACG,QAAD,EAAWC,OAAX,CAAP,CAA2BO,SAA3B,CAAqCD,CAArC,CAA7B,CAArE,EAA4IH,IAA5I,CAAiJ,CAAC,GAAGb,WAAW,CAACkB,WAAhB,EAA6B,CAA7B,CAAjJ,CAAT;QACA,OAAOd,MAAP;MACH,CAJD;;MAKA,OAAOX,MAAM,CAAC0B,MAAP,CAAcX,UAAd,EAA0B;QAC7BY,cAAc,EAAE3B,MAAM,CAAC0B,MAAP,CAAc,EAAd,EAAkBb,OAAO,CAACc,cAA1B,EAA0Cb,OAA1C;MADa,CAA1B,CAAP;IAGH,CATD;EAUH;;EACDV,QAAQ,CAACM,SAAT,GAAqBA,SAArB;EACA;AACJ;AACA;AACA;AACA;;EACI,SAASkB,KAAT,CAAeC,cAAc,GAAG,KAAhC,EAAuC;IACnC,IAAIC,UAAU,GAAG,IAAIzB,MAAM,CAAC0B,OAAX,EAAjB;IACA,IAAIC,GAAG,GAAG,IAAV;IACA,IAAIC,KAAK,GAAG,IAAZ;IACA,OAAO,CAACpB,OAAD,EAAUC,OAAV,KAAsB;MACzB,MAAMC,UAAU,GAAG,CAACC,QAAD,EAAWC,OAAX,KAAuB;QACtC;QACA,MAAMiB,YAAY,GAAGjB,OAAO,CAACa,UAAR,CAAmBN,SAAnB,CAA6BM,UAA7B,CAArB;;QACA,IAAIE,GAAJ,EAAS;UACL,OAAO,CAAC,GAAG3B,MAAM,CAACc,MAAX,GACP;UACA,CAAC,GAAGd,MAAM,CAACO,EAAX,EAAeqB,KAAf,CAFO,EAEgBD,GAFhB,EAEqBZ,IAFrB,CAE0B,CAAC,GAAGb,WAAW,CAAC4B,QAAhB,EAA0B,MAAMD,YAAY,CAACE,WAAb,EAAhC,CAF1B,CAAP;QAGH;;QACDJ,GAAG,GAAGnB,OAAO,CAACG,QAAD,EAAW,EAAE,GAAGC,OAAL;UAAca,UAAU,EAAEA,UAAU,CAACO,YAAX;QAA1B,CAAX,CAAP,CAAyEjB,IAAzE,CAA8E,CAAC,GAAGb,WAAW,CAAC+B,GAAhB,EAAsBC,OAAD,IAAa;UAClH,IAAIA,OAAO,CAACC,IAAR,IAAgB/B,KAAK,CAACgC,sBAAN,CAA6BC,KAA7C,IACAH,OAAO,CAACC,IAAR,IAAgB/B,KAAK,CAACgC,sBAAN,CAA6BE,OAD7C,IAEAJ,OAAO,CAACC,IAAR,IAAgB/B,KAAK,CAACgC,sBAAN,CAA6BG,GAFjD,EAEsD;YAClDX,KAAK,GAAGM,OAAR;UACH;QACJ,CANmF,EAMjFM,SANiF,EAMtE,MAAM;UAChBX,YAAY,CAACE,WAAb;UACAN,UAAU,GAAG,IAAIzB,MAAM,CAAC0B,OAAX,EAAb;UACAC,GAAG,GAAG,IAAN;QACH,CAVmF,CAA9E,EAUFH,cAAc,GAAG,CAAC,GAAGtB,WAAW,CAACkB,WAAhB,GAAH,GAAoC,CAAC,GAAGlB,WAAW,CAACuC,KAAhB,GAVhD,CAAN;QAWA,OAAOd,GAAP;MACH,CApBD;;MAqBA,OAAOhC,MAAM,CAAC0B,MAAP,CAAcX,UAAd,EAA0BF,OAA1B,EAAmCC,OAAO,IAAI,EAA9C,CAAP;IACH,CAvBD;EAwBH;;EACDV,QAAQ,CAACwB,KAAT,GAAiBA,KAAjB;EACA;AACJ;AACA;AACA;AACA;;EACI,SAASmB,OAAT,CAAiBlB,cAAc,GAAG,KAAlC,EAAyC;IACrC,MAAMmB,IAAI,GAAG,IAAIC,GAAJ,EAAb;IACA,OAAO,CAACpC,OAAD,EAAUC,OAAV,KAAsB;MACzB,MAAMC,UAAU,GAAG,CAACC,QAAD,EAAWC,OAAX,KAAuB;QACtC,MAAMiC,YAAY,GAAGC,IAAI,CAACC,SAAL,CAAe,CAAC,GAAG5C,MAAM,CAAC6C,YAAX,EAAyBrC,QAAzB,IAC9BhB,MAAM,CAACsD,IAAP,CAAYtC,QAAZ,EACGuC,IADH,GAEGC,MAFH,CAEU,CAACC,MAAD,EAASC,GAAT,KAAiB;UACzBD,MAAM,CAACC,GAAD,CAAN,GAAc1C,QAAQ,CAAC0C,GAAD,CAAtB;UACA,OAAOD,MAAP;QACH,CALC,EAKC,EALD,CAD8B,GAO9BzC,QAPe,CAArB;QAQA,MAAM2C,QAAQ,GAAGX,IAAI,CAACY,GAAL,CAASV,YAAT,CAAjB;;QACA,IAAIS,QAAJ,EAAc;UACV,OAAOA,QAAP;QACH;;QACD,MAAM3B,GAAG,GAAGnB,OAAO,CAACG,QAAD,EAAWC,OAAX,CAAP,CAA2BG,IAA3B,CAAgCS,cAAc,GAAG,CAAC,GAAGtB,WAAW,CAACkB,WAAhB,GAAH,GAAoC,CAAC,GAAGlB,WAAW,CAACuC,KAAhB,GAAlF,CAAZ;QACAE,IAAI,CAACa,GAAL,CAASX,YAAT,EAAuBlB,GAAvB;QACA,OAAOA,GAAP;MACH,CAhBD;;MAiBA,OAAOhC,MAAM,CAAC0B,MAAP,CAAcX,UAAd,EAA0BF,OAA1B,EAAmCC,OAAO,IAAI,EAA9C,CAAP;IACH,CAnBD;EAoBH;;EACDV,QAAQ,CAAC2C,OAAT,GAAmBA,OAAnB;AACH,CAlFD,EAkFG3C,QAAQ,GAAGF,OAAO,CAACE,QAAR,KAAqBF,OAAO,CAACE,QAAR,GAAmB,EAAxC,CAlFd"},"metadata":{},"sourceType":"script"}