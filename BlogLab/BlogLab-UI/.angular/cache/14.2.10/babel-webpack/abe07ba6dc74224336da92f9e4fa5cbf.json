{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  URL\n} = require('url'); // Find the longest registry key that is used for some kind of auth\n// in the options.\n\n\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri); // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, :_password and :username, or\n  // :certfile and :keyfile\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n\n  let regKey = `//${parsed.host}${parsed.pathname}`;\n\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts)) {\n      return regKey;\n    } // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n\n\n    regKey = regKey.replace(/([^/]+|\\/)$/, '');\n  }\n};\n\nconst hasAuth = (regKey, opts) => opts[`${regKey}:_authToken`] || opts[`${regKey}:_auth`] || opts[`${regKey}:username`] && opts[`${regKey}:_password`] || opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`];\n\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a);\n  const parsedB = new URL(b);\n  return parsedA.host === parsedB.host;\n};\n\nconst getRegistry = opts => {\n  const {\n    spec\n  } = opts;\n  const {\n    scope: specScope,\n    subSpec\n  } = spec ? npa(spec) : {};\n  const subSpecScope = subSpec && subSpec.scope;\n  const scope = subSpec ? subSpecScope : specScope;\n  const scopeReg = scope && opts[`${scope}:registry`];\n  return scopeReg || opts.registry;\n};\n\nconst maybeReadFile = file => {\n  try {\n    return fs.readFileSync(file, 'utf8');\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er;\n    }\n\n    return null;\n  }\n};\n\nconst getAuth = (uri, opts = {}) => {\n  const {\n    forceAuth\n  } = opts;\n\n  if (!uri) {\n    throw new Error('URI is required');\n  }\n\n  const regKey = regKeyFromURI(uri, forceAuth || opts); // we are only allowed to use what's in forceAuth if specified\n\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth,\n      certfile: forceAuth.certfile,\n      keyfile: forceAuth.keyfile\n    });\n  } // no auth for this URI, but might have it for the registry\n\n\n  if (!regKey) {\n    const registry = getRegistry(opts);\n\n    if (registry && uri !== registry && sameHost(uri, registry)) {\n      return getAuth(registry, opts);\n    } else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts);\n      return new Auth({\n        scopeAuthKey\n      });\n    }\n  }\n\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth,\n    [`${regKey}:certfile`]: certfile,\n    [`${regKey}:keyfile`]: keyfile\n  } = opts;\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password,\n    certfile,\n    keyfile\n  });\n};\n\nclass Auth {\n  constructor({\n    token,\n    auth,\n    username,\n    password,\n    scopeAuthKey,\n    certfile,\n    keyfile\n  }) {\n    this.scopeAuthKey = scopeAuthKey;\n    this.token = null;\n    this.auth = null;\n    this.isBasicAuth = false;\n    this.cert = null;\n    this.key = null;\n\n    if (token) {\n      this.token = token;\n    } else if (auth) {\n      this.auth = auth;\n    } else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8');\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64');\n      this.isBasicAuth = true;\n    } // mTLS may be used in conjunction with another auth method above\n\n\n    if (certfile && keyfile) {\n      const cert = maybeReadFile(certfile, 'utf-8');\n      const key = maybeReadFile(keyfile, 'utf-8');\n\n      if (cert && key) {\n        this.cert = cert;\n        this.key = key;\n      }\n    }\n  }\n\n}\n\nmodule.exports = getAuth;","map":{"version":3,"names":["fs","require","npa","URL","regKeyFromURI","uri","opts","parsed","regKey","host","pathname","length","hasAuth","replace","sameHost","a","b","parsedA","parsedB","getRegistry","spec","scope","specScope","subSpec","subSpecScope","scopeReg","registry","maybeReadFile","file","readFileSync","er","code","getAuth","forceAuth","Error","Auth","scopeAuthKey","token","_authToken","username","password","_password","auth","_auth","certfile","keyfile","constructor","isBasicAuth","cert","key","p","Buffer","from","toString","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/npm-registry-fetch/lib/auth.js"],"sourcesContent":["'use strict'\nconst fs = require('fs')\nconst npa = require('npm-package-arg')\nconst { URL } = require('url')\n\n// Find the longest registry key that is used for some kind of auth\n// in the options.\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri)\n  // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, :_password and :username, or\n  // :certfile and :keyfile\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n  let regKey = `//${parsed.host}${parsed.pathname}`\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts)) {\n      return regKey\n    }\n\n    // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n    regKey = regKey.replace(/([^/]+|\\/)$/, '')\n  }\n}\n\nconst hasAuth = (regKey, opts) => (\n  opts[`${regKey}:_authToken`] ||\n  opts[`${regKey}:_auth`] ||\n  opts[`${regKey}:username`] && opts[`${regKey}:_password`] ||\n  opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`]\n)\n\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a)\n  const parsedB = new URL(b)\n  return parsedA.host === parsedB.host\n}\n\nconst getRegistry = opts => {\n  const { spec } = opts\n  const { scope: specScope, subSpec } = spec ? npa(spec) : {}\n  const subSpecScope = subSpec && subSpec.scope\n  const scope = subSpec ? subSpecScope : specScope\n  const scopeReg = scope && opts[`${scope}:registry`]\n  return scopeReg || opts.registry\n}\n\nconst maybeReadFile = file => {\n  try {\n    return fs.readFileSync(file, 'utf8')\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er\n    }\n    return null\n  }\n}\n\nconst getAuth = (uri, opts = {}) => {\n  const { forceAuth } = opts\n  if (!uri) {\n    throw new Error('URI is required')\n  }\n  const regKey = regKeyFromURI(uri, forceAuth || opts)\n\n  // we are only allowed to use what's in forceAuth if specified\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth,\n      certfile: forceAuth.certfile,\n      keyfile: forceAuth.keyfile,\n    })\n  }\n\n  // no auth for this URI, but might have it for the registry\n  if (!regKey) {\n    const registry = getRegistry(opts)\n    if (registry && uri !== registry && sameHost(uri, registry)) {\n      return getAuth(registry, opts)\n    } else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts)\n      return new Auth({ scopeAuthKey })\n    }\n  }\n\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth,\n    [`${regKey}:certfile`]: certfile,\n    [`${regKey}:keyfile`]: keyfile,\n  } = opts\n\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password,\n    certfile,\n    keyfile,\n  })\n}\n\nclass Auth {\n  constructor ({ token, auth, username, password, scopeAuthKey, certfile, keyfile }) {\n    this.scopeAuthKey = scopeAuthKey\n    this.token = null\n    this.auth = null\n    this.isBasicAuth = false\n    this.cert = null\n    this.key = null\n    if (token) {\n      this.token = token\n    } else if (auth) {\n      this.auth = auth\n    } else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8')\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64')\n      this.isBasicAuth = true\n    }\n    // mTLS may be used in conjunction with another auth method above\n    if (certfile && keyfile) {\n      const cert = maybeReadFile(certfile, 'utf-8')\n      const key = maybeReadFile(keyfile, 'utf-8')\n      if (cert && key) {\n        this.cert = cert\n        this.key = key\n      }\n    }\n  }\n}\n\nmodule.exports = getAuth\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}