{"ast":null,"code":"// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set(['github.com', 'gist.github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org']); // we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\n\nconst {\n  parse\n} = require('url'); // eslint-disable-line node/no-deprecated-api\n\n\nconst path = require('path');\n\nconst getRevs = require('./revs.js');\n\nconst spawn = require('./spawn.js');\n\nconst {\n  isWindows\n} = require('./utils.js');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst fs = require('fs');\n\nconst mkdirp = require('mkdirp');\n\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) => getRevs(repo, opts).then(revs => clone(repo, revs, ref, resolveRef(revs, ref, opts), target || defaultTarget(repo, opts.cwd), opts));\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow;\n  }\n\n  return shallowHosts.has(parse(repo).host);\n};\n\nconst defaultTarget = (repo,\n/* istanbul ignore next */\ncwd = process.cwd()) => path.resolve(cwd, path.basename(repo.replace(/[/\\\\]?\\.git$/, '')));\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts);\n  }\n\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts);\n  }\n\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts);\n  }\n\n  return other(repo, revDoc, target, opts);\n};\n\nconst resolveRef = (revs, ref, opts) => {\n  const {\n    spec = {}\n  } = opts;\n  ref = spec.gitCommittish || ref;\n  /* istanbul ignore next - will fail anyway, can't pull */\n\n  if (!revs) {\n    return null;\n  }\n\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts);\n  }\n\n  if (!ref) {\n    return revs.refs.HEAD;\n  }\n\n  if (revs.refs[ref]) {\n    return revs.refs[ref];\n  }\n\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]];\n  }\n\n  return null;\n}; // pull request or some other kind of advertised ref\n\n\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts);\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef].concat(shallow ? ['--depth=1'] : []);\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(['init'])).then(() => isWindows(opts) ? git(['config', '--local', '--add', 'core.longpaths', 'true']) : null).then(() => git(['remote', 'add', 'origin', repo])).then(() => git(fetchOrigin)).then(() => git(['checkout', revDoc.sha])).then(() => updateSubmodules(target, opts)).then(() => revDoc.sha);\n}; // tag or branches.  use -b\n\n\nconst branch = (repo, revDoc, target, opts) => {\n  const args = ['clone', '-b', revDoc.ref, repo, target, '--recurse-submodules'];\n\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n\n  return spawn(args, opts).then(() => revDoc.sha);\n}; // just the head.  clone it\n\n\nconst plain = (repo, revDoc, target, opts) => {\n  const args = ['clone', repo, target, '--recurse-submodules'];\n\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n\n  return spawn(args, opts).then(() => revDoc.sha);\n};\n\nconst updateSubmodules = (target, opts) => new Promise(resolve => fs.stat(target + '/.gitmodules', er => {\n  if (er) {\n    return resolve(null);\n  }\n\n  return resolve(spawn(['submodule', 'update', '-q', '--init', '--recursive'], { ...opts,\n    cwd: target\n  }));\n}));\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : [];\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git'];\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(cloneArgs.concat(lp))).then(() => git(['init'])).then(() => git(['checkout', ref])).then(() => updateSubmodules(target, opts)).then(() => git(['rev-parse', '--revs-only', 'HEAD'])).then(({\n    stdout\n  }) => stdout.trim());\n};","map":{"version":3,"names":["shallowHosts","Set","parse","require","path","getRevs","spawn","isWindows","pickManifest","fs","mkdirp","module","exports","repo","ref","target","opts","then","revs","clone","resolveRef","defaultTarget","cwd","maybeShallow","gitShallow","has","host","process","resolve","basename","replace","revDoc","unresolved","sha","refs","HEAD","plain","type","branch","other","spec","gitCommittish","gitRange","shas","shallow","fetchOrigin","rawRef","concat","git","args","updateSubmodules","push","Promise","stat","er","lp","cloneArgs","stdout","trim"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@npmcli/git/lib/clone.js"],"sourcesContent":["// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set([\n  'github.com',\n  'gist.github.com',\n  'gitlab.com',\n  'bitbucket.com',\n  'bitbucket.org',\n])\n// we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\nconst { parse } = require('url') // eslint-disable-line node/no-deprecated-api\nconst path = require('path')\n\nconst getRevs = require('./revs.js')\nconst spawn = require('./spawn.js')\nconst { isWindows } = require('./utils.js')\n\nconst pickManifest = require('npm-pick-manifest')\nconst fs = require('fs')\nconst mkdirp = require('mkdirp')\n\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) =>\n  getRevs(repo, opts).then(revs => clone(\n    repo,\n    revs,\n    ref,\n    resolveRef(revs, ref, opts),\n    target || defaultTarget(repo, opts.cwd),\n    opts\n  ))\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow\n  }\n  return shallowHosts.has(parse(repo).host)\n}\n\nconst defaultTarget = (repo, /* istanbul ignore next */ cwd = process.cwd()) =>\n  path.resolve(cwd, path.basename(repo.replace(/[/\\\\]?\\.git$/, '')))\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts)\n  }\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts)\n  }\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts)\n  }\n  return other(repo, revDoc, target, opts)\n}\n\nconst resolveRef = (revs, ref, opts) => {\n  const { spec = {} } = opts\n  ref = spec.gitCommittish || ref\n  /* istanbul ignore next - will fail anyway, can't pull */\n  if (!revs) {\n    return null\n  }\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts)\n  }\n  if (!ref) {\n    return revs.refs.HEAD\n  }\n  if (revs.refs[ref]) {\n    return revs.refs[ref]\n  }\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]]\n  }\n  return null\n}\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts)\n\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef]\n    .concat(shallow ? ['--depth=1'] : [])\n\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(['init']))\n    .then(() => isWindows(opts)\n      ? git(['config', '--local', '--add', 'core.longpaths', 'true'])\n      : null)\n    .then(() => git(['remote', 'add', 'origin', repo]))\n    .then(() => git(fetchOrigin))\n    .then(() => git(['checkout', revDoc.sha]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => revDoc.sha)\n}\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    '-b',\n    revDoc.ref,\n    repo,\n    target,\n    '--recurse-submodules',\n  ]\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1')\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true')\n  }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    repo,\n    target,\n    '--recurse-submodules',\n  ]\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1')\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true')\n  }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\nconst updateSubmodules = (target, opts) => new Promise(resolve =>\n  fs.stat(target + '/.gitmodules', er => {\n    if (er) {\n      return resolve(null)\n    }\n    return resolve(spawn([\n      'submodule',\n      'update',\n      '-q',\n      '--init',\n      '--recursive',\n    ], { ...opts, cwd: target }))\n  }))\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : []\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git']\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(cloneArgs.concat(lp)))\n    .then(() => git(['init']))\n    .then(() => git(['checkout', ref]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => git(['rev-parse', '--revs-only', 'HEAD']))\n    .then(({ stdout }) => stdout.trim())\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}