{"ast":null,"code":"// put javascript in here\n'use strict';\n\nconst Parser = require('jsonparse');\n\nconst Minipass = require('minipass');\n\nclass JSONStreamError extends Error {\n  constructor(err, caller) {\n    super(err.message);\n    Error.captureStackTrace(this, caller || this.constructor);\n  }\n\n  get name() {\n    return 'JSONStreamError';\n  }\n\n  set name(n) {}\n\n}\n\nconst check = (x, y) => typeof x === 'string' ? String(y) === x : x && typeof x.test === 'function' ? x.test(y) : typeof x === 'boolean' || typeof x === 'object' ? x : typeof x === 'function' ? x(y) : false;\n\nconst _parser = Symbol('_parser');\n\nconst _onValue = Symbol('_onValue');\n\nconst _onTokenOriginal = Symbol('_onTokenOriginal');\n\nconst _onToken = Symbol('_onToken');\n\nconst _onError = Symbol('_onError');\n\nconst _count = Symbol('_count');\n\nconst _path = Symbol('_path');\n\nconst _map = Symbol('_map');\n\nconst _root = Symbol('_root');\n\nconst _header = Symbol('_header');\n\nconst _footer = Symbol('_footer');\n\nconst _setHeaderFooter = Symbol('_setHeaderFooter');\n\nconst _ending = Symbol('_ending');\n\nclass JSONStream extends Minipass {\n  constructor(opts = {}) {\n    super({ ...opts,\n      objectMode: true\n    });\n    this[_ending] = false;\n    const parser = this[_parser] = new Parser();\n\n    parser.onValue = value => this[_onValue](value);\n\n    this[_onTokenOriginal] = parser.onToken;\n\n    parser.onToken = (token, value) => this[_onToken](token, value);\n\n    parser.onError = er => this[_onError](er);\n\n    this[_count] = 0;\n    this[_path] = typeof opts.path === 'string' ? opts.path.split('.').map(e => e === '$*' ? {\n      emitKey: true\n    } : e === '*' ? true : e === '' ? {\n      recurse: true\n    } : e) : Array.isArray(opts.path) && opts.path.length ? opts.path : null;\n    this[_map] = typeof opts.map === 'function' ? opts.map : null;\n    this[_root] = null;\n    this[_header] = null;\n    this[_footer] = null;\n    this[_count] = 0;\n  }\n\n  [_setHeaderFooter](key, value) {\n    // header has not been emitted yet\n    if (this[_header] !== false) {\n      this[_header] = this[_header] || {};\n      this[_header][key] = value;\n    } // footer has not been emitted yet but header has\n\n\n    if (this[_footer] !== false && this[_header] === false) {\n      this[_footer] = this[_footer] || {};\n      this[_footer][key] = value;\n    }\n  }\n\n  [_onError](er) {\n    // error will always happen during a write() call.\n    const caller = this[_ending] ? this.end : this.write;\n    this[_ending] = false;\n    return this.emit('error', new JSONStreamError(er, caller));\n  }\n\n  [_onToken](token, value) {\n    const parser = this[_parser];\n\n    this[_onTokenOriginal].call(parser, token, value);\n\n    if (parser.stack.length === 0) {\n      if (this[_root]) {\n        const root = this[_root];\n        if (!this[_path]) super.write(root);\n        this[_root] = null;\n        this[_count] = 0;\n      }\n    }\n  }\n\n  [_onValue](value) {\n    const parser = this[_parser]; // the LAST onValue encountered is the root object.\n    // just overwrite it each time.\n\n    this[_root] = value;\n    if (!this[_path]) return;\n    let i = 0; // iterates on path\n\n    let j = 0; // iterates on stack\n\n    let emitKey = false;\n    let emitPath = false;\n\n    while (i < this[_path].length) {\n      const key = this[_path][i];\n      j++;\n\n      if (key && !key.recurse) {\n        const c = j === parser.stack.length ? parser : parser.stack[j];\n        if (!c) return;\n\n        if (!check(key, c.key)) {\n          this[_setHeaderFooter](c.key, value);\n\n          return;\n        }\n\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++;\n      } else {\n        i++;\n        if (i >= this[_path].length) return;\n        const nextKey = this[_path][i];\n        if (!nextKey) return;\n\n        while (true) {\n          const c = j === parser.stack.length ? parser : parser.stack[j];\n          if (!c) return;\n\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(parser.stack[j])) parser.stack[j].value = null;\n            break;\n          } else {\n            this[_setHeaderFooter](c.key, value);\n          }\n\n          j++;\n        }\n      }\n    } // emit header\n\n\n    if (this[_header]) {\n      const header = this[_header];\n      this[_header] = false;\n      this.emit('header', header);\n    }\n\n    if (j !== parser.stack.length) return;\n    this[_count]++;\n    const actualPath = parser.stack.slice(1).map(e => e.key).concat([parser.key]);\n\n    if (value !== null && value !== undefined) {\n      const data = this[_map] ? this[_map](value, actualPath) : value;\n\n      if (data !== null && data !== undefined) {\n        const emit = emitKey || emitPath ? {\n          value: data\n        } : data;\n        if (emitKey) emit.key = parser.key;\n        if (emitPath) emit.path = actualPath;\n        super.write(emit);\n      }\n    }\n\n    if (parser.value) delete parser.value[parser.key];\n\n    for (const k of parser.stack) {\n      k.value = null;\n    }\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);else if (!Buffer.isBuffer(chunk)) return this.emit('error', new TypeError('Can only parse JSON from string or buffer input'));\n\n    this[_parser].write(chunk);\n\n    if (cb) cb();\n    return this.flowing;\n  }\n\n  end(chunk, encoding, cb) {\n    this[_ending] = true;\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    const h = this[_header];\n    this[_header] = null;\n    const f = this[_footer];\n    this[_footer] = null;\n    if (h) this.emit('header', h);\n    if (f) this.emit('footer', f);\n    return super.end();\n  }\n\n  static get JSONStreamError() {\n    return JSONStreamError;\n  }\n\n  static parse(path, map) {\n    return new JSONStream({\n      path,\n      map\n    });\n  }\n\n}\n\nmodule.exports = JSONStream;","map":{"version":3,"names":["Parser","require","Minipass","JSONStreamError","Error","constructor","err","caller","message","captureStackTrace","name","n","check","x","y","String","test","_parser","Symbol","_onValue","_onTokenOriginal","_onToken","_onError","_count","_path","_map","_root","_header","_footer","_setHeaderFooter","_ending","JSONStream","opts","objectMode","parser","onValue","value","onToken","token","onError","er","path","split","map","e","emitKey","recurse","Array","isArray","length","key","end","write","emit","call","stack","root","i","j","emitPath","c","nextKey","Object","isFrozen","header","actualPath","slice","concat","undefined","data","k","chunk","encoding","cb","Buffer","from","isBuffer","TypeError","flowing","once","h","f","parse","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/minipass-json-stream/index.js"],"sourcesContent":["// put javascript in here\n'use strict'\n\nconst Parser = require('jsonparse')\nconst Minipass = require('minipass')\n\nclass JSONStreamError extends Error {\n  constructor (err, caller) {\n    super(err.message)\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () {\n    return 'JSONStreamError'\n  }\n  set name (n) {}\n}\n\nconst check = (x, y) =>\n  typeof x === 'string' ? String(y) === x\n  : x && typeof x.test === 'function' ? x.test(y)\n  : typeof x === 'boolean' || typeof x === 'object' ? x\n  : typeof x === 'function' ? x(y)\n  : false\n\nconst _parser = Symbol('_parser')\nconst _onValue = Symbol('_onValue')\nconst _onTokenOriginal = Symbol('_onTokenOriginal')\nconst _onToken = Symbol('_onToken')\nconst _onError = Symbol('_onError')\nconst _count = Symbol('_count')\nconst _path = Symbol('_path')\nconst _map = Symbol('_map')\nconst _root = Symbol('_root')\nconst _header = Symbol('_header')\nconst _footer = Symbol('_footer')\nconst _setHeaderFooter = Symbol('_setHeaderFooter')\nconst _ending = Symbol('_ending')\n\nclass JSONStream extends Minipass {\n  constructor (opts = {}) {\n    super({\n      ...opts,\n      objectMode: true,\n    })\n\n    this[_ending] = false\n    const parser = this[_parser] = new Parser()\n    parser.onValue = value => this[_onValue](value)\n    this[_onTokenOriginal] = parser.onToken\n    parser.onToken = (token, value) => this[_onToken](token, value)\n    parser.onError = er => this[_onError](er)\n\n    this[_count] = 0\n    this[_path] = typeof opts.path === 'string'\n      ? opts.path.split('.').map(e =>\n          e === '$*' ? { emitKey: true }\n          : e === '*' ? true\n          : e === '' ? { recurse: true }\n          : e)\n      : Array.isArray(opts.path) && opts.path.length ? opts.path\n      : null\n\n    this[_map] = typeof opts.map === 'function' ? opts.map : null\n    this[_root] = null\n    this[_header] = null\n    this[_footer] = null\n    this[_count] = 0\n  }\n\n  [_setHeaderFooter] (key, value) {\n    // header has not been emitted yet\n    if (this[_header] !== false) {\n      this[_header] = this[_header] || {}\n      this[_header][key] = value\n    }\n\n    // footer has not been emitted yet but header has\n    if (this[_footer] !== false && this[_header] === false) {\n      this[_footer] = this[_footer] || {}\n      this[_footer][key] = value\n    }\n  }\n\n  [_onError] (er) {\n    // error will always happen during a write() call.\n    const caller = this[_ending] ? this.end : this.write\n    this[_ending] = false\n    return this.emit('error', new JSONStreamError(er, caller))\n  }\n\n  [_onToken] (token, value) {\n    const parser = this[_parser]\n    this[_onTokenOriginal].call(parser, token, value)\n    if (parser.stack.length === 0) {\n      if (this[_root]) {\n        const root = this[_root]\n        if (!this[_path])\n          super.write(root)\n        this[_root] = null\n        this[_count] = 0\n      }\n    }\n  }\n\n  [_onValue] (value) {\n    const parser = this[_parser]\n    // the LAST onValue encountered is the root object.\n    // just overwrite it each time.\n    this[_root] = value\n\n    if(!this[_path]) return\n\n    let i = 0 // iterates on path\n    let j  = 0 // iterates on stack\n    let emitKey = false\n    let emitPath = false\n    while (i < this[_path].length) {\n      const key = this[_path][i]\n      j++\n\n      if (key && !key.recurse) {\n        const c = (j === parser.stack.length) ? parser : parser.stack[j]\n        if (!c) return\n        if (!check(key, c.key)) {\n          this[_setHeaderFooter](c.key, value)\n          return\n        }\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++\n      } else {\n        i++\n        if (i >= this[_path].length)\n          return\n        const nextKey = this[_path][i]\n        if (!nextKey)\n          return\n        while (true) {\n          const c = (j === parser.stack.length) ? parser : parser.stack[j]\n          if (!c) return\n          if (check(nextKey, c.key)) {\n            i++\n            if (!Object.isFrozen(parser.stack[j]))\n              parser.stack[j].value = null\n            break\n          } else {\n            this[_setHeaderFooter](c.key, value)\n          }\n          j++\n        }\n      }\n    }\n\n    // emit header\n    if (this[_header]) {\n      const header = this[_header]\n      this[_header] = false\n      this.emit('header', header)\n    }\n    if (j !== parser.stack.length) return\n\n    this[_count] ++\n    const actualPath = parser.stack.slice(1)\n      .map(e => e.key).concat([parser.key])\n    if (value !== null && value !== undefined) {\n      const data = this[_map] ? this[_map](value, actualPath) : value\n      if (data !== null && data !== undefined) {\n        const emit = emitKey || emitPath ? { value: data } : data\n        if (emitKey)\n          emit.key = parser.key\n        if (emitPath)\n          emit.path = actualPath\n        super.write(emit)\n      }\n    }\n\n    if (parser.value)\n      delete parser.value[parser.key]\n\n    for (const k of parser.stack) {\n      k.value = null\n    }\n  }\n\n  write (chunk, encoding, cb) {\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = null\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n    else if (!Buffer.isBuffer(chunk))\n      return this.emit('error', new TypeError(\n        'Can only parse JSON from string or buffer input'))\n    this[_parser].write(chunk)\n    if (cb)\n      cb()\n    return this.flowing\n  }\n\n  end (chunk, encoding, cb) {\n    this[_ending] = true\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = null\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n\n    const h = this[_header]\n    this[_header] = null\n    const f = this[_footer]\n    this[_footer] = null\n    if (h)\n      this.emit('header', h)\n    if (f)\n      this.emit('footer', f)\n    return super.end()\n  }\n\n  static get JSONStreamError () { return JSONStreamError }\n  static parse (path, map) {\n    return new JSONStream({path, map})\n  }\n}\n\nmodule.exports = JSONStream\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}