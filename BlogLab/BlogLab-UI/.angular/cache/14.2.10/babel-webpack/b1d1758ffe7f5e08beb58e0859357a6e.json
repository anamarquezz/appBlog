{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst fs = require('fs');\n\nconst {\n  Readable\n} = require('stream');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  _read(batch) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.reading) return;\n      _this.reading = true;\n\n      try {\n        while (!_this.destroyed && batch > 0) {\n          const {\n            path,\n            depth,\n            files = []\n          } = _this.parent || {};\n\n          if (files.length > 0) {\n            const slice = files.splice(0, batch).map(dirent => _this._formatEntry(dirent, path));\n\n            for (const entry of yield Promise.all(slice)) {\n              if (_this.destroyed) return;\n              const entryType = yield _this._getEntryType(entry);\n\n              if (entryType === 'directory' && _this._directoryFilter(entry)) {\n                if (depth <= _this._maxDepth) {\n                  _this.parents.push(_this._exploreDir(entry.fullPath, depth + 1));\n                }\n\n                if (_this._wantsDir) {\n                  _this.push(entry);\n\n                  batch--;\n                }\n              } else if ((entryType === 'file' || _this._includeAsFile(entry)) && _this._fileFilter(entry)) {\n                if (_this._wantsFile) {\n                  _this.push(entry);\n\n                  batch--;\n                }\n              }\n            }\n          } else {\n            const parent = _this.parents.pop();\n\n            if (!parent) {\n              _this.push(null);\n\n              break;\n            }\n\n            _this.parent = yield parent;\n            if (_this.destroyed) return;\n          }\n        }\n      } catch (error) {\n        _this.destroy(error);\n      } finally {\n        _this.reading = false;\n      }\n    })();\n  }\n\n  _exploreDir(path, depth) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let files;\n\n      try {\n        files = yield readdir(path, _this2._rdOptions);\n      } catch (error) {\n        _this2._onError(error);\n      }\n\n      return {\n        files,\n        depth,\n        path\n      };\n    })();\n  }\n\n  _formatEntry(dirent, path) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let entry;\n\n      try {\n        const basename = _this3._isDirent ? dirent.name : dirent;\n        const fullPath = sysPath.resolve(sysPath.join(path, basename));\n        entry = {\n          path: sysPath.relative(_this3._root, fullPath),\n          fullPath,\n          basename\n        };\n        entry[_this3._statsProp] = _this3._isDirent ? dirent : yield _this3._stat(fullPath);\n      } catch (err) {\n        _this3._onError(err);\n      }\n\n      return entry;\n    })();\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  _getEntryType(entry) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // entry may be undefined, because a warning or an error were emitted\n      // and the statsProp is undefined\n      const stats = entry && entry[_this4._statsProp];\n\n      if (!stats) {\n        return;\n      }\n\n      if (stats.isFile()) {\n        return 'file';\n      }\n\n      if (stats.isDirectory()) {\n        return 'directory';\n      }\n\n      if (stats && stats.isSymbolicLink()) {\n        const full = entry.fullPath;\n\n        try {\n          const entryRealPath = yield realpath(full);\n          const entryRealPathStats = yield lstat(entryRealPath);\n\n          if (entryRealPathStats.isFile()) {\n            return 'file';\n          }\n\n          if (entryRealPathStats.isDirectory()) {\n            const len = entryRealPath.length;\n\n            if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n              const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n              recursiveError.code = RECURSIVE_ERROR_CODE;\n              return _this4._onError(recursiveError);\n            }\n\n            return 'directory';\n          }\n        } catch (error) {\n          _this4._onError(error);\n        }\n      }\n    })();\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":{"version":3,"names":["fs","require","Readable","sysPath","promisify","picomatch","readdir","stat","lstat","realpath","BANG","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","maj","min","process","versions","node","split","slice","map","n","Number","parseInt","wantBigintFsStats","platform","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","resolve","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp","TypeError","readdirpPromise","reject","on","promise","default","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/readdirp/index.js"],"sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}