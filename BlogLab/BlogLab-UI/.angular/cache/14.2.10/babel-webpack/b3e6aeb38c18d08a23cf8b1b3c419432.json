{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeSchemas = exports.isJsonSchema = void 0;\n\nconst utils_1 = require(\"../utils\");\n\nfunction isJsonSchema(value) {\n  return (0, utils_1.isJsonObject)(value) || value === false || value === true;\n}\n\nexports.isJsonSchema = isJsonSchema;\n/**\n * Return a schema that is the merge of all subschemas, ie. it should validate all the schemas\n * that were passed in. It is possible to make an invalid schema this way, e.g. by using\n * `mergeSchemas({ type: 'number' }, { type: 'string' })`, which will never validate.\n * @param schemas All schemas to be merged.\n */\n\nfunction mergeSchemas(...schemas) {\n  return schemas.reduce((prev, curr) => {\n    if (curr === undefined) {\n      return prev;\n    }\n\n    if (prev === false || curr === false) {\n      return false;\n    } else if (prev === true) {\n      return curr;\n    } else if (curr === true) {\n      return prev;\n    } else if (Array.isArray(prev.allOf)) {\n      if (Array.isArray(curr.allOf)) {\n        return { ...prev,\n          allOf: [...prev.allOf, ...curr.allOf]\n        };\n      } else {\n        return { ...prev,\n          allOf: [...prev.allOf, curr]\n        };\n      }\n    } else if (Array.isArray(curr.allOf)) {\n      return { ...prev,\n        allOf: [prev, ...curr.allOf]\n      };\n    } else {\n      return { ...prev,\n        allOf: [prev, curr]\n      };\n    }\n  }, true);\n}\n\nexports.mergeSchemas = mergeSchemas;","map":{"version":3,"names":["Object","defineProperty","exports","value","mergeSchemas","isJsonSchema","utils_1","require","isJsonObject","schemas","reduce","prev","curr","undefined","Array","isArray","allOf"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/json/schema/schema.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeSchemas = exports.isJsonSchema = void 0;\nconst utils_1 = require(\"../utils\");\nfunction isJsonSchema(value) {\n    return (0, utils_1.isJsonObject)(value) || value === false || value === true;\n}\nexports.isJsonSchema = isJsonSchema;\n/**\n * Return a schema that is the merge of all subschemas, ie. it should validate all the schemas\n * that were passed in. It is possible to make an invalid schema this way, e.g. by using\n * `mergeSchemas({ type: 'number' }, { type: 'string' })`, which will never validate.\n * @param schemas All schemas to be merged.\n */\nfunction mergeSchemas(...schemas) {\n    return schemas.reduce((prev, curr) => {\n        if (curr === undefined) {\n            return prev;\n        }\n        if (prev === false || curr === false) {\n            return false;\n        }\n        else if (prev === true) {\n            return curr;\n        }\n        else if (curr === true) {\n            return prev;\n        }\n        else if (Array.isArray(prev.allOf)) {\n            if (Array.isArray(curr.allOf)) {\n                return { ...prev, allOf: [...prev.allOf, ...curr.allOf] };\n            }\n            else {\n                return { ...prev, allOf: [...prev.allOf, curr] };\n            }\n        }\n        else if (Array.isArray(curr.allOf)) {\n            return { ...prev, allOf: [prev, ...curr.allOf] };\n        }\n        else {\n            return { ...prev, allOf: [prev, curr] };\n        }\n    }, true);\n}\nexports.mergeSchemas = mergeSchemas;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuBF,OAAO,CAACG,YAAR,GAAuB,KAAK,CAAnD;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,SAASF,YAAT,CAAsBF,KAAtB,EAA6B;EACzB,OAAO,CAAC,GAAGG,OAAO,CAACE,YAAZ,EAA0BL,KAA1B,KAAoCA,KAAK,KAAK,KAA9C,IAAuDA,KAAK,KAAK,IAAxE;AACH;;AACDD,OAAO,CAACG,YAAR,GAAuBA,YAAvB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,YAAT,CAAsB,GAAGK,OAAzB,EAAkC;EAC9B,OAAOA,OAAO,CAACC,MAAR,CAAe,CAACC,IAAD,EAAOC,IAAP,KAAgB;IAClC,IAAIA,IAAI,KAAKC,SAAb,EAAwB;MACpB,OAAOF,IAAP;IACH;;IACD,IAAIA,IAAI,KAAK,KAAT,IAAkBC,IAAI,KAAK,KAA/B,EAAsC;MAClC,OAAO,KAAP;IACH,CAFD,MAGK,IAAID,IAAI,KAAK,IAAb,EAAmB;MACpB,OAAOC,IAAP;IACH,CAFI,MAGA,IAAIA,IAAI,KAAK,IAAb,EAAmB;MACpB,OAAOD,IAAP;IACH,CAFI,MAGA,IAAIG,KAAK,CAACC,OAAN,CAAcJ,IAAI,CAACK,KAAnB,CAAJ,EAA+B;MAChC,IAAIF,KAAK,CAACC,OAAN,CAAcH,IAAI,CAACI,KAAnB,CAAJ,EAA+B;QAC3B,OAAO,EAAE,GAAGL,IAAL;UAAWK,KAAK,EAAE,CAAC,GAAGL,IAAI,CAACK,KAAT,EAAgB,GAAGJ,IAAI,CAACI,KAAxB;QAAlB,CAAP;MACH,CAFD,MAGK;QACD,OAAO,EAAE,GAAGL,IAAL;UAAWK,KAAK,EAAE,CAAC,GAAGL,IAAI,CAACK,KAAT,EAAgBJ,IAAhB;QAAlB,CAAP;MACH;IACJ,CAPI,MAQA,IAAIE,KAAK,CAACC,OAAN,CAAcH,IAAI,CAACI,KAAnB,CAAJ,EAA+B;MAChC,OAAO,EAAE,GAAGL,IAAL;QAAWK,KAAK,EAAE,CAACL,IAAD,EAAO,GAAGC,IAAI,CAACI,KAAf;MAAlB,CAAP;IACH,CAFI,MAGA;MACD,OAAO,EAAE,GAAGL,IAAL;QAAWK,KAAK,EAAE,CAACL,IAAD,EAAOC,IAAP;MAAlB,CAAP;IACH;EACJ,CA3BM,EA2BJ,IA3BI,CAAP;AA4BH;;AACDV,OAAO,CAACE,YAAR,GAAuBA,YAAvB"},"metadata":{},"sourceType":"script"}