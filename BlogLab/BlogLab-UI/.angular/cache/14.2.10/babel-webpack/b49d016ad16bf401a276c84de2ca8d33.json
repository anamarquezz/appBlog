{"ast":null,"code":"var _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Fetcher = require('./fetcher.js');\n\nconst RemoteFetcher = require('./remote.js');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst pacoteVersion = require('../package.json').version;\n\nconst removeTrailingSlashes = require('./util/trailing-slashes.js');\n\nconst npa = require('npm-package-arg');\n\nconst rpj = require('read-package-json-fast');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst ssri = require('ssri');\n\nconst crypto = require('crypto'); // Corgis are cute. üêïüê∂\n\n\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\nconst fullDoc = 'application/json';\n\nconst fetch = require('npm-registry-fetch');\n\nconst _headers = Symbol('_headers');\n\nclass RegistryFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n\n    this.packumentCache = this.opts.packumentCache || null; // handle case when npm-package-arg guesses wrong.\n\n    if (this.spec.type === 'tag' && this.spec.rawSpec === '' && this.defaultTag !== 'latest') {\n      this.spec = npa(`${this.spec.name}@${this.defaultTag}`);\n    }\n\n    this.registry = fetch.pickRegistry(spec, opts);\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' + this.spec.escapedName;\n    const parsed = new URL(this.registry);\n    const regKey = `//${parsed.host}${parsed.pathname}`; // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`];\n    } // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n\n  }\n\n  resolve() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // fetching the manifest sets resolved and (if present) integrity\n      yield _this.manifest();\n\n      if (!_this.resolved) {\n        throw Object.assign(new Error('Invalid package manifest: no `dist.tarball` field'), {\n          package: _this.spec.toString()\n        });\n      }\n\n      return _this.resolved;\n    })();\n  }\n\n  [_headers]() {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc\n    };\n  }\n\n  packument() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // note this might be either an in-flight promise for a request,\n      // or the actual packument, but we never want to make more than\n      // one request at a time for the same thing regardless.\n      if (_this2.packumentCache && _this2.packumentCache.has(_this2.packumentUrl)) {\n        return _this2.packumentCache.get(_this2.packumentUrl);\n      } // npm-registry-fetch the packument\n      // set the appropriate header for corgis if fullMetadata isn't set\n      // return the res.json() promise\n\n\n      try {\n        const res = yield fetch(_this2.packumentUrl, { ..._this2.opts,\n          headers: _this2[_headers](),\n          spec: _this2.spec,\n          // never check integrity for packuments themselves\n          integrity: null\n        });\n        const packument = yield res.json();\n        packument._cached = res.headers.has('x-local-cache');\n        packument._contentLength = +res.headers.get('content-length');\n\n        if (_this2.packumentCache) {\n          _this2.packumentCache.set(_this2.packumentUrl, packument);\n        }\n\n        return packument;\n      } catch (err) {\n        if (_this2.packumentCache) {\n          _this2.packumentCache.delete(_this2.packumentUrl);\n        }\n\n        if (err.code !== 'E404' || _this2.fullMetadata) {\n          throw err;\n        } // possible that corgis are not supported by this registry\n\n\n        _this2.fullMetadata = true;\n        return _this2.packument();\n      }\n    })();\n  }\n\n  manifest() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.package) {\n        return _this3.package;\n      }\n\n      const packument = yield _this3.packument();\n      let mani = yield pickManifest(packument, _this3.spec.fetchSpec, { ..._this3.opts,\n        defaultTag: _this3.defaultTag,\n        before: _this3.before\n      });\n      mani = rpj.normalize(mani);\n      /* XXX add ETARGET and E403 revalidation of cached packuments here */\n      // add _resolved and _integrity from dist object\n\n      const {\n        dist\n      } = mani;\n\n      if (dist) {\n        _this3.resolved = mani._resolved = dist.tarball;\n        mani._from = _this3.from;\n        const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ..._this3.opts\n        }) : null;\n\n        if (distIntegrity) {\n          if (_this3.integrity && !_this3.integrity.match(distIntegrity)) {\n            // only bork if they have algos in common.\n            // otherwise we end up breaking if we have saved a sha512\n            // previously for the tarball, but the manifest only\n            // provides a sha1, which is possible for older publishes.\n            // Otherwise, this is almost certainly a case of holding it\n            // wrong, and will result in weird or insecure behavior\n            // later on when building package tree.\n            for (const algo of Object.keys(_this3.integrity)) {\n              if (distIntegrity[algo]) {\n                throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: ` + `wanted ${_this3.integrity} but got ${distIntegrity}.`), {\n                  code: 'EINTEGRITY'\n                });\n              }\n            }\n          } // made it this far, the integrity is worthwhile.  accept it.\n          // the setter here will take care of merging it into what we already\n          // had.\n\n\n          _this3.integrity = distIntegrity;\n        }\n      }\n\n      if (_this3.integrity) {\n        mani._integrity = String(_this3.integrity);\n\n        if (dist.signatures) {\n          if (_this3.opts.verifySignatures) {\n            // validate and throw on error, then set _signatures\n            const message = `${mani._id}:${mani._integrity}`;\n\n            for (const signature of dist.signatures) {\n              const publicKey = _this3.registryKeys && _this3.registryKeys.filter(key => key.keyid === signature.keyid)[0];\n\n              if (!publicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + 'but no corresponding public key can be found'), {\n                  code: 'EMISSINGSIGNATUREKEY'\n                });\n              }\n\n              const validPublicKey = !publicKey.expires || Date.parse(publicKey.expires) > Date.now();\n\n              if (!validPublicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + `but the corresponding public key has expired ${publicKey.expires}`), {\n                  code: 'EEXPIREDSIGNATUREKEY'\n                });\n              }\n\n              const verifier = crypto.createVerify('SHA256');\n              verifier.write(message);\n              verifier.end();\n              const valid = verifier.verify(publicKey.pemkey, signature.sig, 'base64');\n\n              if (!valid) {\n                throw Object.assign(new Error(`${mani._id} has an invalid registry signature with ` + `keyid: ${publicKey.keyid} and signature: ${signature.sig}`), {\n                  code: 'EINTEGRITYSIGNATURE',\n                  keyid: publicKey.keyid,\n                  signature: signature.sig,\n                  resolved: mani._resolved,\n                  integrity: mani._integrity\n                });\n              }\n            }\n\n            mani._signatures = dist.signatures;\n          } else {\n            mani._signatures = dist.signatures;\n          }\n        }\n      }\n\n      _this3.package = mani;\n      return _this3.package;\n    })();\n  }\n\n  [_tarballFromResolved]() {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, { ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`\n    })[_tarballFromResolved]();\n  }\n\n  get types() {\n    return ['tag', 'version', 'range'];\n  }\n\n}\n\nmodule.exports = RegistryFetcher;","map":{"version":3,"names":["Fetcher","require","RemoteFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","removeTrailingSlashes","npa","rpj","pickManifest","ssri","crypto","corgiDoc","fullDoc","fetch","_headers","RegistryFetcher","constructor","spec","opts","packumentCache","type","rawSpec","defaultTag","name","registry","pickRegistry","packumentUrl","escapedName","parsed","URL","regKey","host","pathname","registryKeys","resolve","manifest","resolved","Object","assign","Error","package","toString","userAgent","process","headers","accept","fullMetadata","packument","has","get","res","integrity","json","_cached","_contentLength","set","err","delete","code","mani","fetchSpec","before","normalize","dist","_resolved","tarball","_from","from","distIntegrity","parse","shasum","fromHex","match","algo","keys","_integrity","String","signatures","verifySignatures","message","_id","signature","publicKey","filter","key","keyid","validPublicKey","expires","Date","now","verifier","createVerify","write","end","valid","verify","pemkey","sig","_signatures","pkgid","types","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/pacote/lib/registry.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst RemoteFetcher = require('./remote.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst removeTrailingSlashes = require('./util/trailing-slashes.js')\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst pickManifest = require('npm-pick-manifest')\nconst ssri = require('ssri')\nconst crypto = require('crypto')\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'\nconst fullDoc = 'application/json'\n\nconst fetch = require('npm-registry-fetch')\n\nconst _headers = Symbol('_headers')\nclass RegistryFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null\n\n    // handle case when npm-package-arg guesses wrong.\n    if (this.spec.type === 'tag' &&\n        this.spec.rawSpec === '' &&\n        this.defaultTag !== 'latest') {\n      this.spec = npa(`${this.spec.name}@${this.defaultTag}`)\n    }\n    this.registry = fetch.pickRegistry(spec, opts)\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' +\n      this.spec.escapedName\n\n    const parsed = new URL(this.registry)\n    const regKey = `//${parsed.host}${parsed.pathname}`\n    // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`]\n    }\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  async resolve () {\n    // fetching the manifest sets resolved and (if present) integrity\n    await this.manifest()\n    if (!this.resolved) {\n      throw Object.assign(\n        new Error('Invalid package manifest: no `dist.tarball` field'),\n        { package: this.spec.toString() }\n      )\n    }\n    return this.resolved\n  }\n\n  [_headers] () {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc,\n    }\n  }\n\n  async packument () {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) {\n      return this.packumentCache.get(this.packumentUrl)\n    }\n\n    // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n    try {\n      const res = await fetch(this.packumentUrl, {\n        ...this.opts,\n        headers: this[_headers](),\n        spec: this.spec,\n        // never check integrity for packuments themselves\n        integrity: null,\n      })\n      const packument = await res.json()\n      packument._cached = res.headers.has('x-local-cache')\n      packument._contentLength = +res.headers.get('content-length')\n      if (this.packumentCache) {\n        this.packumentCache.set(this.packumentUrl, packument)\n      }\n      return packument\n    } catch (err) {\n      if (this.packumentCache) {\n        this.packumentCache.delete(this.packumentUrl)\n      }\n      if (err.code !== 'E404' || this.fullMetadata) {\n        throw err\n      }\n      // possible that corgis are not supported by this registry\n      this.fullMetadata = true\n      return this.packument()\n    }\n  }\n\n  async manifest () {\n    if (this.package) {\n      return this.package\n    }\n\n    const packument = await this.packument()\n    let mani = await pickManifest(packument, this.spec.fetchSpec, {\n      ...this.opts,\n      defaultTag: this.defaultTag,\n      before: this.before,\n    })\n    mani = rpj.normalize(mani)\n    /* XXX add ETARGET and E403 revalidation of cached packuments here */\n\n    // add _resolved and _integrity from dist object\n    const { dist } = mani\n    if (dist) {\n      this.resolved = mani._resolved = dist.tarball\n      mani._from = this.from\n      const distIntegrity = dist.integrity ? ssri.parse(dist.integrity)\n        : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ...this.opts })\n        : null\n      if (distIntegrity) {\n        if (this.integrity && !this.integrity.match(distIntegrity)) {\n          // only bork if they have algos in common.\n          // otherwise we end up breaking if we have saved a sha512\n          // previously for the tarball, but the manifest only\n          // provides a sha1, which is possible for older publishes.\n          // Otherwise, this is almost certainly a case of holding it\n          // wrong, and will result in weird or insecure behavior\n          // later on when building package tree.\n          for (const algo of Object.keys(this.integrity)) {\n            if (distIntegrity[algo]) {\n              throw Object.assign(new Error(\n                `Integrity checksum failed when using ${algo}: ` +\n                `wanted ${this.integrity} but got ${distIntegrity}.`\n              ), { code: 'EINTEGRITY' })\n            }\n          }\n        }\n        // made it this far, the integrity is worthwhile.  accept it.\n        // the setter here will take care of merging it into what we already\n        // had.\n        this.integrity = distIntegrity\n      }\n    }\n    if (this.integrity) {\n      mani._integrity = String(this.integrity)\n      if (dist.signatures) {\n        if (this.opts.verifySignatures) {\n          // validate and throw on error, then set _signatures\n          const message = `${mani._id}:${mani._integrity}`\n          for (const signature of dist.signatures) {\n            const publicKey = this.registryKeys &&\n              this.registryKeys.filter(key => (key.keyid === signature.keyid))[0]\n            if (!publicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  'but no corresponding public key can be found'\n              ), { code: 'EMISSINGSIGNATUREKEY' })\n            }\n            const validPublicKey =\n              !publicKey.expires || (Date.parse(publicKey.expires) > Date.now())\n            if (!validPublicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  `but the corresponding public key has expired ${publicKey.expires}`\n              ), { code: 'EEXPIREDSIGNATUREKEY' })\n            }\n            const verifier = crypto.createVerify('SHA256')\n            verifier.write(message)\n            verifier.end()\n            const valid = verifier.verify(\n              publicKey.pemkey,\n              signature.sig,\n              'base64'\n            )\n            if (!valid) {\n              throw Object.assign(new Error(\n                  `${mani._id} has an invalid registry signature with ` +\n                  `keyid: ${publicKey.keyid} and signature: ${signature.sig}`\n              ), {\n                code: 'EINTEGRITYSIGNATURE',\n                keyid: publicKey.keyid,\n                signature: signature.sig,\n                resolved: mani._resolved,\n                integrity: mani._integrity,\n              })\n            }\n          }\n          mani._signatures = dist.signatures\n        } else {\n          mani._signatures = dist.signatures\n        }\n      }\n    }\n    this.package = mani\n    return this.package\n  }\n\n  [_tarballFromResolved] () {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`,\n    })[_tarballFromResolved]()\n  }\n\n  get types () {\n    return [\n      'tag',\n      'version',\n      'range',\n    ]\n  }\n}\nmodule.exports = RegistryFetcher\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}