{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst json_1 = require(\"../../json\");\n\nconst api_1 = require(\"./api\");\n\nconst exception_1 = require(\"./exception\");\n\nclass JobArgumentSchemaValidationError extends json_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Argument failed to validate. Errors: ');\n  }\n\n}\n\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\n\nclass JobInboundMessageSchemaValidationError extends json_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Inbound Message failed to validate. Errors: ');\n  }\n\n}\n\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\n\nclass JobOutputSchemaValidationError extends json_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Output failed to validate. Errors: ');\n  }\n\n}\n\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\n\nfunction _jobShare() {\n  // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n  // ReplaySubject.\n  return source => {\n    let refCount = 0;\n    let subject;\n    let hasError = false;\n    let isComplete = false;\n    let subscription;\n    return new rxjs_1.Observable(subscriber => {\n      let innerSub;\n      refCount++;\n\n      if (!subject) {\n        subject = new rxjs_1.Subject();\n        innerSub = subject.subscribe(subscriber);\n        subscription = source.subscribe({\n          next(value) {\n            subject.next(value);\n          },\n\n          error(err) {\n            hasError = true;\n            subject.error(err);\n          },\n\n          complete() {\n            isComplete = true;\n            subject.complete();\n          }\n\n        });\n      } else {\n        innerSub = subject.subscribe(subscriber);\n      }\n\n      return () => {\n        refCount--;\n        innerSub.unsubscribe();\n\n        if (subscription && refCount === 0 && (isComplete || hasError)) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\n\n\nclass SimpleScheduler {\n  constructor(_jobRegistry, _schemaRegistry = new json_1.schema.CoreSchemaRegistry()) {\n    this._jobRegistry = _jobRegistry;\n    this._schemaRegistry = _schemaRegistry;\n    this._internalJobDescriptionMap = new Map();\n    this._queue = [];\n    this._pauseCounter = 0;\n  }\n\n  _getInternalDescription(name) {\n    const maybeHandler = this._internalJobDescriptionMap.get(name);\n\n    if (maybeHandler !== undefined) {\n      return (0, rxjs_1.of)(maybeHandler);\n    }\n\n    const handler = this._jobRegistry.get(name);\n\n    return handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler === null) {\n        return (0, rxjs_1.of)(null);\n      }\n\n      const description = { // Make a copy of it to be sure it's proper JSON.\n        ...JSON.parse(JSON.stringify(handler.jobDescription)),\n        name: handler.jobDescription.name || name,\n        argument: handler.jobDescription.argument || true,\n        input: handler.jobDescription.input || true,\n        output: handler.jobDescription.output || true,\n        channels: handler.jobDescription.channels || {}\n      };\n      const handlerWithExtra = Object.assign(handler.bind(undefined), {\n        jobDescription: description,\n        argumentV: this._schemaRegistry.compile(description.argument).pipe((0, operators_1.shareReplay)(1)),\n        inputV: this._schemaRegistry.compile(description.input).pipe((0, operators_1.shareReplay)(1)),\n        outputV: this._schemaRegistry.compile(description.output).pipe((0, operators_1.shareReplay)(1))\n      });\n\n      this._internalJobDescriptionMap.set(name, handlerWithExtra);\n\n      return (0, rxjs_1.of)(handlerWithExtra);\n    }));\n  }\n  /**\n   * Get a job description for a named job.\n   *\n   * @param name The name of the job.\n   * @returns A description, or null if the job is not registered.\n   */\n\n\n  getDescription(name) {\n    return (0, rxjs_1.concat)(this._getInternalDescription(name).pipe((0, operators_1.map)(x => x && x.jobDescription)), (0, rxjs_1.of)(null)).pipe((0, operators_1.first)());\n  }\n  /**\n   * Returns true if the job name has been registered.\n   * @param name The name of the job.\n   * @returns True if the job exists, false otherwise.\n   */\n\n\n  has(name) {\n    return this.getDescription(name).pipe((0, operators_1.map)(x => x !== null));\n  }\n  /**\n   * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n   * used to resume execution. If multiple `pause()` were called, all their resume functions must\n   * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n   * function will have no effect.\n   *\n   * Jobs already running are NOT paused. This is pausing the scheduler only.\n   */\n\n\n  pause() {\n    let called = false;\n    this._pauseCounter++;\n    return () => {\n      if (!called) {\n        called = true;\n\n        if (--this._pauseCounter == 0) {\n          // Resume the queue.\n          const q = this._queue;\n          this._queue = [];\n          q.forEach(fn => fn());\n        }\n      }\n    };\n  }\n  /**\n   * Schedule a job to be run, using its name.\n   * @param name The name of job to be run.\n   * @param argument The argument to send to the job when starting it.\n   * @param options Scheduling options.\n   * @returns The Job being run.\n   */\n\n\n  schedule(name, argument, options) {\n    if (this._pauseCounter > 0) {\n      const waitable = new rxjs_1.Subject();\n\n      this._queue.push(() => waitable.complete());\n\n      return this._scheduleJob(name, argument, options || {}, waitable);\n    }\n\n    return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n  }\n  /**\n   * Filter messages.\n   * @private\n   */\n\n\n  _filterJobOutboundMessages(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return state == api_1.JobState.Queued;\n\n      case api_1.JobOutboundMessageKind.Start:\n        return state == api_1.JobState.Ready;\n\n      case api_1.JobOutboundMessageKind.End:\n        return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n    }\n\n    return true;\n  }\n  /**\n   * Return a new state. This is just to simplify the reading of the _createJob method.\n   * @private\n   */\n\n\n  _updateState(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return api_1.JobState.Ready;\n\n      case api_1.JobOutboundMessageKind.Start:\n        return api_1.JobState.Started;\n\n      case api_1.JobOutboundMessageKind.End:\n        return api_1.JobState.Ended;\n    }\n\n    return state;\n  }\n  /**\n   * Create the job.\n   * @private\n   */\n\n\n  _createJob(name, argument, handler, inboundBus, outboundBus) {\n    const schemaRegistry = this._schemaRegistry;\n    const channelsSubject = new Map();\n    const channels = new Map();\n    let state = api_1.JobState.Queued;\n    let pingId = 0; // Create the input channel by having a filter.\n\n    const input = new rxjs_1.Subject();\n    input.pipe((0, operators_1.concatMap)(message => handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler === null) {\n        throw new exception_1.JobDoesNotExistException(name);\n      } else {\n        return handler.inputV.pipe((0, operators_1.switchMap)(validate => validate(message)));\n      }\n    }))), (0, operators_1.filter)(result => result.success), (0, operators_1.map)(result => result.data)).subscribe(value => inboundBus.next({\n      kind: api_1.JobInboundMessageKind.Input,\n      value\n    }));\n    outboundBus = (0, rxjs_1.concat)(outboundBus, // Add an End message at completion. This will be filtered out if the job actually send an\n    // End.\n    handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler) {\n        return (0, rxjs_1.of)({\n          kind: api_1.JobOutboundMessageKind.End,\n          description: handler.jobDescription\n        });\n      } else {\n        return rxjs_1.EMPTY;\n      }\n    }))).pipe((0, operators_1.filter)(message => this._filterJobOutboundMessages(message, state)), // Update internal logic and Job<> members.\n    (0, operators_1.tap)(message => {\n      // Update the state.\n      state = this._updateState(message, state);\n\n      switch (message.kind) {\n        case api_1.JobOutboundMessageKind.ChannelCreate:\n          {\n            const maybeSubject = channelsSubject.get(message.name); // If it doesn't exist or it's closed on the other end.\n\n            if (!maybeSubject) {\n              const s = new rxjs_1.Subject();\n              channelsSubject.set(message.name, s);\n              channels.set(message.name, s.asObservable());\n            }\n\n            break;\n          }\n\n        case api_1.JobOutboundMessageKind.ChannelMessage:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n\n            if (maybeSubject) {\n              maybeSubject.next(message.message);\n            }\n\n            break;\n          }\n\n        case api_1.JobOutboundMessageKind.ChannelComplete:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n\n            if (maybeSubject) {\n              maybeSubject.complete();\n              channelsSubject.delete(message.name);\n            }\n\n            break;\n          }\n\n        case api_1.JobOutboundMessageKind.ChannelError:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n\n            if (maybeSubject) {\n              maybeSubject.error(message.error);\n              channelsSubject.delete(message.name);\n            }\n\n            break;\n          }\n      }\n    }, () => {\n      state = api_1.JobState.Errored;\n    }), // Do output validation (might include default values so this might have side\n    // effects). We keep all messages in order.\n    (0, operators_1.concatMap)(message => {\n      if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n        return (0, rxjs_1.of)(message);\n      }\n\n      return handler.pipe((0, operators_1.switchMap)(handler => {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        } else {\n          return handler.outputV.pipe((0, operators_1.switchMap)(validate => validate(message.value)), (0, operators_1.switchMap)(output => {\n            if (!output.success) {\n              throw new JobOutputSchemaValidationError(output.errors);\n            }\n\n            return (0, rxjs_1.of)({ ...message,\n              output: output.data\n            });\n          }));\n        }\n      }));\n    }), _jobShare());\n    const output = outboundBus.pipe((0, operators_1.filter)(x => x.kind == api_1.JobOutboundMessageKind.Output), (0, operators_1.map)(x => x.value), (0, operators_1.shareReplay)(1)); // Return the Job.\n\n    return {\n      get state() {\n        return state;\n      },\n\n      argument,\n      description: handler.pipe((0, operators_1.switchMap)(handler => {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        } else {\n          return (0, rxjs_1.of)(handler.jobDescription);\n        }\n      })),\n      output,\n\n      getChannel(name, schema = true) {\n        let maybeObservable = channels.get(name);\n\n        if (!maybeObservable) {\n          const s = new rxjs_1.Subject();\n          channelsSubject.set(name, s);\n          channels.set(name, s.asObservable());\n          maybeObservable = s.asObservable();\n        }\n\n        return maybeObservable.pipe( // Keep the order of messages.\n        (0, operators_1.concatMap)(message => {\n          return schemaRegistry.compile(schema).pipe((0, operators_1.switchMap)(validate => validate(message)), (0, operators_1.filter)(x => x.success), (0, operators_1.map)(x => x.data));\n        }));\n      },\n\n      ping() {\n        const id = pingId++;\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Ping,\n          id\n        });\n        return outboundBus.pipe((0, operators_1.filter)(x => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), (0, operators_1.first)(), (0, operators_1.ignoreElements)());\n      },\n\n      stop() {\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Stop\n        });\n      },\n\n      input,\n      inboundBus,\n      outboundBus\n    };\n  }\n\n  _scheduleJob(name, argument, options, waitable) {\n    // Get handler first, since this can error out if there's no handler for the job name.\n    const handler = this._getInternalDescription(name);\n\n    const optionsDeps = options && options.dependencies || [];\n    const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n    const inboundBus = new rxjs_1.Subject();\n    const outboundBus = (0, rxjs_1.concat)( // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n    // all dependencies at the same time so they run concurrently.\n    (0, rxjs_1.merge)(...dependencies.map(x => x.outboundBus)).pipe((0, operators_1.ignoreElements)()), // Wait for pause() to clear (if necessary).\n    waitable, (0, rxjs_1.from)(handler).pipe((0, operators_1.switchMap)(handler => new rxjs_1.Observable(subscriber => {\n      if (!handler) {\n        throw new exception_1.JobDoesNotExistException(name);\n      } // Validate the argument.\n\n\n      return handler.argumentV.pipe((0, operators_1.switchMap)(validate => validate(argument)), (0, operators_1.switchMap)(output => {\n        if (!output.success) {\n          throw new JobArgumentSchemaValidationError(output.errors);\n        }\n\n        const argument = output.data;\n        const description = handler.jobDescription;\n        subscriber.next({\n          kind: api_1.JobOutboundMessageKind.OnReady,\n          description\n        });\n        const context = {\n          description,\n          dependencies: [...dependencies],\n          inboundBus: inboundBus.asObservable(),\n          scheduler: this\n        };\n        return handler(argument, context);\n      })).subscribe(subscriber);\n    }))));\n    return this._createJob(name, argument, handler, inboundBus, outboundBus);\n  }\n\n}\n\nexports.SimpleScheduler = SimpleScheduler;","map":{"version":3,"names":["Object","defineProperty","exports","value","SimpleScheduler","JobOutputSchemaValidationError","JobInboundMessageSchemaValidationError","JobArgumentSchemaValidationError","rxjs_1","require","operators_1","json_1","api_1","exception_1","schema","SchemaValidationException","constructor","errors","_jobShare","source","refCount","subject","hasError","isComplete","subscription","Observable","subscriber","innerSub","Subject","subscribe","next","error","err","complete","unsubscribe","_jobRegistry","_schemaRegistry","CoreSchemaRegistry","_internalJobDescriptionMap","Map","_queue","_pauseCounter","_getInternalDescription","name","maybeHandler","get","undefined","of","handler","pipe","switchMap","description","JSON","parse","stringify","jobDescription","argument","input","output","channels","handlerWithExtra","assign","bind","argumentV","compile","shareReplay","inputV","outputV","set","getDescription","concat","map","x","first","has","pause","called","q","forEach","fn","schedule","options","waitable","push","_scheduleJob","EMPTY","_filterJobOutboundMessages","message","state","kind","JobOutboundMessageKind","OnReady","JobState","Queued","Start","Ready","End","Started","_updateState","Ended","_createJob","inboundBus","outboundBus","schemaRegistry","channelsSubject","pingId","concatMap","JobDoesNotExistException","validate","filter","result","success","data","JobInboundMessageKind","Input","tap","ChannelCreate","maybeSubject","s","asObservable","ChannelMessage","ChannelComplete","delete","ChannelError","Errored","Output","getChannel","maybeObservable","ping","id","Ping","Pong","ignoreElements","stop","Stop","optionsDeps","dependencies","Array","isArray","merge","from","context","scheduler"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/experimental/jobs/simple-scheduler.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst json_1 = require(\"../../json\");\nconst api_1 = require(\"./api\");\nconst exception_1 = require(\"./exception\");\nclass JobArgumentSchemaValidationError extends json_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Argument failed to validate. Errors: ');\n    }\n}\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\nclass JobInboundMessageSchemaValidationError extends json_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Inbound Message failed to validate. Errors: ');\n    }\n}\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\nclass JobOutputSchemaValidationError extends json_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Output failed to validate. Errors: ');\n    }\n}\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\nfunction _jobShare() {\n    // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n    // ReplaySubject.\n    return (source) => {\n        let refCount = 0;\n        let subject;\n        let hasError = false;\n        let isComplete = false;\n        let subscription;\n        return new rxjs_1.Observable((subscriber) => {\n            let innerSub;\n            refCount++;\n            if (!subject) {\n                subject = new rxjs_1.Subject();\n                innerSub = subject.subscribe(subscriber);\n                subscription = source.subscribe({\n                    next(value) {\n                        subject.next(value);\n                    },\n                    error(err) {\n                        hasError = true;\n                        subject.error(err);\n                    },\n                    complete() {\n                        isComplete = true;\n                        subject.complete();\n                    },\n                });\n            }\n            else {\n                innerSub = subject.subscribe(subscriber);\n            }\n            return () => {\n                refCount--;\n                innerSub.unsubscribe();\n                if (subscription && refCount === 0 && (isComplete || hasError)) {\n                    subscription.unsubscribe();\n                }\n            };\n        });\n    };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\nclass SimpleScheduler {\n    constructor(_jobRegistry, _schemaRegistry = new json_1.schema.CoreSchemaRegistry()) {\n        this._jobRegistry = _jobRegistry;\n        this._schemaRegistry = _schemaRegistry;\n        this._internalJobDescriptionMap = new Map();\n        this._queue = [];\n        this._pauseCounter = 0;\n    }\n    _getInternalDescription(name) {\n        const maybeHandler = this._internalJobDescriptionMap.get(name);\n        if (maybeHandler !== undefined) {\n            return (0, rxjs_1.of)(maybeHandler);\n        }\n        const handler = this._jobRegistry.get(name);\n        return handler.pipe((0, operators_1.switchMap)((handler) => {\n            if (handler === null) {\n                return (0, rxjs_1.of)(null);\n            }\n            const description = {\n                // Make a copy of it to be sure it's proper JSON.\n                ...JSON.parse(JSON.stringify(handler.jobDescription)),\n                name: handler.jobDescription.name || name,\n                argument: handler.jobDescription.argument || true,\n                input: handler.jobDescription.input || true,\n                output: handler.jobDescription.output || true,\n                channels: handler.jobDescription.channels || {},\n            };\n            const handlerWithExtra = Object.assign(handler.bind(undefined), {\n                jobDescription: description,\n                argumentV: this._schemaRegistry.compile(description.argument).pipe((0, operators_1.shareReplay)(1)),\n                inputV: this._schemaRegistry.compile(description.input).pipe((0, operators_1.shareReplay)(1)),\n                outputV: this._schemaRegistry.compile(description.output).pipe((0, operators_1.shareReplay)(1)),\n            });\n            this._internalJobDescriptionMap.set(name, handlerWithExtra);\n            return (0, rxjs_1.of)(handlerWithExtra);\n        }));\n    }\n    /**\n     * Get a job description for a named job.\n     *\n     * @param name The name of the job.\n     * @returns A description, or null if the job is not registered.\n     */\n    getDescription(name) {\n        return (0, rxjs_1.concat)(this._getInternalDescription(name).pipe((0, operators_1.map)((x) => x && x.jobDescription)), (0, rxjs_1.of)(null)).pipe((0, operators_1.first)());\n    }\n    /**\n     * Returns true if the job name has been registered.\n     * @param name The name of the job.\n     * @returns True if the job exists, false otherwise.\n     */\n    has(name) {\n        return this.getDescription(name).pipe((0, operators_1.map)((x) => x !== null));\n    }\n    /**\n     * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n     * used to resume execution. If multiple `pause()` were called, all their resume functions must\n     * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n     * function will have no effect.\n     *\n     * Jobs already running are NOT paused. This is pausing the scheduler only.\n     */\n    pause() {\n        let called = false;\n        this._pauseCounter++;\n        return () => {\n            if (!called) {\n                called = true;\n                if (--this._pauseCounter == 0) {\n                    // Resume the queue.\n                    const q = this._queue;\n                    this._queue = [];\n                    q.forEach((fn) => fn());\n                }\n            }\n        };\n    }\n    /**\n     * Schedule a job to be run, using its name.\n     * @param name The name of job to be run.\n     * @param argument The argument to send to the job when starting it.\n     * @param options Scheduling options.\n     * @returns The Job being run.\n     */\n    schedule(name, argument, options) {\n        if (this._pauseCounter > 0) {\n            const waitable = new rxjs_1.Subject();\n            this._queue.push(() => waitable.complete());\n            return this._scheduleJob(name, argument, options || {}, waitable);\n        }\n        return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n    }\n    /**\n     * Filter messages.\n     * @private\n     */\n    _filterJobOutboundMessages(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return state == api_1.JobState.Queued;\n            case api_1.JobOutboundMessageKind.Start:\n                return state == api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.End:\n                return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n        }\n        return true;\n    }\n    /**\n     * Return a new state. This is just to simplify the reading of the _createJob method.\n     * @private\n     */\n    _updateState(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.Start:\n                return api_1.JobState.Started;\n            case api_1.JobOutboundMessageKind.End:\n                return api_1.JobState.Ended;\n        }\n        return state;\n    }\n    /**\n     * Create the job.\n     * @private\n     */\n    _createJob(name, argument, handler, inboundBus, outboundBus) {\n        const schemaRegistry = this._schemaRegistry;\n        const channelsSubject = new Map();\n        const channels = new Map();\n        let state = api_1.JobState.Queued;\n        let pingId = 0;\n        // Create the input channel by having a filter.\n        const input = new rxjs_1.Subject();\n        input\n            .pipe((0, operators_1.concatMap)((message) => handler.pipe((0, operators_1.switchMap)((handler) => {\n            if (handler === null) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            else {\n                return handler.inputV.pipe((0, operators_1.switchMap)((validate) => validate(message)));\n            }\n        }))), (0, operators_1.filter)((result) => result.success), (0, operators_1.map)((result) => result.data))\n            .subscribe((value) => inboundBus.next({ kind: api_1.JobInboundMessageKind.Input, value }));\n        outboundBus = (0, rxjs_1.concat)(outboundBus, \n        // Add an End message at completion. This will be filtered out if the job actually send an\n        // End.\n        handler.pipe((0, operators_1.switchMap)((handler) => {\n            if (handler) {\n                return (0, rxjs_1.of)({\n                    kind: api_1.JobOutboundMessageKind.End,\n                    description: handler.jobDescription,\n                });\n            }\n            else {\n                return rxjs_1.EMPTY;\n            }\n        }))).pipe((0, operators_1.filter)((message) => this._filterJobOutboundMessages(message, state)), \n        // Update internal logic and Job<> members.\n        (0, operators_1.tap)((message) => {\n            // Update the state.\n            state = this._updateState(message, state);\n            switch (message.kind) {\n                case api_1.JobOutboundMessageKind.ChannelCreate: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    // If it doesn't exist or it's closed on the other end.\n                    if (!maybeSubject) {\n                        const s = new rxjs_1.Subject();\n                        channelsSubject.set(message.name, s);\n                        channels.set(message.name, s.asObservable());\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelMessage: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.next(message.message);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelComplete: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.complete();\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelError: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.error(message.error);\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n            }\n        }, () => {\n            state = api_1.JobState.Errored;\n        }), \n        // Do output validation (might include default values so this might have side\n        // effects). We keep all messages in order.\n        (0, operators_1.concatMap)((message) => {\n            if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n                return (0, rxjs_1.of)(message);\n            }\n            return handler.pipe((0, operators_1.switchMap)((handler) => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                else {\n                    return handler.outputV.pipe((0, operators_1.switchMap)((validate) => validate(message.value)), (0, operators_1.switchMap)((output) => {\n                        if (!output.success) {\n                            throw new JobOutputSchemaValidationError(output.errors);\n                        }\n                        return (0, rxjs_1.of)({\n                            ...message,\n                            output: output.data,\n                        });\n                    }));\n                }\n            }));\n        }), _jobShare());\n        const output = outboundBus.pipe((0, operators_1.filter)((x) => x.kind == api_1.JobOutboundMessageKind.Output), (0, operators_1.map)((x) => x.value), (0, operators_1.shareReplay)(1));\n        // Return the Job.\n        return {\n            get state() {\n                return state;\n            },\n            argument,\n            description: handler.pipe((0, operators_1.switchMap)((handler) => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                else {\n                    return (0, rxjs_1.of)(handler.jobDescription);\n                }\n            })),\n            output,\n            getChannel(name, schema = true) {\n                let maybeObservable = channels.get(name);\n                if (!maybeObservable) {\n                    const s = new rxjs_1.Subject();\n                    channelsSubject.set(name, s);\n                    channels.set(name, s.asObservable());\n                    maybeObservable = s.asObservable();\n                }\n                return maybeObservable.pipe(\n                // Keep the order of messages.\n                (0, operators_1.concatMap)((message) => {\n                    return schemaRegistry.compile(schema).pipe((0, operators_1.switchMap)((validate) => validate(message)), (0, operators_1.filter)((x) => x.success), (0, operators_1.map)((x) => x.data));\n                }));\n            },\n            ping() {\n                const id = pingId++;\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Ping, id });\n                return outboundBus.pipe((0, operators_1.filter)((x) => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), (0, operators_1.first)(), (0, operators_1.ignoreElements)());\n            },\n            stop() {\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Stop });\n            },\n            input,\n            inboundBus,\n            outboundBus,\n        };\n    }\n    _scheduleJob(name, argument, options, waitable) {\n        // Get handler first, since this can error out if there's no handler for the job name.\n        const handler = this._getInternalDescription(name);\n        const optionsDeps = (options && options.dependencies) || [];\n        const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n        const inboundBus = new rxjs_1.Subject();\n        const outboundBus = (0, rxjs_1.concat)(\n        // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n        // all dependencies at the same time so they run concurrently.\n        (0, rxjs_1.merge)(...dependencies.map((x) => x.outboundBus)).pipe((0, operators_1.ignoreElements)()), \n        // Wait for pause() to clear (if necessary).\n        waitable, (0, rxjs_1.from)(handler).pipe((0, operators_1.switchMap)((handler) => new rxjs_1.Observable((subscriber) => {\n            if (!handler) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            // Validate the argument.\n            return handler.argumentV\n                .pipe((0, operators_1.switchMap)((validate) => validate(argument)), (0, operators_1.switchMap)((output) => {\n                if (!output.success) {\n                    throw new JobArgumentSchemaValidationError(output.errors);\n                }\n                const argument = output.data;\n                const description = handler.jobDescription;\n                subscriber.next({ kind: api_1.JobOutboundMessageKind.OnReady, description });\n                const context = {\n                    description,\n                    dependencies: [...dependencies],\n                    inboundBus: inboundBus.asObservable(),\n                    scheduler: this,\n                };\n                return handler(argument, context);\n            }))\n                .subscribe(subscriber);\n        }))));\n        return this._createJob(name, argument, handler, inboundBus, outboundBus);\n    }\n}\nexports.SimpleScheduler = SimpleScheduler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}