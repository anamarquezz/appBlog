{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CordHost = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst exception_1 = require(\"../../exception\");\n\nconst memory_1 = require(\"./memory\");\n/**\n * A Host that records changes to the underlying Host, while keeping a record of Create, Overwrite,\n * Rename and Delete of files.\n *\n * This is fully compatible with Host, but will keep a staging of every changes asked. That staging\n * follows the principle of the Tree (e.g. can create a file that already exists).\n *\n * Using `create()` and `overwrite()` will force those operations, but using `write` will add\n * the create/overwrite records IIF the files does/doesn't already exist.\n */\n\n\nclass CordHost extends memory_1.SimpleMemoryHost {\n  constructor(_back) {\n    super();\n    this._back = _back;\n    this._filesToCreate = new Set();\n    this._filesToRename = new Map();\n    this._filesToRenameRevert = new Map();\n    this._filesToDelete = new Set();\n    this._filesToOverwrite = new Set();\n  }\n\n  get backend() {\n    return this._back;\n  }\n\n  get capabilities() {\n    // Our own host is always Synchronous, but the backend might not be.\n    return {\n      synchronous: this._back.capabilities.synchronous\n    };\n  }\n  /**\n   * Create a copy of this host, including all actions made.\n   * @returns {CordHost} The carbon copy.\n   */\n\n\n  clone() {\n    const dolly = new CordHost(this._back);\n    dolly._cache = new Map(this._cache);\n    dolly._filesToCreate = new Set(this._filesToCreate);\n    dolly._filesToRename = new Map(this._filesToRename);\n    dolly._filesToRenameRevert = new Map(this._filesToRenameRevert);\n    dolly._filesToDelete = new Set(this._filesToDelete);\n    dolly._filesToOverwrite = new Set(this._filesToOverwrite);\n    return dolly;\n  }\n  /**\n   * Commit the changes recorded to a Host. It is assumed that the host does have the same structure\n   * as the host that was used for backend (could be the same host).\n   * @param host The host to create/delete/rename/overwrite files to.\n   * @param force Whether to skip existence checks when creating/overwriting. This is\n   *   faster but might lead to incorrect states. Because Hosts natively don't support creation\n   *   versus overwriting (it's only writing), we check for existence before completing a request.\n   * @returns An observable that completes when done, or error if an error occured.\n   */\n\n\n  commit(host, force = false) {\n    // Really commit everything to the actual host.\n    return (0, rxjs_1.from)(this.records()).pipe((0, operators_1.concatMap)(record => {\n      switch (record.kind) {\n        case 'delete':\n          return host.delete(record.path);\n\n        case 'rename':\n          return host.rename(record.from, record.to);\n\n        case 'create':\n          return host.exists(record.path).pipe((0, operators_1.switchMap)(exists => {\n            if (exists && !force) {\n              return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(record.path));\n            } else {\n              return host.write(record.path, record.content);\n            }\n          }));\n\n        case 'overwrite':\n          return host.exists(record.path).pipe((0, operators_1.switchMap)(exists => {\n            if (!exists && !force) {\n              return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(record.path));\n            } else {\n              return host.write(record.path, record.content);\n            }\n          }));\n      }\n    }), (0, operators_1.reduce)(() => {}));\n  }\n\n  records() {\n    return [...[...this._filesToDelete.values()].map(path => ({\n      kind: 'delete',\n      path\n    })), ...[...this._filesToRename.entries()].map(([from, to]) => ({\n      kind: 'rename',\n      from,\n      to\n    })), ...[...this._filesToCreate.values()].map(path => ({\n      kind: 'create',\n      path,\n      content: this._read(path)\n    })), ...[...this._filesToOverwrite.values()].map(path => ({\n      kind: 'overwrite',\n      path,\n      content: this._read(path)\n    }))];\n  }\n  /**\n   * Specialized version of {@link CordHost#write} which forces the creation of a file whether it\n   * exists or not.\n   * @param {} path\n   * @param {FileBuffer} content\n   * @returns {Observable<void>}\n   */\n\n\n  create(path, content) {\n    if (super._exists(path)) {\n      throw new exception_1.FileAlreadyExistException(path);\n    }\n\n    if (this._filesToDelete.has(path)) {\n      this._filesToDelete.delete(path);\n\n      this._filesToOverwrite.add(path);\n    } else {\n      this._filesToCreate.add(path);\n    }\n\n    return super.write(path, content);\n  }\n\n  overwrite(path, content) {\n    return this.isDirectory(path).pipe((0, operators_1.switchMap)(isDir => {\n      if (isDir) {\n        return (0, rxjs_1.throwError)(new exception_1.PathIsDirectoryException(path));\n      }\n\n      return this.exists(path);\n    }), (0, operators_1.switchMap)(exists => {\n      if (!exists) {\n        return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n      }\n\n      if (!this._filesToCreate.has(path)) {\n        this._filesToOverwrite.add(path);\n      }\n\n      return super.write(path, content);\n    }));\n  }\n\n  write(path, content) {\n    return this.exists(path).pipe((0, operators_1.switchMap)(exists => {\n      if (exists) {\n        // It exists, but might be being renamed or deleted. In that case we want to create it.\n        if (this.willRename(path) || this.willDelete(path)) {\n          return this.create(path, content);\n        } else {\n          return this.overwrite(path, content);\n        }\n      } else {\n        return this.create(path, content);\n      }\n    }));\n  }\n\n  read(path) {\n    if (this._exists(path)) {\n      return super.read(path);\n    }\n\n    return this._back.read(path);\n  }\n\n  delete(path) {\n    if (this._exists(path)) {\n      if (this._filesToCreate.has(path)) {\n        this._filesToCreate.delete(path);\n      } else if (this._filesToOverwrite.has(path)) {\n        this._filesToOverwrite.delete(path);\n\n        this._filesToDelete.add(path);\n      } else {\n        const maybeOrigin = this._filesToRenameRevert.get(path);\n\n        if (maybeOrigin) {\n          this._filesToRenameRevert.delete(path);\n\n          this._filesToRename.delete(maybeOrigin);\n\n          this._filesToDelete.add(maybeOrigin);\n        } else {\n          return (0, rxjs_1.throwError)(new exception_1.UnknownException(`This should never happen. Path: ${JSON.stringify(path)}.`));\n        }\n      }\n\n      return super.delete(path);\n    } else {\n      return this._back.exists(path).pipe((0, operators_1.switchMap)(exists => {\n        if (exists) {\n          this._filesToDelete.add(path);\n\n          return (0, rxjs_1.of)();\n        } else {\n          return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n        }\n      }));\n    }\n  }\n\n  rename(from, to) {\n    return (0, rxjs_1.concat)(this.exists(to), this.exists(from)).pipe((0, operators_1.toArray)(), (0, operators_1.switchMap)(([existTo, existFrom]) => {\n      if (!existFrom) {\n        return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(from));\n      }\n\n      if (from === to) {\n        return rxjs_1.EMPTY;\n      }\n\n      if (existTo) {\n        return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(to));\n      } // If we're renaming a file that's been created, shortcircuit to creating the `to` path.\n\n\n      if (this._filesToCreate.has(from)) {\n        this._filesToCreate.delete(from);\n\n        this._filesToCreate.add(to);\n\n        return super.rename(from, to);\n      }\n\n      if (this._filesToOverwrite.has(from)) {\n        this._filesToOverwrite.delete(from); // Recursively call this function. This is so we don't repeat the bottom logic. This\n        // if will be by-passed because we just deleted the `from` path from files to overwrite.\n\n\n        return (0, rxjs_1.concat)(this.rename(from, to), new rxjs_1.Observable(x => {\n          this._filesToOverwrite.add(to);\n\n          x.complete();\n        }));\n      }\n\n      if (this._filesToDelete.has(to)) {\n        this._filesToDelete.delete(to);\n\n        this._filesToDelete.add(from);\n\n        this._filesToOverwrite.add(to); // We need to delete the original and write the new one.\n\n\n        return this.read(from).pipe((0, operators_1.map)(content => this._write(to, content)));\n      }\n\n      const maybeTo1 = this._filesToRenameRevert.get(from);\n\n      if (maybeTo1) {\n        // We already renamed to this file (A => from), let's rename the former to the new\n        // path (A => to).\n        this._filesToRename.delete(maybeTo1);\n\n        this._filesToRenameRevert.delete(from);\n\n        from = maybeTo1;\n      }\n\n      this._filesToRename.set(from, to);\n\n      this._filesToRenameRevert.set(to, from); // If the file is part of our data, just rename it internally.\n\n\n      if (this._exists(from)) {\n        return super.rename(from, to);\n      } else {\n        // Create a file with the same content.\n        return this._back.read(from).pipe((0, operators_1.switchMap)(content => super.write(to, content)));\n      }\n    }));\n  }\n\n  list(path) {\n    return (0, rxjs_1.concat)(super.list(path), this._back.list(path)).pipe((0, operators_1.reduce)((list, curr) => {\n      curr.forEach(elem => list.add(elem));\n      return list;\n    }, new Set()), (0, operators_1.map)(set => [...set]));\n  }\n\n  exists(path) {\n    return this._exists(path) ? (0, rxjs_1.of)(true) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(false) : this._back.exists(path);\n  }\n\n  isDirectory(path) {\n    return this._exists(path) ? super.isDirectory(path) : this._back.isDirectory(path);\n  }\n\n  isFile(path) {\n    return this._exists(path) ? super.isFile(path) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(false) : this._back.isFile(path);\n  }\n\n  stat(path) {\n    return this._exists(path) ? super.stat(path) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(null) : this._back.stat(path);\n  }\n\n  watch(path, options) {\n    // Watching not supported.\n    return null;\n  }\n\n  willCreate(path) {\n    return this._filesToCreate.has(path);\n  }\n\n  willOverwrite(path) {\n    return this._filesToOverwrite.has(path);\n  }\n\n  willDelete(path) {\n    return this._filesToDelete.has(path);\n  }\n\n  willRename(path) {\n    return this._filesToRename.has(path);\n  }\n\n  willRenameTo(path, to) {\n    return this._filesToRename.get(path) === to;\n  }\n\n}\n\nexports.CordHost = CordHost;","map":{"version":3,"names":["Object","defineProperty","exports","value","CordHost","rxjs_1","require","operators_1","exception_1","memory_1","SimpleMemoryHost","constructor","_back","_filesToCreate","Set","_filesToRename","Map","_filesToRenameRevert","_filesToDelete","_filesToOverwrite","backend","capabilities","synchronous","clone","dolly","_cache","commit","host","force","from","records","pipe","concatMap","record","kind","delete","path","rename","to","exists","switchMap","throwError","FileAlreadyExistException","write","content","FileDoesNotExistException","reduce","values","map","entries","_read","create","_exists","has","add","overwrite","isDirectory","isDir","PathIsDirectoryException","willRename","willDelete","read","maybeOrigin","get","UnknownException","JSON","stringify","of","concat","toArray","existTo","existFrom","EMPTY","Observable","x","complete","_write","maybeTo1","set","list","curr","forEach","elem","isFile","stat","watch","options","willCreate","willOverwrite","willRenameTo"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/virtual-fs/host/record.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CordHost = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../../exception\");\nconst memory_1 = require(\"./memory\");\n/**\n * A Host that records changes to the underlying Host, while keeping a record of Create, Overwrite,\n * Rename and Delete of files.\n *\n * This is fully compatible with Host, but will keep a staging of every changes asked. That staging\n * follows the principle of the Tree (e.g. can create a file that already exists).\n *\n * Using `create()` and `overwrite()` will force those operations, but using `write` will add\n * the create/overwrite records IIF the files does/doesn't already exist.\n */\nclass CordHost extends memory_1.SimpleMemoryHost {\n    constructor(_back) {\n        super();\n        this._back = _back;\n        this._filesToCreate = new Set();\n        this._filesToRename = new Map();\n        this._filesToRenameRevert = new Map();\n        this._filesToDelete = new Set();\n        this._filesToOverwrite = new Set();\n    }\n    get backend() {\n        return this._back;\n    }\n    get capabilities() {\n        // Our own host is always Synchronous, but the backend might not be.\n        return {\n            synchronous: this._back.capabilities.synchronous,\n        };\n    }\n    /**\n     * Create a copy of this host, including all actions made.\n     * @returns {CordHost} The carbon copy.\n     */\n    clone() {\n        const dolly = new CordHost(this._back);\n        dolly._cache = new Map(this._cache);\n        dolly._filesToCreate = new Set(this._filesToCreate);\n        dolly._filesToRename = new Map(this._filesToRename);\n        dolly._filesToRenameRevert = new Map(this._filesToRenameRevert);\n        dolly._filesToDelete = new Set(this._filesToDelete);\n        dolly._filesToOverwrite = new Set(this._filesToOverwrite);\n        return dolly;\n    }\n    /**\n     * Commit the changes recorded to a Host. It is assumed that the host does have the same structure\n     * as the host that was used for backend (could be the same host).\n     * @param host The host to create/delete/rename/overwrite files to.\n     * @param force Whether to skip existence checks when creating/overwriting. This is\n     *   faster but might lead to incorrect states. Because Hosts natively don't support creation\n     *   versus overwriting (it's only writing), we check for existence before completing a request.\n     * @returns An observable that completes when done, or error if an error occured.\n     */\n    commit(host, force = false) {\n        // Really commit everything to the actual host.\n        return (0, rxjs_1.from)(this.records()).pipe((0, operators_1.concatMap)((record) => {\n            switch (record.kind) {\n                case 'delete':\n                    return host.delete(record.path);\n                case 'rename':\n                    return host.rename(record.from, record.to);\n                case 'create':\n                    return host.exists(record.path).pipe((0, operators_1.switchMap)((exists) => {\n                        if (exists && !force) {\n                            return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(record.path));\n                        }\n                        else {\n                            return host.write(record.path, record.content);\n                        }\n                    }));\n                case 'overwrite':\n                    return host.exists(record.path).pipe((0, operators_1.switchMap)((exists) => {\n                        if (!exists && !force) {\n                            return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(record.path));\n                        }\n                        else {\n                            return host.write(record.path, record.content);\n                        }\n                    }));\n            }\n        }), (0, operators_1.reduce)(() => { }));\n    }\n    records() {\n        return [\n            ...[...this._filesToDelete.values()].map((path) => ({\n                kind: 'delete',\n                path,\n            })),\n            ...[...this._filesToRename.entries()].map(([from, to]) => ({\n                kind: 'rename',\n                from,\n                to,\n            })),\n            ...[...this._filesToCreate.values()].map((path) => ({\n                kind: 'create',\n                path,\n                content: this._read(path),\n            })),\n            ...[...this._filesToOverwrite.values()].map((path) => ({\n                kind: 'overwrite',\n                path,\n                content: this._read(path),\n            })),\n        ];\n    }\n    /**\n     * Specialized version of {@link CordHost#write} which forces the creation of a file whether it\n     * exists or not.\n     * @param {} path\n     * @param {FileBuffer} content\n     * @returns {Observable<void>}\n     */\n    create(path, content) {\n        if (super._exists(path)) {\n            throw new exception_1.FileAlreadyExistException(path);\n        }\n        if (this._filesToDelete.has(path)) {\n            this._filesToDelete.delete(path);\n            this._filesToOverwrite.add(path);\n        }\n        else {\n            this._filesToCreate.add(path);\n        }\n        return super.write(path, content);\n    }\n    overwrite(path, content) {\n        return this.isDirectory(path).pipe((0, operators_1.switchMap)((isDir) => {\n            if (isDir) {\n                return (0, rxjs_1.throwError)(new exception_1.PathIsDirectoryException(path));\n            }\n            return this.exists(path);\n        }), (0, operators_1.switchMap)((exists) => {\n            if (!exists) {\n                return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n            }\n            if (!this._filesToCreate.has(path)) {\n                this._filesToOverwrite.add(path);\n            }\n            return super.write(path, content);\n        }));\n    }\n    write(path, content) {\n        return this.exists(path).pipe((0, operators_1.switchMap)((exists) => {\n            if (exists) {\n                // It exists, but might be being renamed or deleted. In that case we want to create it.\n                if (this.willRename(path) || this.willDelete(path)) {\n                    return this.create(path, content);\n                }\n                else {\n                    return this.overwrite(path, content);\n                }\n            }\n            else {\n                return this.create(path, content);\n            }\n        }));\n    }\n    read(path) {\n        if (this._exists(path)) {\n            return super.read(path);\n        }\n        return this._back.read(path);\n    }\n    delete(path) {\n        if (this._exists(path)) {\n            if (this._filesToCreate.has(path)) {\n                this._filesToCreate.delete(path);\n            }\n            else if (this._filesToOverwrite.has(path)) {\n                this._filesToOverwrite.delete(path);\n                this._filesToDelete.add(path);\n            }\n            else {\n                const maybeOrigin = this._filesToRenameRevert.get(path);\n                if (maybeOrigin) {\n                    this._filesToRenameRevert.delete(path);\n                    this._filesToRename.delete(maybeOrigin);\n                    this._filesToDelete.add(maybeOrigin);\n                }\n                else {\n                    return (0, rxjs_1.throwError)(new exception_1.UnknownException(`This should never happen. Path: ${JSON.stringify(path)}.`));\n                }\n            }\n            return super.delete(path);\n        }\n        else {\n            return this._back.exists(path).pipe((0, operators_1.switchMap)((exists) => {\n                if (exists) {\n                    this._filesToDelete.add(path);\n                    return (0, rxjs_1.of)();\n                }\n                else {\n                    return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n                }\n            }));\n        }\n    }\n    rename(from, to) {\n        return (0, rxjs_1.concat)(this.exists(to), this.exists(from)).pipe((0, operators_1.toArray)(), (0, operators_1.switchMap)(([existTo, existFrom]) => {\n            if (!existFrom) {\n                return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(from));\n            }\n            if (from === to) {\n                return rxjs_1.EMPTY;\n            }\n            if (existTo) {\n                return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(to));\n            }\n            // If we're renaming a file that's been created, shortcircuit to creating the `to` path.\n            if (this._filesToCreate.has(from)) {\n                this._filesToCreate.delete(from);\n                this._filesToCreate.add(to);\n                return super.rename(from, to);\n            }\n            if (this._filesToOverwrite.has(from)) {\n                this._filesToOverwrite.delete(from);\n                // Recursively call this function. This is so we don't repeat the bottom logic. This\n                // if will be by-passed because we just deleted the `from` path from files to overwrite.\n                return (0, rxjs_1.concat)(this.rename(from, to), new rxjs_1.Observable((x) => {\n                    this._filesToOverwrite.add(to);\n                    x.complete();\n                }));\n            }\n            if (this._filesToDelete.has(to)) {\n                this._filesToDelete.delete(to);\n                this._filesToDelete.add(from);\n                this._filesToOverwrite.add(to);\n                // We need to delete the original and write the new one.\n                return this.read(from).pipe((0, operators_1.map)((content) => this._write(to, content)));\n            }\n            const maybeTo1 = this._filesToRenameRevert.get(from);\n            if (maybeTo1) {\n                // We already renamed to this file (A => from), let's rename the former to the new\n                // path (A => to).\n                this._filesToRename.delete(maybeTo1);\n                this._filesToRenameRevert.delete(from);\n                from = maybeTo1;\n            }\n            this._filesToRename.set(from, to);\n            this._filesToRenameRevert.set(to, from);\n            // If the file is part of our data, just rename it internally.\n            if (this._exists(from)) {\n                return super.rename(from, to);\n            }\n            else {\n                // Create a file with the same content.\n                return this._back.read(from).pipe((0, operators_1.switchMap)((content) => super.write(to, content)));\n            }\n        }));\n    }\n    list(path) {\n        return (0, rxjs_1.concat)(super.list(path), this._back.list(path)).pipe((0, operators_1.reduce)((list, curr) => {\n            curr.forEach((elem) => list.add(elem));\n            return list;\n        }, new Set()), (0, operators_1.map)((set) => [...set]));\n    }\n    exists(path) {\n        return this._exists(path)\n            ? (0, rxjs_1.of)(true)\n            : this.willDelete(path) || this.willRename(path)\n                ? (0, rxjs_1.of)(false)\n                : this._back.exists(path);\n    }\n    isDirectory(path) {\n        return this._exists(path) ? super.isDirectory(path) : this._back.isDirectory(path);\n    }\n    isFile(path) {\n        return this._exists(path)\n            ? super.isFile(path)\n            : this.willDelete(path) || this.willRename(path)\n                ? (0, rxjs_1.of)(false)\n                : this._back.isFile(path);\n    }\n    stat(path) {\n        return this._exists(path)\n            ? super.stat(path)\n            : this.willDelete(path) || this.willRename(path)\n                ? (0, rxjs_1.of)(null)\n                : this._back.stat(path);\n    }\n    watch(path, options) {\n        // Watching not supported.\n        return null;\n    }\n    willCreate(path) {\n        return this._filesToCreate.has(path);\n    }\n    willOverwrite(path) {\n        return this._filesToOverwrite.has(path);\n    }\n    willDelete(path) {\n        return this._filesToDelete.has(path);\n    }\n    willRename(path) {\n        return this._filesToRename.has(path);\n    }\n    willRenameTo(path, to) {\n        return this._filesToRename.get(path) === to;\n    }\n}\nexports.CordHost = CordHost;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}