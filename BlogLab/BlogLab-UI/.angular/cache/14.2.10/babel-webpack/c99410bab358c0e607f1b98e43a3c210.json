{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst fs = require('graceful-fs');\n\nconst os = require('os');\n\nconst tar = require('tar');\n\nconst path = require('path');\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst crypto = require('crypto');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst fetch = require('make-fetch-happen');\n\nconst processRelease = require('./process-release');\n\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nfunction install(_x, _x2, _x3) {\n  return _install.apply(this, arguments);\n}\n\nfunction _install() {\n  _install = _asyncToGenerator(function* (fs, gyp, argv) {\n    const release = processRelease(argv, gyp, process.version, process.release); // Determine which node dev files version we are installing\n\n    log.verbose('install', 'input version string %j', release.version);\n\n    if (!release.semver) {\n      // could not parse the version string with semver\n      throw new Error('Invalid version number: ' + release.version);\n    }\n\n    if (semver.lt(release.version, '0.8.0')) {\n      throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n    } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n    if (release.semver.prerelease[0] === 'pre') {\n      log.verbose('detected \"pre\" node version', release.version);\n\n      if (!gyp.opts.nodedir) {\n        throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n      }\n\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      return;\n    } // flatten version into String\n\n\n    log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n    const devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n    // check if it is already installed, and only install when needed\n\n    if (gyp.opts.ensure) {\n      log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n\n      try {\n        yield fs.promises.stat(devDir);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n\n          try {\n            return yield go();\n          } catch (err) {\n            return rollback(err);\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err);\n        }\n\n        throw err;\n      }\n\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      const installVersionFile = path.resolve(devDir, 'installVersion');\n      let installVersion = 0;\n\n      try {\n        const ver = yield fs.promises.readFile(installVersionFile, 'ascii');\n        installVersion = parseInt(ver, 10) || 0;\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n\n      log.verbose('got \"installVersion\"', installVersion);\n      log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n      if (installVersion < gyp.package.installVersion) {\n        log.verbose('install', 'version is no good; reinstalling');\n\n        try {\n          return yield go();\n        } catch (err) {\n          return rollback(err);\n        }\n      }\n\n      log.verbose('install', 'version is good');\n    } else {\n      try {\n        return yield go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n\n    function go() {\n      return _go.apply(this, arguments);\n    } // go()\n\n    /**\n     * Checks if a given filename is \"valid\" for this installation.\n     */\n\n\n    function _go() {\n      _go = _asyncToGenerator(function* () {\n        log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n        try {\n          const created = yield fs.promises.mkdir(devDir, {\n            recursive: true\n          });\n\n          if (created) {\n            log.verbose('created nodedir', created);\n          }\n        } catch (err) {\n          if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n\n          throw err;\n        } // now download the node tarball\n\n\n        const tarPath = gyp.opts.tarball;\n        let extractCount = 0;\n        const contentShasums = {};\n        const expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n        // only .h header files and the gyp files get extracted\n\n        function isValid(path) {\n          const isValid = valid(path);\n\n          if (isValid) {\n            log.verbose('extracted file from tarball', path);\n            extractCount++;\n          } else {\n            // invalid\n            log.silly('ignoring from tarball', path);\n          }\n\n          return isValid;\n        } // download the tarball and extract!\n\n\n        if (tarPath) {\n          yield tar.extract({\n            file: tarPath,\n            strip: 1,\n            filter: isValid,\n            cwd: devDir\n          });\n        } else {\n          try {\n            const res = yield download(gyp, release.tarballUrl);\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n            }\n\n            yield streamPipeline(res.body, // content checksum\n            new ShaSum((_, checksum) => {\n              const filename = path.basename(release.tarballUrl).trim();\n              contentShasums[filename] = checksum;\n              log.verbose('content checksum', filename, checksum);\n            }), tar.extract({\n              strip: 1,\n              cwd: devDir,\n              filter: isValid\n            }));\n          } catch (err) {\n            // something went wrong downloading the tarball?\n            if (err.code === 'ENOTFOUND') {\n              throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n            }\n\n            throw err;\n          }\n        } // invoked after the tarball has finished being extracted\n\n\n        if (extractCount === 0) {\n          throw new Error('There was a fatal problem while downloading/extracting the tarball');\n        }\n\n        log.verbose('tarball', 'done parsing tarball');\n        const installVersionPath = path.resolve(devDir, 'installVersion');\n        yield Promise.all([// need to download node.lib\n        ...(win ? downloadNodeLib() : []), // write the \"installVersion\" file\n        fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'), // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        ...(!tarPath || win ? [downloadShasums()] : [])]);\n        log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n        for (const k in contentShasums) {\n          log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n          if (contentShasums[k] !== expectShasums[k]) {\n            throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n          }\n        }\n\n        function downloadShasums() {\n          return _downloadShasums.apply(this, arguments);\n        }\n\n        function _downloadShasums() {\n          _downloadShasums = _asyncToGenerator(function* () {\n            log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n            log.verbose('checksum url', release.shasumsUrl);\n            const res = yield download(gyp, release.shasumsUrl);\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status}  status code downloading checksum`);\n            }\n\n            for (const line of (yield res.text()).trim().split('\\n')) {\n              const items = line.trim().split(/\\s+/);\n\n              if (items.length !== 2) {\n                return;\n              } // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n\n              const name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            }\n\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n          });\n          return _downloadShasums.apply(this, arguments);\n        }\n\n        function downloadNodeLib() {\n          log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n          const archs = ['ia32', 'x64', 'arm64'];\n          return archs.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (arch) {\n              const dir = path.resolve(devDir, arch);\n              const targetLibPath = path.resolve(dir, release.name + '.lib');\n              const {\n                libUrl,\n                libPath\n              } = release[arch];\n              const name = `${arch} ${release.name}.lib`;\n              log.verbose(name, 'dir', dir);\n              log.verbose(name, 'url', libUrl);\n              yield fs.promises.mkdir(dir, {\n                recursive: true\n              });\n              log.verbose('streaming', name, 'to:', targetLibPath);\n              const res = yield download(gyp, libUrl);\n\n              if (res.status === 403 || res.status === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`);\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`);\n                }\n\n                return;\n              } else if (res.status !== 200) {\n                throw new Error(`${res.status} status code downloading ${name}`);\n              }\n\n              return streamPipeline(res.body, new ShaSum((_, checksum) => {\n                contentShasums[libPath] = checksum;\n                log.verbose('content checksum', libPath, checksum);\n              }), fs.createWriteStream(targetLibPath));\n            });\n\n            return function (_x9) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n        } // downloadNodeLib()\n\n      });\n      return _go.apply(this, arguments);\n    }\n\n    function valid(file) {\n      // header files\n      const extname = path.extname(file);\n      return extname === '.h' || extname === '.gypi';\n    }\n\n    function rollback(_x7) {\n      return _rollback.apply(this, arguments);\n    }\n    /**\n     * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n     * it drops the permissions before invoking any child processes (like\n     * node-gyp). So what happens is the \"nobody\" user doesn't have\n     * permission to create the dev dir. As a fallback, make the tmpdir() be\n     * the dev dir for this installation. This is not ideal, but at least\n     * the compilation will succeed...\n     */\n\n\n    function _rollback() {\n      _rollback = _asyncToGenerator(function* (err) {\n        log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n        yield util.promisify(gyp.commands.remove)([release.versionDir]);\n        throw err;\n      });\n      return _rollback.apply(this, arguments);\n    }\n\n    function eaccesFallback(_x8) {\n      return _eaccesFallback.apply(this, arguments);\n    }\n\n    function _eaccesFallback() {\n      _eaccesFallback = _asyncToGenerator(function* (err) {\n        const noretry = '--node_gyp_internal_noretry';\n\n        if (argv.indexOf(noretry) !== -1) {\n          throw err;\n        }\n\n        const tmpdir = os.tmpdir();\n        gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n        let userString = '';\n\n        try {\n          // os.userInfo can fail on some systems, it's not critical here\n          userString = ` (\"${os.userInfo().username}\")`;\n        } catch (e) {}\n\n        log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n        log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n        if (process.cwd() === tmpdir) {\n          log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n          gyp.todo.push({\n            name: 'remove',\n            args: argv\n          });\n        }\n\n        return util.promisify(gyp.commands.install)([noretry].concat(argv));\n      });\n      return _eaccesFallback.apply(this, arguments);\n    }\n  });\n  return _install.apply(this, arguments);\n}\n\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n\n    callback(null, chunk);\n  }\n\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n\n    callback();\n  }\n\n}\n\nfunction download(_x4, _x5) {\n  return _download.apply(this, arguments);\n}\n\nfunction _download() {\n  _download = _asyncToGenerator(function* (gyp, url) {\n    log.http('GET', url);\n    const requestOpts = {\n      headers: {\n        'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n        Connection: 'keep-alive'\n      },\n      proxy: gyp.opts.proxy,\n      noProxy: gyp.opts.noproxy\n    };\n    const cafile = gyp.opts.cafile;\n\n    if (cafile) {\n      requestOpts.ca = yield readCAFile(cafile);\n    }\n\n    const res = yield fetch(url, requestOpts);\n    log.http(res.status, res.url);\n    return res;\n  });\n  return _download.apply(this, arguments);\n}\n\nfunction readCAFile(_x6) {\n  return _readCAFile.apply(this, arguments);\n}\n\nfunction _readCAFile() {\n  _readCAFile = _asyncToGenerator(function* (filename) {\n    // The CA file can contain multiple certificates so split on certificate\n    // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n    const ca = yield fs.promises.readFile(filename, 'utf8');\n    const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n    return ca.match(re);\n  });\n  return _readCAFile.apply(this, arguments);\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\n\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"names":["fs","require","os","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","gyp","argv","release","version","verbose","Error","lt","prerelease","opts","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","created","mkdir","recursive","tarPath","tarball","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","line","text","split","items","length","name","replace","archs","map","arch","dir","targetLibPath","libUrl","libPath","warn","createWriteStream","extname","commands","remove","noretry","indexOf","tmpdir","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/node-gyp/lib/install.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    // download the tarball and extract!\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      })\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl)\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n        }\n\n        await streamPipeline(\n          res.body,\n          // content checksum\n          new ShaSum((_, checksum) => {\n            const filename = path.basename(release.tarballUrl).trim()\n            contentShasums[filename] = checksum\n            log.verbose('content checksum', filename, checksum)\n          }),\n          tar.extract({\n            strip: 1,\n            cwd: devDir,\n            filter: isValid\n          })\n        )\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.')\n        }\n        throw err\n      }\n    }\n\n    // invoked after the tarball has finished being extracted\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball')\n    }\n\n    log.verbose('tarball', 'done parsing tarball')\n\n    const installVersionPath = path.resolve(devDir, 'installVersion')\n    await Promise.all([\n      // need to download node.lib\n      ...(win ? downloadNodeLib() : []),\n      // write the \"installVersion\" file\n      fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n      // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n      ...(!tarPath || win ? [downloadShasums()] : [])\n    ])\n\n    log.verbose('download contents checksum', JSON.stringify(contentShasums))\n    // check content shasums\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const archs = ['ia32', 'x64', 'arm64']\n      return archs.map(async (arch) => {\n        const dir = path.resolve(devDir, arch)\n        const targetLibPath = path.resolve(dir, release.name + '.lib')\n        const { libUrl, libPath } = release[arch]\n        const name = `${arch} ${release.name}.lib`\n        log.verbose(name, 'dir', dir)\n        log.verbose(name, 'url', libUrl)\n\n        await fs.promises.mkdir(dir, { recursive: true })\n        log.verbose('streaming', name, 'to:', targetLibPath)\n\n        const res = await download(gyp, libUrl)\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`)\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`)\n          }\n          return\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`)\n        }\n\n        return streamPipeline(\n          res.body,\n          new ShaSum((_, checksum) => {\n            contentShasums[libPath] = checksum\n            log.verbose('content checksum', libPath, checksum)\n          }),\n          fs.createWriteStream(targetLibPath)\n        )\n      })\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}