{"ast":null,"code":"'use strict';\n\nvar sourcemapCodec = require('sourcemap-codec');\n\nclass BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n  }\n\n  add(n) {\n    this.bits[n >> 5] |= 1 << (n & 31);\n  }\n\n  has(n) {\n    return !!(this.bits[n >> 5] & 1 << (n & 31));\n  }\n\n}\n\nclass Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = '';\n    this.outro = '';\n    this.content = content;\n    this.storeName = false;\n    this.edited = false; // we make these non-enumerable, for sanity while debugging\n\n    Object.defineProperties(this, {\n      previous: {\n        writable: true,\n        value: null\n      },\n      next: {\n        writable: true,\n        value: null\n      }\n    });\n  }\n\n  appendLeft(content) {\n    this.outro += content;\n  }\n\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n\n  clone() {\n    const chunk = new Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n\n  eachNext(fn) {\n    let chunk = this;\n\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n\n  eachPrevious(fn) {\n    let chunk = this;\n\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n\n    if (!contentOnly) {\n      this.intro = '';\n      this.outro = '';\n    }\n\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = '';\n    this.end = index;\n\n    if (this.edited) {\n      // TODO is this block necessary?...\n      newChunk.edit('', false);\n      this.content = '';\n    } else {\n      this.content = originalBefore;\n    }\n\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit('', undefined, true);\n      }\n\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.intro = this.intro.replace(rx, '');\n      if (this.intro.length) return true;\n    }\n  }\n\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.end - trimmed.length);\n        this.edit('', undefined, true);\n      }\n\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.outro = this.outro.replace(rx, '');\n      if (this.outro.length) return true;\n    }\n  }\n\n}\n\nlet btoa = () => {\n  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n  btoa = str => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n  btoa = str => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nclass SourceMap {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = sourcemapCodec.encode(properties.mappings);\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toUrl() {\n    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n  }\n\n}\n\nfunction guessIndent(code) {\n  const lines = code.split('\\n');\n  const tabbed = lines.filter(line => /^\\t+/.test(line));\n  const spaced = lines.filter(line => /^ {2,}/.test(line));\n\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  } // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n\n\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  } // Otherwise, we need to guess the multiple\n\n\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n\n  if (fromParts.length) {\n    let i = fromParts.length;\n\n    while (i--) fromParts[i] = '..';\n  }\n\n  return fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n  const originalLines = source.split('\\n');\n  const lineOffsets = [];\n\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n\n    while (i < j) {\n      const m = i + j >> 1;\n\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return {\n      line,\n      column\n    };\n  };\n}\n\nclass Mappings {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n\n      this.rawSegments.push(segment);\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n    }\n\n    this.advance(content);\n    this.pending = null;\n  }\n\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n\n    while (originalCharIndex < chunk.end) {\n      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n      }\n\n      if (original[originalCharIndex] === '\\n') {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n\n      originalCharIndex += 1;\n    }\n\n    this.pending = null;\n  }\n\n  advance(str) {\n    if (!str) return;\n    const lines = str.split('\\n');\n\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n\n      this.generatedCodeColumn = 0;\n    }\n\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n\n}\n\nconst n = '\\n';\nconst warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\n\nclass MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk(0, string.length, string);\n    Object.defineProperties(this, {\n      original: {\n        writable: true,\n        value: string\n      },\n      outro: {\n        writable: true,\n        value: ''\n      },\n      intro: {\n        writable: true,\n        value: ''\n      },\n      firstChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastSearchedChunk: {\n        writable: true,\n        value: chunk\n      },\n      byStart: {\n        writable: true,\n        value: {}\n      },\n      byEnd: {\n        writable: true,\n        value: {}\n      },\n      filename: {\n        writable: true,\n        value: options.filename\n      },\n      indentExclusionRanges: {\n        writable: true,\n        value: options.indentExclusionRanges\n      },\n      sourcemapLocations: {\n        writable: true,\n        value: new BitSet()\n      },\n      storedNames: {\n        writable: true,\n        value: {}\n      },\n      indentStr: {\n        writable: true,\n        value: guessIndent(string)\n      }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n\n  append(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.outro += content;\n    return this;\n  }\n\n  appendLeft(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byEnd[index];\n\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n\n    return this;\n  }\n\n  appendRight(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byStart[index];\n\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n\n    return this;\n  }\n\n  clone() {\n    const cloned = new MagicString(this.original, {\n      filename: this.filename\n    });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n\n      originalChunk = nextOriginalChunk;\n    }\n\n    cloned.lastChunk = clonedChunk;\n\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n\n    this.firstChunk.eachNext(chunk => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n\n      if (chunk.edited) {\n        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n      sourcesContent: options.includeContent ? [this.original] : [null],\n      names,\n      mappings: mappings.raw\n    };\n  }\n\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n\n  getIndentString() {\n    return this.indentStr === null ? '\\t' : this.indentStr;\n  }\n\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = undefined;\n    }\n\n    indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n    if (indentStr === '') return this; // noop\n\n    options = options || {}; // Process exclusion ranges\n\n    const isExcluded = {};\n\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n      exclusions.forEach(exclusion => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n\n    let shouldIndentNextCharacter = options.indentStart !== false;\n\n    const replacer = match => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n\n    while (chunk) {\n      const end = chunk.end;\n\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n\n            if (char === '\\n') {\n              shouldIndentNextCharacter = true;\n            } else if (char !== '\\r' && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n\n          charIndex += 1;\n        }\n      }\n\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n\n  insert() {\n    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n  }\n\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\n      warned.insertLeft = true;\n    }\n\n    return this.appendLeft(index, content);\n  }\n\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\n      warned.insertRight = true;\n    }\n\n    return this.prependRight(index, content);\n  }\n\n  move(start, end, index) {\n    if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n    this._split(start);\n\n    this._split(end);\n\n    this._split(index);\n\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n\n  overwrite(start, end, content, options) {\n    if (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n    while (start < 0) start += this.original.length;\n\n    while (end < 0) end += this.original.length;\n\n    if (end > this.original.length) throw new Error('end is out of bounds');\n    if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n\n    this._split(start);\n\n    this._split(end);\n\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\n        warned.storeName = true;\n      }\n\n      options = {\n        storeName: true\n      };\n    }\n\n    const storeName = options !== undefined ? options.storeName : false;\n    const contentOnly = options !== undefined ? options.contentOnly : false;\n\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n\n    if (first) {\n      let chunk = first;\n\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error('Cannot overwrite across a split point');\n        }\n\n        chunk = chunk.next;\n        chunk.edit('', false);\n      }\n\n      first.edit(content, storeName, contentOnly);\n    } else {\n      // must be inserting at the end\n      const newChunk = new Chunk(start, end, '').edit(content, storeName); // TODO last chunk in the array may not be the last chunk, if it's moved...\n\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n\n    return this;\n  }\n\n  prepend(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.intro = content + this.intro;\n    return this;\n  }\n\n  prependLeft(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byEnd[index];\n\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n\n    return this;\n  }\n\n  prependRight(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byStart[index];\n\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n\n    return this;\n  }\n\n  remove(start, end) {\n    while (start < 0) start += this.original.length;\n\n    while (end < 0) end += this.original.length;\n\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n    if (start > end) throw new Error('end must be greater than start');\n\n    this._split(start);\n\n    this._split(end);\n\n    let chunk = this.byStart[start];\n\n    while (chunk) {\n      chunk.intro = '';\n      chunk.outro = '';\n      chunk.edit('');\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n\n    return this;\n  }\n\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return '';\n  }\n\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n\n  slice(start = 0, end = this.original.length) {\n    while (start < 0) start += this.original.length;\n\n    while (end < 0) end += this.original.length;\n\n    let result = ''; // find start chunk\n\n    let chunk = this.firstChunk;\n\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      // found end chunk before start\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n\n      chunk = chunk.next;\n    }\n\n    if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n\n      if (containsEnd) {\n        break;\n      }\n\n      chunk = chunk.next;\n    }\n\n    return result;\n  } // TODO deprecate this? not really very useful\n\n\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    const searchForward = index > chunk.end;\n\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  }\n\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      // zero-length edited chunks are a special case (overlapping replacements)\n      const loc = getLocator(this.original)(index);\n      throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`);\n    }\n\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n\n    return str + this.outro;\n  }\n\n  isEmpty() {\n    let chunk = this.firstChunk;\n\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;\n    } while (chunk = chunk.next);\n\n    return true;\n  }\n\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n\n    return length;\n  }\n\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx); // if chunk was trimmed, we have a new lastChunk\n\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n\n    return false;\n  }\n\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n\n  trimStartAborted(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n\n      if (chunk.end !== end) {\n        // special case...\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n\n    return false;\n  }\n\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n\n  replace(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === 'string') {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n          if (i === '$') return '$';\n          if (i === '&') return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n\n      return matches;\n    }\n\n    if (typeof searchValue !== 'string' && searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach(match => {\n        if (match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));\n    }\n\n    return this;\n  }\n\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n  constructor(options = {}) {\n    this.intro = options.intro || '';\n    this.separator = options.separator !== undefined ? options.separator : '\\n';\n    this.sources = [];\n    this.uniqueSources = [];\n    this.uniqueSourceIndexByFilename = {};\n  }\n\n  addSource(source) {\n    if (source instanceof MagicString) {\n      return this.addSource({\n        content: source,\n        filename: source.filename,\n        separator: this.separator\n      });\n    }\n\n    if (!isObject(source) || !source.content) {\n      throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n    }\n\n    ['filename', 'indentExclusionRanges', 'separator'].forEach(option => {\n      if (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n    });\n\n    if (source.separator === undefined) {\n      // TODO there's a bunch of this sort of thing, needs cleaning up\n      source.separator = this.separator;\n    }\n\n    if (source.filename) {\n      if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n        this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n        this.uniqueSources.push({\n          filename: source.filename,\n          content: source.content.original\n        });\n      } else {\n        const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\n        if (source.content.original !== uniqueSource.content) {\n          throw new Error(`Illegal source: same filename (${source.filename}), different contents`);\n        }\n      }\n    }\n\n    this.sources.push(source);\n    return this;\n  }\n\n  append(str, options) {\n    this.addSource({\n      content: new MagicString(str),\n      separator: options && options.separator || ''\n    });\n    return this;\n  }\n\n  clone() {\n    const bundle = new Bundle({\n      intro: this.intro,\n      separator: this.separator\n    });\n    this.sources.forEach(source => {\n      bundle.addSource({\n        filename: source.filename,\n        content: source.content.clone(),\n        separator: source.separator\n      });\n    });\n    return bundle;\n  }\n\n  generateDecodedMap(options = {}) {\n    const names = [];\n    this.sources.forEach(source => {\n      Object.keys(source.content.storedNames).forEach(name => {\n        if (!~names.indexOf(name)) names.push(name);\n      });\n    });\n    const mappings = new Mappings(options.hires);\n\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n\n    this.sources.forEach((source, i) => {\n      if (i > 0) {\n        mappings.advance(this.separator);\n      }\n\n      const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n      const magicString = source.content;\n      const locate = getLocator(magicString.original);\n\n      if (magicString.intro) {\n        mappings.advance(magicString.intro);\n      }\n\n      magicString.firstChunk.eachNext(chunk => {\n        const loc = locate(chunk.start);\n        if (chunk.intro.length) mappings.advance(chunk.intro);\n\n        if (source.filename) {\n          if (chunk.edited) {\n            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n          } else {\n            mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n          }\n        } else {\n          mappings.advance(chunk.content);\n        }\n\n        if (chunk.outro.length) mappings.advance(chunk.outro);\n      });\n\n      if (magicString.outro) {\n        mappings.advance(magicString.outro);\n      }\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: this.uniqueSources.map(source => {\n        return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n      }),\n      sourcesContent: this.uniqueSources.map(source => {\n        return options.includeContent ? source.content : null;\n      }),\n      names,\n      mappings: mappings.raw\n    };\n  }\n\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n\n  getIndentString() {\n    const indentStringCounts = {};\n    this.sources.forEach(source => {\n      const indentStr = source.content.indentStr;\n      if (indentStr === null) return;\n      if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n      indentStringCounts[indentStr] += 1;\n    });\n    return Object.keys(indentStringCounts).sort((a, b) => {\n      return indentStringCounts[a] - indentStringCounts[b];\n    })[0] || '\\t';\n  }\n\n  indent(indentStr) {\n    if (!arguments.length) {\n      indentStr = this.getIndentString();\n    }\n\n    if (indentStr === '') return this; // noop\n\n    let trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n    this.sources.forEach((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n      source.content.indent(indentStr, {\n        exclude: source.indentExclusionRanges,\n        indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\n      });\n      trailingNewline = source.content.lastChar() === '\\n';\n    });\n\n    if (this.intro) {\n      this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, (match, index) => {\n        return index > 0 ? indentStr + match : match;\n      });\n    }\n\n    return this;\n  }\n\n  prepend(str) {\n    this.intro = str + this.intro;\n    return this;\n  }\n\n  toString() {\n    const body = this.sources.map((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const str = (i > 0 ? separator : '') + source.content.toString();\n      return str;\n    }).join('');\n    return this.intro + body;\n  }\n\n  isEmpty() {\n    if (this.intro.length && this.intro.trim()) return false;\n    if (this.sources.some(source => !source.content.isEmpty())) return false;\n    return true;\n  }\n\n  length() {\n    return this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n  }\n\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n\n  trimStart(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n\n    if (!this.intro) {\n      let source;\n      let i = 0;\n\n      do {\n        source = this.sources[i++];\n\n        if (!source) {\n          break;\n        }\n      } while (!source.content.trimStartAborted(charType));\n    }\n\n    return this;\n  }\n\n  trimEnd(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    let source;\n    let i = this.sources.length - 1;\n\n    do {\n      source = this.sources[i--];\n\n      if (!source) {\n        this.intro = this.intro.replace(rx, '');\n        break;\n      }\n    } while (!source.content.trimEndAborted(charType));\n\n    return this;\n  }\n\n}\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString;","map":{"version":3,"names":["sourcemapCodec","require","BitSet","constructor","arg","bits","slice","add","n","has","Chunk","start","end","content","original","intro","outro","storeName","edited","Object","defineProperties","previous","writable","value","next","appendLeft","appendRight","clone","chunk","contains","index","eachNext","fn","eachPrevious","edit","contentOnly","prependLeft","prependRight","split","sliceIndex","originalBefore","originalAfter","newChunk","toString","trimEnd","rx","replace","length","trimmed","undefined","trimStart","btoa","Error","window","str","unescape","encodeURIComponent","Buffer","from","SourceMap","properties","version","file","sources","sourcesContent","names","mappings","encode","JSON","stringify","toUrl","guessIndent","code","lines","tabbed","filter","line","test","spaced","min","reduce","current","numSpaces","exec","Math","Infinity","Array","join","getRelativePath","to","fromParts","toParts","pop","shift","i","concat","prototype","isObject","thing","call","getLocator","source","originalLines","lineOffsets","pos","push","locate","j","m","column","Mappings","hires","generatedCodeLine","generatedCodeColumn","raw","rawSegments","pending","addEdit","sourceIndex","loc","nameIndex","segment","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","warned","insertLeft","insertRight","MagicString","string","options","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","filename","indentExclusionRanges","storedNames","indentStr","addSourcemapLocation","char","append","TypeError","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","keys","indexOf","includeContent","generateMap","getIndentString","indent","pattern","isExcluded","exclude","exclusions","forEach","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","console","warn","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","defineProperty","enumerable","prepend","remove","lastChar","lastLine","lineIndex","lastIndexOf","substr","lineStr","result","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trim","trimLines","charType","trimEndAborted","RegExp","aborted","trimStartAborted","hasChanged","searchValue","replacement","getReplacement","_","num","groups","matchAll","re","matches","global","hasOwnProp","hasOwnProperty","Bundle","separator","uniqueSources","uniqueSourceIndexByFilename","addSource","option","uniqueSource","bundle","name","magicString","map","indentStringCounts","sort","a","b","arguments","trailingNewline","body","some","default","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/magic-string/dist/magic-string.cjs.js"],"sourcesContent":["'use strict';\n\nvar sourcemapCodec = require('sourcemap-codec');\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = sourcemapCodec.encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (typeof searchValue !== 'string' && searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null)\n\t\t\t\tthis.overwrite(\n\t\t\t\t\tmatch.index,\n\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}