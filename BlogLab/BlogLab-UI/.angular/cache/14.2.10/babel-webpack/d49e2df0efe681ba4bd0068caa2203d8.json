{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleMemoryHost = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst exception_1 = require(\"../../exception\");\n\nconst path_1 = require(\"../path\");\n\nclass SimpleMemoryHost {\n  constructor() {\n    this._cache = new Map();\n    this._watchers = new Map();\n\n    this._cache.set((0, path_1.normalize)('/'), this._newDirStats());\n  }\n\n  _newDirStats() {\n    return {\n      inspect() {\n        return '<Directory>';\n      },\n\n      isFile() {\n        return false;\n      },\n\n      isDirectory() {\n        return true;\n      },\n\n      size: 0,\n      atime: new Date(),\n      ctime: new Date(),\n      mtime: new Date(),\n      birthtime: new Date(),\n      content: null\n    };\n  }\n\n  _newFileStats(content, oldStats) {\n    return {\n      inspect() {\n        return `<File size(${content.byteLength})>`;\n      },\n\n      isFile() {\n        return true;\n      },\n\n      isDirectory() {\n        return false;\n      },\n\n      size: content.byteLength,\n      atime: oldStats ? oldStats.atime : new Date(),\n      ctime: new Date(),\n      mtime: new Date(),\n      birthtime: oldStats ? oldStats.birthtime : new Date(),\n      content\n    };\n  }\n\n  _toAbsolute(path) {\n    return (0, path_1.isAbsolute)(path) ? path : (0, path_1.normalize)('/' + path);\n  }\n\n  _updateWatchers(path, type) {\n    const time = new Date();\n    let currentPath = path;\n    let parent = null;\n\n    if (this._watchers.size == 0) {\n      // Nothing to do if there's no watchers.\n      return;\n    }\n\n    const maybeWatcher = this._watchers.get(currentPath);\n\n    if (maybeWatcher) {\n      maybeWatcher.forEach(watcher => {\n        const [options, subject] = watcher;\n        subject.next({\n          path,\n          time,\n          type\n        });\n\n        if (!options.persistent && type == 2\n        /* HostWatchEventType.Deleted */\n        ) {\n          subject.complete();\n\n          this._watchers.delete(currentPath);\n        }\n      });\n    }\n\n    do {\n      currentPath = parent !== null ? parent : currentPath;\n      parent = (0, path_1.dirname)(currentPath);\n\n      const maybeWatcher = this._watchers.get(currentPath);\n\n      if (maybeWatcher) {\n        maybeWatcher.forEach(watcher => {\n          const [options, subject] = watcher;\n\n          if (!options.recursive) {\n            return;\n          }\n\n          subject.next({\n            path,\n            time,\n            type\n          });\n\n          if (!options.persistent && type == 2\n          /* HostWatchEventType.Deleted */\n          ) {\n            subject.complete();\n\n            this._watchers.delete(currentPath);\n          }\n        });\n      }\n    } while (parent != currentPath);\n  }\n\n  get capabilities() {\n    return {\n      synchronous: true\n    };\n  }\n  /**\n   * List of protected methods that give direct access outside the observables to the cache\n   * and internal states.\n   */\n\n\n  _write(path, content) {\n    path = this._toAbsolute(path);\n\n    const old = this._cache.get(path);\n\n    if (old && old.isDirectory()) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } // Update all directories. If we find a file we know it's an invalid write.\n\n\n    const fragments = (0, path_1.split)(path);\n    let curr = (0, path_1.normalize)('/');\n\n    for (const fr of fragments) {\n      curr = (0, path_1.join)(curr, fr);\n\n      const maybeStats = this._cache.get(fr);\n\n      if (maybeStats) {\n        if (maybeStats.isFile()) {\n          throw new exception_1.PathIsFileException(curr);\n        }\n      } else {\n        this._cache.set(curr, this._newDirStats());\n      }\n    } // Create the stats.\n\n\n    const stats = this._newFileStats(content, old);\n\n    this._cache.set(path, stats);\n\n    this._updateWatchers(path, old ? 0\n    /* HostWatchEventType.Changed */\n    : 1\n    /* HostWatchEventType.Created */\n    );\n  }\n\n  _read(path) {\n    path = this._toAbsolute(path);\n\n    const maybeStats = this._cache.get(path);\n\n    if (!maybeStats) {\n      throw new exception_1.FileDoesNotExistException(path);\n    } else if (maybeStats.isDirectory()) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } else if (!maybeStats.content) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } else {\n      return maybeStats.content;\n    }\n  }\n\n  _delete(path) {\n    path = this._toAbsolute(path);\n\n    if (this._isDirectory(path)) {\n      for (const [cachePath] of this._cache.entries()) {\n        if (cachePath.startsWith(path + path_1.NormalizedSep) || cachePath === path) {\n          this._cache.delete(cachePath);\n        }\n      }\n    } else {\n      this._cache.delete(path);\n    }\n\n    this._updateWatchers(path, 2\n    /* HostWatchEventType.Deleted */\n    );\n  }\n\n  _rename(from, to) {\n    from = this._toAbsolute(from);\n    to = this._toAbsolute(to);\n\n    if (!this._cache.has(from)) {\n      throw new exception_1.FileDoesNotExistException(from);\n    } else if (this._cache.has(to)) {\n      throw new exception_1.FileAlreadyExistException(to);\n    }\n\n    if (this._isDirectory(from)) {\n      for (const path of this._cache.keys()) {\n        if (path.startsWith(from + path_1.NormalizedSep)) {\n          const content = this._cache.get(path);\n\n          if (content) {\n            // We don't need to clone or extract the content, since we're moving files.\n            this._cache.set((0, path_1.join)(to, path_1.NormalizedSep, path.slice(from.length)), content);\n          }\n        }\n      }\n    } else {\n      const content = this._cache.get(from);\n\n      if (content) {\n        const fragments = (0, path_1.split)(to);\n        const newDirectories = [];\n        let curr = (0, path_1.normalize)('/');\n\n        for (const fr of fragments) {\n          curr = (0, path_1.join)(curr, fr);\n\n          const maybeStats = this._cache.get(fr);\n\n          if (maybeStats) {\n            if (maybeStats.isFile()) {\n              throw new exception_1.PathIsFileException(curr);\n            }\n          } else {\n            newDirectories.push(curr);\n          }\n        }\n\n        for (const newDirectory of newDirectories) {\n          this._cache.set(newDirectory, this._newDirStats());\n        }\n\n        this._cache.delete(from);\n\n        this._cache.set(to, content);\n      }\n    }\n\n    this._updateWatchers(from, 3\n    /* HostWatchEventType.Renamed */\n    );\n  }\n\n  _list(path) {\n    path = this._toAbsolute(path);\n\n    if (this._isFile(path)) {\n      throw new exception_1.PathIsFileException(path);\n    }\n\n    const fragments = (0, path_1.split)(path);\n    const result = new Set();\n\n    if (path !== path_1.NormalizedRoot) {\n      for (const p of this._cache.keys()) {\n        if (p.startsWith(path + path_1.NormalizedSep)) {\n          result.add((0, path_1.split)(p)[fragments.length]);\n        }\n      }\n    } else {\n      for (const p of this._cache.keys()) {\n        if (p.startsWith(path_1.NormalizedSep) && p !== path_1.NormalizedRoot) {\n          result.add((0, path_1.split)(p)[1]);\n        }\n      }\n    }\n\n    return [...result];\n  }\n\n  _exists(path) {\n    return !!this._cache.get(this._toAbsolute(path));\n  }\n\n  _isDirectory(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n\n    return maybeStats ? maybeStats.isDirectory() : false;\n  }\n\n  _isFile(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n\n    return maybeStats ? maybeStats.isFile() : false;\n  }\n\n  _stat(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n\n    if (!maybeStats) {\n      return null;\n    } else {\n      return maybeStats;\n    }\n  }\n\n  _watch(path, options) {\n    path = this._toAbsolute(path);\n    const subject = new rxjs_1.Subject();\n\n    let maybeWatcherArray = this._watchers.get(path);\n\n    if (!maybeWatcherArray) {\n      maybeWatcherArray = [];\n\n      this._watchers.set(path, maybeWatcherArray);\n    }\n\n    maybeWatcherArray.push([options || {}, subject]);\n    return subject.asObservable();\n  }\n\n  write(path, content) {\n    return new rxjs_1.Observable(obs => {\n      this._write(path, content);\n\n      obs.next();\n      obs.complete();\n    });\n  }\n\n  read(path) {\n    return new rxjs_1.Observable(obs => {\n      const content = this._read(path);\n\n      obs.next(content);\n      obs.complete();\n    });\n  }\n\n  delete(path) {\n    return new rxjs_1.Observable(obs => {\n      this._delete(path);\n\n      obs.next();\n      obs.complete();\n    });\n  }\n\n  rename(from, to) {\n    return new rxjs_1.Observable(obs => {\n      this._rename(from, to);\n\n      obs.next();\n      obs.complete();\n    });\n  }\n\n  list(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._list(path));\n      obs.complete();\n    });\n  }\n\n  exists(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._exists(path));\n      obs.complete();\n    });\n  }\n\n  isDirectory(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._isDirectory(path));\n      obs.complete();\n    });\n  }\n\n  isFile(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._isFile(path));\n      obs.complete();\n    });\n  } // Some hosts may not support stat.\n\n\n  stat(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._stat(path));\n      obs.complete();\n    });\n  }\n\n  watch(path, options) {\n    return this._watch(path, options);\n  }\n\n  reset() {\n    this._cache.clear();\n\n    this._watchers.clear();\n  }\n\n}\n\nexports.SimpleMemoryHost = SimpleMemoryHost;","map":{"version":3,"names":["Object","defineProperty","exports","value","SimpleMemoryHost","rxjs_1","require","exception_1","path_1","constructor","_cache","Map","_watchers","set","normalize","_newDirStats","inspect","isFile","isDirectory","size","atime","Date","ctime","mtime","birthtime","content","_newFileStats","oldStats","byteLength","_toAbsolute","path","isAbsolute","_updateWatchers","type","time","currentPath","parent","maybeWatcher","get","forEach","watcher","options","subject","next","persistent","complete","delete","dirname","recursive","capabilities","synchronous","_write","old","PathIsDirectoryException","fragments","split","curr","fr","join","maybeStats","PathIsFileException","stats","_read","FileDoesNotExistException","_delete","_isDirectory","cachePath","entries","startsWith","NormalizedSep","_rename","from","to","has","FileAlreadyExistException","keys","slice","length","newDirectories","push","newDirectory","_list","_isFile","result","Set","NormalizedRoot","p","add","_exists","_stat","_watch","Subject","maybeWatcherArray","asObservable","write","Observable","obs","read","rename","list","exists","stat","watch","reset","clear"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/core/src/virtual-fs/host/memory.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleMemoryHost = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst exception_1 = require(\"../../exception\");\nconst path_1 = require(\"../path\");\nclass SimpleMemoryHost {\n    constructor() {\n        this._cache = new Map();\n        this._watchers = new Map();\n        this._cache.set((0, path_1.normalize)('/'), this._newDirStats());\n    }\n    _newDirStats() {\n        return {\n            inspect() {\n                return '<Directory>';\n            },\n            isFile() {\n                return false;\n            },\n            isDirectory() {\n                return true;\n            },\n            size: 0,\n            atime: new Date(),\n            ctime: new Date(),\n            mtime: new Date(),\n            birthtime: new Date(),\n            content: null,\n        };\n    }\n    _newFileStats(content, oldStats) {\n        return {\n            inspect() {\n                return `<File size(${content.byteLength})>`;\n            },\n            isFile() {\n                return true;\n            },\n            isDirectory() {\n                return false;\n            },\n            size: content.byteLength,\n            atime: oldStats ? oldStats.atime : new Date(),\n            ctime: new Date(),\n            mtime: new Date(),\n            birthtime: oldStats ? oldStats.birthtime : new Date(),\n            content,\n        };\n    }\n    _toAbsolute(path) {\n        return (0, path_1.isAbsolute)(path) ? path : (0, path_1.normalize)('/' + path);\n    }\n    _updateWatchers(path, type) {\n        const time = new Date();\n        let currentPath = path;\n        let parent = null;\n        if (this._watchers.size == 0) {\n            // Nothing to do if there's no watchers.\n            return;\n        }\n        const maybeWatcher = this._watchers.get(currentPath);\n        if (maybeWatcher) {\n            maybeWatcher.forEach((watcher) => {\n                const [options, subject] = watcher;\n                subject.next({ path, time, type });\n                if (!options.persistent && type == 2 /* HostWatchEventType.Deleted */) {\n                    subject.complete();\n                    this._watchers.delete(currentPath);\n                }\n            });\n        }\n        do {\n            currentPath = parent !== null ? parent : currentPath;\n            parent = (0, path_1.dirname)(currentPath);\n            const maybeWatcher = this._watchers.get(currentPath);\n            if (maybeWatcher) {\n                maybeWatcher.forEach((watcher) => {\n                    const [options, subject] = watcher;\n                    if (!options.recursive) {\n                        return;\n                    }\n                    subject.next({ path, time, type });\n                    if (!options.persistent && type == 2 /* HostWatchEventType.Deleted */) {\n                        subject.complete();\n                        this._watchers.delete(currentPath);\n                    }\n                });\n            }\n        } while (parent != currentPath);\n    }\n    get capabilities() {\n        return { synchronous: true };\n    }\n    /**\n     * List of protected methods that give direct access outside the observables to the cache\n     * and internal states.\n     */\n    _write(path, content) {\n        path = this._toAbsolute(path);\n        const old = this._cache.get(path);\n        if (old && old.isDirectory()) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        // Update all directories. If we find a file we know it's an invalid write.\n        const fragments = (0, path_1.split)(path);\n        let curr = (0, path_1.normalize)('/');\n        for (const fr of fragments) {\n            curr = (0, path_1.join)(curr, fr);\n            const maybeStats = this._cache.get(fr);\n            if (maybeStats) {\n                if (maybeStats.isFile()) {\n                    throw new exception_1.PathIsFileException(curr);\n                }\n            }\n            else {\n                this._cache.set(curr, this._newDirStats());\n            }\n        }\n        // Create the stats.\n        const stats = this._newFileStats(content, old);\n        this._cache.set(path, stats);\n        this._updateWatchers(path, old ? 0 /* HostWatchEventType.Changed */ : 1 /* HostWatchEventType.Created */);\n    }\n    _read(path) {\n        path = this._toAbsolute(path);\n        const maybeStats = this._cache.get(path);\n        if (!maybeStats) {\n            throw new exception_1.FileDoesNotExistException(path);\n        }\n        else if (maybeStats.isDirectory()) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        else if (!maybeStats.content) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        else {\n            return maybeStats.content;\n        }\n    }\n    _delete(path) {\n        path = this._toAbsolute(path);\n        if (this._isDirectory(path)) {\n            for (const [cachePath] of this._cache.entries()) {\n                if (cachePath.startsWith(path + path_1.NormalizedSep) || cachePath === path) {\n                    this._cache.delete(cachePath);\n                }\n            }\n        }\n        else {\n            this._cache.delete(path);\n        }\n        this._updateWatchers(path, 2 /* HostWatchEventType.Deleted */);\n    }\n    _rename(from, to) {\n        from = this._toAbsolute(from);\n        to = this._toAbsolute(to);\n        if (!this._cache.has(from)) {\n            throw new exception_1.FileDoesNotExistException(from);\n        }\n        else if (this._cache.has(to)) {\n            throw new exception_1.FileAlreadyExistException(to);\n        }\n        if (this._isDirectory(from)) {\n            for (const path of this._cache.keys()) {\n                if (path.startsWith(from + path_1.NormalizedSep)) {\n                    const content = this._cache.get(path);\n                    if (content) {\n                        // We don't need to clone or extract the content, since we're moving files.\n                        this._cache.set((0, path_1.join)(to, path_1.NormalizedSep, path.slice(from.length)), content);\n                    }\n                }\n            }\n        }\n        else {\n            const content = this._cache.get(from);\n            if (content) {\n                const fragments = (0, path_1.split)(to);\n                const newDirectories = [];\n                let curr = (0, path_1.normalize)('/');\n                for (const fr of fragments) {\n                    curr = (0, path_1.join)(curr, fr);\n                    const maybeStats = this._cache.get(fr);\n                    if (maybeStats) {\n                        if (maybeStats.isFile()) {\n                            throw new exception_1.PathIsFileException(curr);\n                        }\n                    }\n                    else {\n                        newDirectories.push(curr);\n                    }\n                }\n                for (const newDirectory of newDirectories) {\n                    this._cache.set(newDirectory, this._newDirStats());\n                }\n                this._cache.delete(from);\n                this._cache.set(to, content);\n            }\n        }\n        this._updateWatchers(from, 3 /* HostWatchEventType.Renamed */);\n    }\n    _list(path) {\n        path = this._toAbsolute(path);\n        if (this._isFile(path)) {\n            throw new exception_1.PathIsFileException(path);\n        }\n        const fragments = (0, path_1.split)(path);\n        const result = new Set();\n        if (path !== path_1.NormalizedRoot) {\n            for (const p of this._cache.keys()) {\n                if (p.startsWith(path + path_1.NormalizedSep)) {\n                    result.add((0, path_1.split)(p)[fragments.length]);\n                }\n            }\n        }\n        else {\n            for (const p of this._cache.keys()) {\n                if (p.startsWith(path_1.NormalizedSep) && p !== path_1.NormalizedRoot) {\n                    result.add((0, path_1.split)(p)[1]);\n                }\n            }\n        }\n        return [...result];\n    }\n    _exists(path) {\n        return !!this._cache.get(this._toAbsolute(path));\n    }\n    _isDirectory(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        return maybeStats ? maybeStats.isDirectory() : false;\n    }\n    _isFile(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        return maybeStats ? maybeStats.isFile() : false;\n    }\n    _stat(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        if (!maybeStats) {\n            return null;\n        }\n        else {\n            return maybeStats;\n        }\n    }\n    _watch(path, options) {\n        path = this._toAbsolute(path);\n        const subject = new rxjs_1.Subject();\n        let maybeWatcherArray = this._watchers.get(path);\n        if (!maybeWatcherArray) {\n            maybeWatcherArray = [];\n            this._watchers.set(path, maybeWatcherArray);\n        }\n        maybeWatcherArray.push([options || {}, subject]);\n        return subject.asObservable();\n    }\n    write(path, content) {\n        return new rxjs_1.Observable((obs) => {\n            this._write(path, content);\n            obs.next();\n            obs.complete();\n        });\n    }\n    read(path) {\n        return new rxjs_1.Observable((obs) => {\n            const content = this._read(path);\n            obs.next(content);\n            obs.complete();\n        });\n    }\n    delete(path) {\n        return new rxjs_1.Observable((obs) => {\n            this._delete(path);\n            obs.next();\n            obs.complete();\n        });\n    }\n    rename(from, to) {\n        return new rxjs_1.Observable((obs) => {\n            this._rename(from, to);\n            obs.next();\n            obs.complete();\n        });\n    }\n    list(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._list(path));\n            obs.complete();\n        });\n    }\n    exists(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._exists(path));\n            obs.complete();\n        });\n    }\n    isDirectory(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._isDirectory(path));\n            obs.complete();\n        });\n    }\n    isFile(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._isFile(path));\n            obs.complete();\n        });\n    }\n    // Some hosts may not support stat.\n    stat(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._stat(path));\n            obs.complete();\n        });\n    }\n    watch(path, options) {\n        return this._watch(path, options);\n    }\n    reset() {\n        this._cache.clear();\n        this._watchers.clear();\n    }\n}\nexports.SimpleMemoryHost = SimpleMemoryHost;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}