{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilterHostTree = exports.HostCreateTree = exports.HostTree = exports.HostDirEntry = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst jsonc_parser_1 = require(\"jsonc-parser\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst util_1 = require(\"util\");\n\nconst exception_1 = require(\"../exception/exception\");\n\nconst delegate_1 = require(\"./delegate\");\n\nconst entry_1 = require(\"./entry\");\n\nconst interface_1 = require(\"./interface\");\n\nconst recorder_1 = require(\"./recorder\");\n\nconst scoped_1 = require(\"./scoped\");\n\nlet _uniqueId = 0;\n\nclass HostDirEntry {\n  constructor(parent, path, _host, _tree) {\n    this.parent = parent;\n    this.path = path;\n    this._host = _host;\n    this._tree = _tree;\n  }\n\n  get subdirs() {\n    return this._host.list(this.path).filter(fragment => this._host.isDirectory((0, core_1.join)(this.path, fragment)));\n  }\n\n  get subfiles() {\n    return this._host.list(this.path).filter(fragment => this._host.isFile((0, core_1.join)(this.path, fragment)));\n  }\n\n  dir(name) {\n    return this._tree.getDir((0, core_1.join)(this.path, name));\n  }\n\n  file(name) {\n    return this._tree.get((0, core_1.join)(this.path, name));\n  }\n\n  visit(visitor) {\n    try {\n      this.getSubfilesRecursively().forEach(file => visitor(file.path, file));\n    } catch (e) {\n      if (e !== interface_1.FileVisitorCancelToken) {\n        throw e;\n      }\n    }\n  }\n\n  getSubfilesRecursively() {\n    function _recurse(entry) {\n      return entry.subdirs.reduce((files, subdir) => [...files, ..._recurse(entry.dir(subdir))], entry.subfiles.map(subfile => entry.file(subfile)));\n    }\n\n    return _recurse(this);\n  }\n\n}\n\nexports.HostDirEntry = HostDirEntry;\n\nclass HostTree {\n  constructor(_backend = new core_1.virtualFs.Empty()) {\n    this._backend = _backend;\n    this._id = --_uniqueId;\n    this._ancestry = new Set();\n    this._dirCache = new Map();\n    this._record = new core_1.virtualFs.CordHost(new core_1.virtualFs.SafeReadonlyHost(_backend));\n    this._recordSync = new core_1.virtualFs.SyncDelegateHost(this._record);\n  }\n\n  [interface_1.TreeSymbol]() {\n    return this;\n  }\n\n  static isHostTree(tree) {\n    if (tree instanceof HostTree) {\n      return true;\n    }\n\n    if (typeof tree === 'object' && typeof tree._ancestry === 'object') {\n      return true;\n    }\n\n    return false;\n  }\n\n  _normalizePath(path) {\n    return (0, core_1.normalize)('/' + path);\n  }\n\n  _willCreate(path) {\n    return this._record.willCreate(path);\n  }\n\n  _willOverwrite(path) {\n    return this._record.willOverwrite(path);\n  }\n\n  _willDelete(path) {\n    return this._record.willDelete(path);\n  }\n\n  _willRename(path) {\n    return this._record.willRename(path);\n  }\n\n  branch() {\n    const branchedTree = new HostTree(this._backend);\n    branchedTree._record = this._record.clone();\n    branchedTree._recordSync = new core_1.virtualFs.SyncDelegateHost(branchedTree._record);\n    branchedTree._ancestry = new Set(this._ancestry).add(this._id);\n    return branchedTree;\n  }\n\n  isAncestorOf(tree) {\n    if (tree instanceof HostTree) {\n      return tree._ancestry.has(this._id);\n    }\n\n    if (tree instanceof delegate_1.DelegateTree) {\n      return this.isAncestorOf(tree._other);\n    }\n\n    if (tree instanceof scoped_1.ScopedTree) {\n      return this.isAncestorOf(tree._base);\n    }\n\n    return false;\n  }\n\n  merge(other, strategy = interface_1.MergeStrategy.Default) {\n    if (other === this) {\n      // Merging with yourself? Tsk tsk. Nothing to do at least.\n      return;\n    }\n\n    if (this.isAncestorOf(other)) {\n      // Workaround for merging a branch back into one of its ancestors\n      // More complete branch point tracking is required to avoid\n      strategy |= interface_1.MergeStrategy.Overwrite;\n    }\n\n    const creationConflictAllowed = (strategy & interface_1.MergeStrategy.AllowCreationConflict) == interface_1.MergeStrategy.AllowCreationConflict;\n    const overwriteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowOverwriteConflict) == interface_1.MergeStrategy.AllowOverwriteConflict;\n    const deleteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowDeleteConflict) == interface_1.MergeStrategy.AllowDeleteConflict;\n    other.actions.forEach(action => {\n      switch (action.kind) {\n        case 'c':\n          {\n            const {\n              path,\n              content\n            } = action;\n\n            if (this._willCreate(path) || this._willOverwrite(path) || this.exists(path)) {\n              const existingContent = this.read(path);\n\n              if (existingContent && content.equals(existingContent)) {\n                // Identical outcome; no action required\n                return;\n              }\n\n              if (!creationConflictAllowed) {\n                throw new exception_1.MergeConflictException(path);\n              }\n\n              this._record.overwrite(path, content).subscribe();\n            } else {\n              this._record.create(path, content).subscribe();\n            }\n\n            return;\n          }\n\n        case 'o':\n          {\n            const {\n              path,\n              content\n            } = action;\n\n            if (this._willDelete(path) && !overwriteConflictAllowed) {\n              throw new exception_1.MergeConflictException(path);\n            } // Ignore if content is the same (considered the same change).\n\n\n            if (this._willOverwrite(path)) {\n              const existingContent = this.read(path);\n\n              if (existingContent && content.equals(existingContent)) {\n                // Identical outcome; no action required\n                return;\n              }\n\n              if (!overwriteConflictAllowed) {\n                throw new exception_1.MergeConflictException(path);\n              }\n            } // We use write here as merge validation has already been done, and we want to let\n            // the CordHost do its job.\n\n\n            this._record.write(path, content).subscribe();\n\n            return;\n          }\n\n        case 'r':\n          {\n            const {\n              path,\n              to\n            } = action;\n\n            if (this._willDelete(path)) {\n              throw new exception_1.MergeConflictException(path);\n            }\n\n            if (this._willRename(path)) {\n              if (this._record.willRenameTo(path, to)) {\n                // Identical outcome; no action required\n                return;\n              } // No override possible for renaming.\n\n\n              throw new exception_1.MergeConflictException(path);\n            }\n\n            this.rename(path, to);\n            return;\n          }\n\n        case 'd':\n          {\n            const {\n              path\n            } = action;\n\n            if (this._willDelete(path)) {\n              // TODO: This should technically check the content (e.g., hash on delete)\n              // Identical outcome; no action required\n              return;\n            }\n\n            if (!this.exists(path) && !deleteConflictAllowed) {\n              throw new exception_1.MergeConflictException(path);\n            }\n\n            this._recordSync.delete(path);\n\n            return;\n          }\n      }\n    });\n  }\n\n  get root() {\n    return this.getDir('/');\n  } // Readonly.\n\n\n  read(path) {\n    const entry = this.get(path);\n    return entry ? entry.content : null;\n  }\n\n  readText(path) {\n    const data = this.read(path);\n\n    if (data === null) {\n      throw new exception_1.FileDoesNotExistException(path);\n    }\n\n    const decoder = new util_1.TextDecoder('utf-8', {\n      fatal: true\n    });\n\n    try {\n      // With the `fatal` option enabled, invalid data will throw a TypeError\n      return decoder.decode(data);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        throw new Error(`Failed to decode \"${path}\" as UTF-8 text.`);\n      }\n\n      throw e;\n    }\n  }\n\n  readJson(path) {\n    const content = this.readText(path);\n    const errors = [];\n    const result = (0, jsonc_parser_1.parse)(content, errors, {\n      allowTrailingComma: true\n    }); // If there is a parse error throw with the error information\n\n    if (errors[0]) {\n      const {\n        error,\n        offset\n      } = errors[0];\n      throw new Error(`Failed to parse \"${path}\" as JSON. ${(0, jsonc_parser_1.printParseErrorCode)(error)} at offset: ${offset}.`);\n    }\n\n    return result;\n  }\n\n  exists(path) {\n    return this._recordSync.isFile(this._normalizePath(path));\n  }\n\n  get(path) {\n    const p = this._normalizePath(path);\n\n    if (this._recordSync.isDirectory(p)) {\n      throw new core_1.PathIsDirectoryException(p);\n    }\n\n    if (!this._recordSync.exists(p)) {\n      return null;\n    }\n\n    return new entry_1.LazyFileEntry(p, () => Buffer.from(this._recordSync.read(p)));\n  }\n\n  getDir(path) {\n    const p = this._normalizePath(path);\n\n    if (this._recordSync.isFile(p)) {\n      throw new core_1.PathIsFileException(p);\n    }\n\n    let maybeCache = this._dirCache.get(p);\n\n    if (!maybeCache) {\n      let parent = (0, core_1.dirname)(p);\n\n      if (p === parent) {\n        parent = null;\n      }\n\n      maybeCache = new HostDirEntry(parent && this.getDir(parent), p, this._recordSync, this);\n\n      this._dirCache.set(p, maybeCache);\n    }\n\n    return maybeCache;\n  }\n\n  visit(visitor) {\n    this.root.visit((path, entry) => {\n      visitor(path, entry);\n    });\n  } // Change content of host files.\n\n\n  overwrite(path, content) {\n    const p = this._normalizePath(path);\n\n    if (!this._recordSync.exists(p)) {\n      throw new exception_1.FileDoesNotExistException(p);\n    }\n\n    const c = typeof content == 'string' ? Buffer.from(content) : content;\n\n    this._record.overwrite(p, c).subscribe();\n  }\n\n  beginUpdate(path) {\n    const entry = this.get(path);\n\n    if (!entry) {\n      throw new exception_1.FileDoesNotExistException(path);\n    }\n\n    return recorder_1.UpdateRecorderBase.createFromFileEntry(entry);\n  }\n\n  commitUpdate(record) {\n    if (record instanceof recorder_1.UpdateRecorderBase) {\n      const path = record.path;\n      const entry = this.get(path);\n\n      if (!entry) {\n        throw new exception_1.ContentHasMutatedException(path);\n      } else {\n        const newContent = record.apply(entry.content);\n\n        if (!newContent.equals(entry.content)) {\n          this.overwrite(path, newContent);\n        }\n      }\n    } else {\n      throw new exception_1.InvalidUpdateRecordException();\n    }\n  } // Structural methods.\n\n\n  create(path, content) {\n    const p = this._normalizePath(path);\n\n    if (this._recordSync.exists(p)) {\n      throw new exception_1.FileAlreadyExistException(p);\n    }\n\n    const c = typeof content == 'string' ? Buffer.from(content) : content;\n\n    this._record.create(p, c).subscribe();\n  }\n\n  delete(path) {\n    this._recordSync.delete(this._normalizePath(path));\n  }\n\n  rename(from, to) {\n    this._recordSync.rename(this._normalizePath(from), this._normalizePath(to));\n  }\n\n  apply(action, strategy) {\n    throw new exception_1.SchematicsException('Apply not implemented on host trees.');\n  }\n\n  *generateActions() {\n    for (const record of this._record.records()) {\n      switch (record.kind) {\n        case 'create':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'c',\n            path: record.path,\n            content: Buffer.from(record.content)\n          };\n          break;\n\n        case 'overwrite':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'o',\n            path: record.path,\n            content: Buffer.from(record.content)\n          };\n          break;\n\n        case 'rename':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'r',\n            path: record.from,\n            to: record.to\n          };\n          break;\n\n        case 'delete':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'd',\n            path: record.path\n          };\n          break;\n      }\n    }\n  }\n\n  get actions() {\n    // Create a list of all records until we hit our original backend. This is to support branches\n    // that diverge from each others.\n    return Array.from(this.generateActions());\n  }\n\n}\n\nexports.HostTree = HostTree;\n\nclass HostCreateTree extends HostTree {\n  constructor(host) {\n    super();\n    const tempHost = new HostTree(host);\n    tempHost.visit(path => {\n      const content = tempHost.read(path);\n\n      if (content) {\n        this.create(path, content);\n      }\n    });\n  }\n\n}\n\nexports.HostCreateTree = HostCreateTree;\n\nclass FilterHostTree extends HostTree {\n  constructor(tree, filter = () => true) {\n    const newBackend = new core_1.virtualFs.SimpleMemoryHost(); // cast to allow access\n\n    const originalBackend = tree._backend;\n\n    const recurse = base => {\n      return originalBackend.list(base).pipe((0, operators_1.mergeMap)(x => x), (0, operators_1.map)(path => (0, core_1.join)(base, path)), (0, operators_1.concatMap)(path => {\n        let isDirectory = false;\n        originalBackend.isDirectory(path).subscribe(val => isDirectory = val);\n\n        if (isDirectory) {\n          return recurse(path);\n        }\n\n        let isFile = false;\n        originalBackend.isFile(path).subscribe(val => isFile = val);\n\n        if (!isFile || !filter(path)) {\n          return rxjs_1.EMPTY;\n        }\n\n        let content = null;\n        originalBackend.read(path).subscribe(val => content = val);\n\n        if (!content) {\n          return rxjs_1.EMPTY;\n        }\n\n        return newBackend.write(path, content);\n      }));\n    };\n\n    recurse((0, core_1.normalize)('/')).subscribe();\n    super(newBackend);\n\n    for (const action of tree.actions) {\n      if (!filter(action.path)) {\n        continue;\n      }\n\n      switch (action.kind) {\n        case 'c':\n          this.create(action.path, action.content);\n          break;\n\n        case 'd':\n          this.delete(action.path);\n          break;\n\n        case 'o':\n          this.overwrite(action.path, action.content);\n          break;\n\n        case 'r':\n          this.rename(action.path, action.to);\n          break;\n      }\n    }\n  }\n\n}\n\nexports.FilterHostTree = FilterHostTree;","map":{"version":3,"names":["Object","defineProperty","exports","value","FilterHostTree","HostCreateTree","HostTree","HostDirEntry","core_1","require","jsonc_parser_1","rxjs_1","operators_1","util_1","exception_1","delegate_1","entry_1","interface_1","recorder_1","scoped_1","_uniqueId","constructor","parent","path","_host","_tree","subdirs","list","filter","fragment","isDirectory","join","subfiles","isFile","dir","name","getDir","file","get","visit","visitor","getSubfilesRecursively","forEach","e","FileVisitorCancelToken","_recurse","entry","reduce","files","subdir","map","subfile","_backend","virtualFs","Empty","_id","_ancestry","Set","_dirCache","Map","_record","CordHost","SafeReadonlyHost","_recordSync","SyncDelegateHost","TreeSymbol","isHostTree","tree","_normalizePath","normalize","_willCreate","willCreate","_willOverwrite","willOverwrite","_willDelete","willDelete","_willRename","willRename","branch","branchedTree","clone","add","isAncestorOf","has","DelegateTree","_other","ScopedTree","_base","merge","other","strategy","MergeStrategy","Default","Overwrite","creationConflictAllowed","AllowCreationConflict","overwriteConflictAllowed","AllowOverwriteConflict","deleteConflictAllowed","AllowDeleteConflict","actions","action","kind","content","exists","existingContent","read","equals","MergeConflictException","overwrite","subscribe","create","write","to","willRenameTo","rename","delete","root","readText","data","FileDoesNotExistException","decoder","TextDecoder","fatal","decode","TypeError","Error","readJson","errors","result","parse","allowTrailingComma","error","offset","printParseErrorCode","p","PathIsDirectoryException","LazyFileEntry","Buffer","from","PathIsFileException","maybeCache","dirname","set","c","beginUpdate","UpdateRecorderBase","createFromFileEntry","commitUpdate","record","ContentHasMutatedException","newContent","apply","InvalidUpdateRecordException","FileAlreadyExistException","SchematicsException","generateActions","records","id","Array","host","tempHost","newBackend","SimpleMemoryHost","originalBackend","recurse","base","pipe","mergeMap","x","concatMap","val","EMPTY"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular-devkit/schematics/src/tree/host-tree.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FilterHostTree = exports.HostCreateTree = exports.HostTree = exports.HostDirEntry = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst util_1 = require(\"util\");\nconst exception_1 = require(\"../exception/exception\");\nconst delegate_1 = require(\"./delegate\");\nconst entry_1 = require(\"./entry\");\nconst interface_1 = require(\"./interface\");\nconst recorder_1 = require(\"./recorder\");\nconst scoped_1 = require(\"./scoped\");\nlet _uniqueId = 0;\nclass HostDirEntry {\n    constructor(parent, path, _host, _tree) {\n        this.parent = parent;\n        this.path = path;\n        this._host = _host;\n        this._tree = _tree;\n    }\n    get subdirs() {\n        return this._host\n            .list(this.path)\n            .filter((fragment) => this._host.isDirectory((0, core_1.join)(this.path, fragment)));\n    }\n    get subfiles() {\n        return this._host\n            .list(this.path)\n            .filter((fragment) => this._host.isFile((0, core_1.join)(this.path, fragment)));\n    }\n    dir(name) {\n        return this._tree.getDir((0, core_1.join)(this.path, name));\n    }\n    file(name) {\n        return this._tree.get((0, core_1.join)(this.path, name));\n    }\n    visit(visitor) {\n        try {\n            this.getSubfilesRecursively().forEach((file) => visitor(file.path, file));\n        }\n        catch (e) {\n            if (e !== interface_1.FileVisitorCancelToken) {\n                throw e;\n            }\n        }\n    }\n    getSubfilesRecursively() {\n        function _recurse(entry) {\n            return entry.subdirs.reduce((files, subdir) => [...files, ..._recurse(entry.dir(subdir))], entry.subfiles.map((subfile) => entry.file(subfile)));\n        }\n        return _recurse(this);\n    }\n}\nexports.HostDirEntry = HostDirEntry;\nclass HostTree {\n    constructor(_backend = new core_1.virtualFs.Empty()) {\n        this._backend = _backend;\n        this._id = --_uniqueId;\n        this._ancestry = new Set();\n        this._dirCache = new Map();\n        this._record = new core_1.virtualFs.CordHost(new core_1.virtualFs.SafeReadonlyHost(_backend));\n        this._recordSync = new core_1.virtualFs.SyncDelegateHost(this._record);\n    }\n    [interface_1.TreeSymbol]() {\n        return this;\n    }\n    static isHostTree(tree) {\n        if (tree instanceof HostTree) {\n            return true;\n        }\n        if (typeof tree === 'object' && typeof tree._ancestry === 'object') {\n            return true;\n        }\n        return false;\n    }\n    _normalizePath(path) {\n        return (0, core_1.normalize)('/' + path);\n    }\n    _willCreate(path) {\n        return this._record.willCreate(path);\n    }\n    _willOverwrite(path) {\n        return this._record.willOverwrite(path);\n    }\n    _willDelete(path) {\n        return this._record.willDelete(path);\n    }\n    _willRename(path) {\n        return this._record.willRename(path);\n    }\n    branch() {\n        const branchedTree = new HostTree(this._backend);\n        branchedTree._record = this._record.clone();\n        branchedTree._recordSync = new core_1.virtualFs.SyncDelegateHost(branchedTree._record);\n        branchedTree._ancestry = new Set(this._ancestry).add(this._id);\n        return branchedTree;\n    }\n    isAncestorOf(tree) {\n        if (tree instanceof HostTree) {\n            return tree._ancestry.has(this._id);\n        }\n        if (tree instanceof delegate_1.DelegateTree) {\n            return this.isAncestorOf(tree._other);\n        }\n        if (tree instanceof scoped_1.ScopedTree) {\n            return this.isAncestorOf(tree._base);\n        }\n        return false;\n    }\n    merge(other, strategy = interface_1.MergeStrategy.Default) {\n        if (other === this) {\n            // Merging with yourself? Tsk tsk. Nothing to do at least.\n            return;\n        }\n        if (this.isAncestorOf(other)) {\n            // Workaround for merging a branch back into one of its ancestors\n            // More complete branch point tracking is required to avoid\n            strategy |= interface_1.MergeStrategy.Overwrite;\n        }\n        const creationConflictAllowed = (strategy & interface_1.MergeStrategy.AllowCreationConflict) == interface_1.MergeStrategy.AllowCreationConflict;\n        const overwriteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowOverwriteConflict) == interface_1.MergeStrategy.AllowOverwriteConflict;\n        const deleteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowDeleteConflict) == interface_1.MergeStrategy.AllowDeleteConflict;\n        other.actions.forEach((action) => {\n            switch (action.kind) {\n                case 'c': {\n                    const { path, content } = action;\n                    if (this._willCreate(path) || this._willOverwrite(path) || this.exists(path)) {\n                        const existingContent = this.read(path);\n                        if (existingContent && content.equals(existingContent)) {\n                            // Identical outcome; no action required\n                            return;\n                        }\n                        if (!creationConflictAllowed) {\n                            throw new exception_1.MergeConflictException(path);\n                        }\n                        this._record.overwrite(path, content).subscribe();\n                    }\n                    else {\n                        this._record.create(path, content).subscribe();\n                    }\n                    return;\n                }\n                case 'o': {\n                    const { path, content } = action;\n                    if (this._willDelete(path) && !overwriteConflictAllowed) {\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    // Ignore if content is the same (considered the same change).\n                    if (this._willOverwrite(path)) {\n                        const existingContent = this.read(path);\n                        if (existingContent && content.equals(existingContent)) {\n                            // Identical outcome; no action required\n                            return;\n                        }\n                        if (!overwriteConflictAllowed) {\n                            throw new exception_1.MergeConflictException(path);\n                        }\n                    }\n                    // We use write here as merge validation has already been done, and we want to let\n                    // the CordHost do its job.\n                    this._record.write(path, content).subscribe();\n                    return;\n                }\n                case 'r': {\n                    const { path, to } = action;\n                    if (this._willDelete(path)) {\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    if (this._willRename(path)) {\n                        if (this._record.willRenameTo(path, to)) {\n                            // Identical outcome; no action required\n                            return;\n                        }\n                        // No override possible for renaming.\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    this.rename(path, to);\n                    return;\n                }\n                case 'd': {\n                    const { path } = action;\n                    if (this._willDelete(path)) {\n                        // TODO: This should technically check the content (e.g., hash on delete)\n                        // Identical outcome; no action required\n                        return;\n                    }\n                    if (!this.exists(path) && !deleteConflictAllowed) {\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    this._recordSync.delete(path);\n                    return;\n                }\n            }\n        });\n    }\n    get root() {\n        return this.getDir('/');\n    }\n    // Readonly.\n    read(path) {\n        const entry = this.get(path);\n        return entry ? entry.content : null;\n    }\n    readText(path) {\n        const data = this.read(path);\n        if (data === null) {\n            throw new exception_1.FileDoesNotExistException(path);\n        }\n        const decoder = new util_1.TextDecoder('utf-8', { fatal: true });\n        try {\n            // With the `fatal` option enabled, invalid data will throw a TypeError\n            return decoder.decode(data);\n        }\n        catch (e) {\n            if (e instanceof TypeError) {\n                throw new Error(`Failed to decode \"${path}\" as UTF-8 text.`);\n            }\n            throw e;\n        }\n    }\n    readJson(path) {\n        const content = this.readText(path);\n        const errors = [];\n        const result = (0, jsonc_parser_1.parse)(content, errors, { allowTrailingComma: true });\n        // If there is a parse error throw with the error information\n        if (errors[0]) {\n            const { error, offset } = errors[0];\n            throw new Error(`Failed to parse \"${path}\" as JSON. ${(0, jsonc_parser_1.printParseErrorCode)(error)} at offset: ${offset}.`);\n        }\n        return result;\n    }\n    exists(path) {\n        return this._recordSync.isFile(this._normalizePath(path));\n    }\n    get(path) {\n        const p = this._normalizePath(path);\n        if (this._recordSync.isDirectory(p)) {\n            throw new core_1.PathIsDirectoryException(p);\n        }\n        if (!this._recordSync.exists(p)) {\n            return null;\n        }\n        return new entry_1.LazyFileEntry(p, () => Buffer.from(this._recordSync.read(p)));\n    }\n    getDir(path) {\n        const p = this._normalizePath(path);\n        if (this._recordSync.isFile(p)) {\n            throw new core_1.PathIsFileException(p);\n        }\n        let maybeCache = this._dirCache.get(p);\n        if (!maybeCache) {\n            let parent = (0, core_1.dirname)(p);\n            if (p === parent) {\n                parent = null;\n            }\n            maybeCache = new HostDirEntry(parent && this.getDir(parent), p, this._recordSync, this);\n            this._dirCache.set(p, maybeCache);\n        }\n        return maybeCache;\n    }\n    visit(visitor) {\n        this.root.visit((path, entry) => {\n            visitor(path, entry);\n        });\n    }\n    // Change content of host files.\n    overwrite(path, content) {\n        const p = this._normalizePath(path);\n        if (!this._recordSync.exists(p)) {\n            throw new exception_1.FileDoesNotExistException(p);\n        }\n        const c = typeof content == 'string' ? Buffer.from(content) : content;\n        this._record.overwrite(p, c).subscribe();\n    }\n    beginUpdate(path) {\n        const entry = this.get(path);\n        if (!entry) {\n            throw new exception_1.FileDoesNotExistException(path);\n        }\n        return recorder_1.UpdateRecorderBase.createFromFileEntry(entry);\n    }\n    commitUpdate(record) {\n        if (record instanceof recorder_1.UpdateRecorderBase) {\n            const path = record.path;\n            const entry = this.get(path);\n            if (!entry) {\n                throw new exception_1.ContentHasMutatedException(path);\n            }\n            else {\n                const newContent = record.apply(entry.content);\n                if (!newContent.equals(entry.content)) {\n                    this.overwrite(path, newContent);\n                }\n            }\n        }\n        else {\n            throw new exception_1.InvalidUpdateRecordException();\n        }\n    }\n    // Structural methods.\n    create(path, content) {\n        const p = this._normalizePath(path);\n        if (this._recordSync.exists(p)) {\n            throw new exception_1.FileAlreadyExistException(p);\n        }\n        const c = typeof content == 'string' ? Buffer.from(content) : content;\n        this._record.create(p, c).subscribe();\n    }\n    delete(path) {\n        this._recordSync.delete(this._normalizePath(path));\n    }\n    rename(from, to) {\n        this._recordSync.rename(this._normalizePath(from), this._normalizePath(to));\n    }\n    apply(action, strategy) {\n        throw new exception_1.SchematicsException('Apply not implemented on host trees.');\n    }\n    *generateActions() {\n        for (const record of this._record.records()) {\n            switch (record.kind) {\n                case 'create':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'c',\n                        path: record.path,\n                        content: Buffer.from(record.content),\n                    };\n                    break;\n                case 'overwrite':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'o',\n                        path: record.path,\n                        content: Buffer.from(record.content),\n                    };\n                    break;\n                case 'rename':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'r',\n                        path: record.from,\n                        to: record.to,\n                    };\n                    break;\n                case 'delete':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'd',\n                        path: record.path,\n                    };\n                    break;\n            }\n        }\n    }\n    get actions() {\n        // Create a list of all records until we hit our original backend. This is to support branches\n        // that diverge from each others.\n        return Array.from(this.generateActions());\n    }\n}\nexports.HostTree = HostTree;\nclass HostCreateTree extends HostTree {\n    constructor(host) {\n        super();\n        const tempHost = new HostTree(host);\n        tempHost.visit((path) => {\n            const content = tempHost.read(path);\n            if (content) {\n                this.create(path, content);\n            }\n        });\n    }\n}\nexports.HostCreateTree = HostCreateTree;\nclass FilterHostTree extends HostTree {\n    constructor(tree, filter = () => true) {\n        const newBackend = new core_1.virtualFs.SimpleMemoryHost();\n        // cast to allow access\n        const originalBackend = tree._backend;\n        const recurse = (base) => {\n            return originalBackend.list(base).pipe((0, operators_1.mergeMap)((x) => x), (0, operators_1.map)((path) => (0, core_1.join)(base, path)), (0, operators_1.concatMap)((path) => {\n                let isDirectory = false;\n                originalBackend.isDirectory(path).subscribe((val) => (isDirectory = val));\n                if (isDirectory) {\n                    return recurse(path);\n                }\n                let isFile = false;\n                originalBackend.isFile(path).subscribe((val) => (isFile = val));\n                if (!isFile || !filter(path)) {\n                    return rxjs_1.EMPTY;\n                }\n                let content = null;\n                originalBackend.read(path).subscribe((val) => (content = val));\n                if (!content) {\n                    return rxjs_1.EMPTY;\n                }\n                return newBackend.write(path, content);\n            }));\n        };\n        recurse((0, core_1.normalize)('/')).subscribe();\n        super(newBackend);\n        for (const action of tree.actions) {\n            if (!filter(action.path)) {\n                continue;\n            }\n            switch (action.kind) {\n                case 'c':\n                    this.create(action.path, action.content);\n                    break;\n                case 'd':\n                    this.delete(action.path);\n                    break;\n                case 'o':\n                    this.overwrite(action.path, action.content);\n                    break;\n                case 'r':\n                    this.rename(action.path, action.to);\n                    break;\n            }\n        }\n    }\n}\nexports.FilterHostTree = FilterHostTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}