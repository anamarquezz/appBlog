{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst fs = require('@npmcli/fs');\n\nconst move = require('@npmcli/move-file');\n\nconst pinflight = require('promise-inflight');\n\nmodule.exports = moveFile;\n\nfunction moveFile(_x, _x2) {\n  return _moveFile.apply(this, arguments);\n}\n\nfunction _moveFile() {\n  _moveFile = _asyncToGenerator(function* (src, dest) {\n    const isWindows = process.platform === 'win32'; // This isn't quite an fs.rename -- the assumption is that\n    // if `dest` already exists, and we get certain errors while\n    // trying to move it, we should just not bother.\n    //\n    // In the case of cache corruption, users will receive an\n    // EINTEGRITY error elsewhere, and can remove the offending\n    // content their own way.\n    //\n    // Note that, as the name suggests, this strictly only supports file moves.\n\n    try {\n      yield fs.link(src, dest);\n    } catch (err) {\n      if (isWindows && err.code === 'EPERM') {// XXX This is a really weird way to handle this situation, as it\n        // results in the src file being deleted even though the dest\n        // might not exist.  Since we pretty much always write files to\n        // deterministic locations based on content hash, this is likely\n        // ok (or at worst, just ends in a future cache miss).  But it would\n        // be worth investigating at some time in the future if this is\n        // really what we want to do here.\n      } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {// file already exists, so whatever\n      } else {\n        throw err;\n      }\n    }\n\n    try {\n      yield Promise.all([fs.unlink(src), !isWindows && fs.chmod(dest, '0444')]);\n    } catch (e) {\n      return pinflight('cacache-move-file:' + dest, /*#__PURE__*/_asyncToGenerator(function* () {\n        yield fs.stat(dest).catch(err => {\n          if (err.code !== 'ENOENT') {\n            // Something else is wrong here. Bail bail bail\n            throw err;\n          }\n        }); // file doesn't already exist! let's try a rename -> copy fallback\n        // only delete if it successfully copies\n\n        return move(src, dest);\n      }));\n    }\n  });\n  return _moveFile.apply(this, arguments);\n}","map":{"version":3,"names":["fs","require","move","pinflight","module","exports","moveFile","src","dest","isWindows","process","platform","link","err","code","Promise","all","unlink","chmod","e","stat","catch"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/cacache/lib/util/move-file.js"],"sourcesContent":["'use strict'\n\nconst fs = require('@npmcli/fs')\nconst move = require('@npmcli/move-file')\nconst pinflight = require('promise-inflight')\n\nmodule.exports = moveFile\n\nasync function moveFile (src, dest) {\n  const isWindows = process.platform === 'win32'\n\n  // This isn't quite an fs.rename -- the assumption is that\n  // if `dest` already exists, and we get certain errors while\n  // trying to move it, we should just not bother.\n  //\n  // In the case of cache corruption, users will receive an\n  // EINTEGRITY error elsewhere, and can remove the offending\n  // content their own way.\n  //\n  // Note that, as the name suggests, this strictly only supports file moves.\n  try {\n    await fs.link(src, dest)\n  } catch (err) {\n    if (isWindows && err.code === 'EPERM') {\n      // XXX This is a really weird way to handle this situation, as it\n      // results in the src file being deleted even though the dest\n      // might not exist.  Since we pretty much always write files to\n      // deterministic locations based on content hash, this is likely\n      // ok (or at worst, just ends in a future cache miss).  But it would\n      // be worth investigating at some time in the future if this is\n      // really what we want to do here.\n    } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {\n      // file already exists, so whatever\n    } else {\n      throw err\n    }\n  }\n  try {\n    await Promise.all([\n      fs.unlink(src),\n      !isWindows && fs.chmod(dest, '0444'),\n    ])\n  } catch (e) {\n    return pinflight('cacache-move-file:' + dest, async () => {\n      await fs.stat(dest).catch((err) => {\n        if (err.code !== 'ENOENT') {\n          // Something else is wrong here. Bail bail bail\n          throw err\n        }\n      })\n      // file doesn't already exist! let's try a rename -> copy fallback\n      // only delete if it successfully copies\n      return move(src, dest)\n    })\n  }\n}\n"],"mappings":"AAAA;;;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,YAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,mBAAD,CAApB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,kBAAD,CAAzB;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,QAAjB;;SAEeA,Q;;;;;gCAAf,WAAyBC,GAAzB,EAA8BC,IAA9B,EAAoC;IAClC,MAAMC,SAAS,GAAGC,OAAO,CAACC,QAAR,KAAqB,OAAvC,CADkC,CAGlC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,IAAI;MACF,MAAMX,EAAE,CAACY,IAAH,CAAQL,GAAR,EAAaC,IAAb,CAAN;IACD,CAFD,CAEE,OAAOK,GAAP,EAAY;MACZ,IAAIJ,SAAS,IAAII,GAAG,CAACC,IAAJ,KAAa,OAA9B,EAAuC,CACrC;QACA;QACA;QACA;QACA;QACA;QACA;MACD,CARD,MAQO,IAAID,GAAG,CAACC,IAAJ,KAAa,QAAb,IAAyBD,GAAG,CAACC,IAAJ,KAAa,OAA1C,EAAmD,CACxD;MACD,CAFM,MAEA;QACL,MAAMD,GAAN;MACD;IACF;;IACD,IAAI;MACF,MAAME,OAAO,CAACC,GAAR,CAAY,CAChBhB,EAAE,CAACiB,MAAH,CAAUV,GAAV,CADgB,EAEhB,CAACE,SAAD,IAAcT,EAAE,CAACkB,KAAH,CAASV,IAAT,EAAe,MAAf,CAFE,CAAZ,CAAN;IAID,CALD,CAKE,OAAOW,CAAP,EAAU;MACV,OAAOhB,SAAS,CAAC,uBAAuBK,IAAxB,iCAA8B,aAAY;QACxD,MAAMR,EAAE,CAACoB,IAAH,CAAQZ,IAAR,EAAca,KAAd,CAAqBR,GAAD,IAAS;UACjC,IAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;YACzB;YACA,MAAMD,GAAN;UACD;QACF,CALK,CAAN,CADwD,CAOxD;QACA;;QACA,OAAOX,IAAI,CAACK,GAAD,EAAMC,IAAN,CAAX;MACD,CAVe,EAAhB;IAWD;EACF,C"},"metadata":{},"sourceType":"script"}