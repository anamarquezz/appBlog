{"ast":null,"code":"var _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\n// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\nconst bundled = require('npm-bundled');\n\nconst {\n  promisify\n} = require('util');\n\nconst fs = require('fs');\n\nconst readFile = promisify(fs.readFile);\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\n\nconst {\n  relative,\n  resolve,\n  basename,\n  dirname\n} = require('path');\n\nconst normalizePackageBin = require('npm-normalize-package-bin');\n\nconst readPackage = ({\n  path,\n  packageJsonCache\n}) => packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path)) : readFile(path).then(json => {\n  const pkg = normalizePackageBin(JSON.parse(json));\n  packageJsonCache.set(path, pkg);\n  return pkg;\n}).catch(er => null); // just normalize bundle deps and bin, that's all we care about here.\n\n\nconst normalized = Symbol('package data has been normalized');\n\nconst rpj = ({\n  path,\n  packageJsonCache\n}) => readPackage({\n  path,\n  packageJsonCache\n}).then(pkg => {\n  if (!pkg || pkg[normalized]) return pkg;\n\n  if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundledDependencies;\n    delete pkg.bundledDependencies;\n  }\n\n  const bd = pkg.bundleDependencies;\n\n  if (bd === true) {\n    pkg.bundleDependencies = [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.optionalDependencies || {})];\n  }\n\n  if (typeof bd === 'object' && !Array.isArray(bd)) {\n    pkg.bundleDependencies = Object.keys(bd);\n  }\n\n  pkg[normalized] = true;\n  return pkg;\n});\n\nconst pkgContents = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    path,\n    depth,\n    currentDepth = 0,\n    pkg = null,\n    result = null,\n    packageJsonCache = null\n  }) {\n    if (!result) result = new Set();\n    if (!packageJsonCache) packageJsonCache = new Map();\n\n    if (pkg === true) {\n      return rpj({\n        path: path + '/package.json',\n        packageJsonCache\n      }).then(pkg => pkgContents({\n        path,\n        depth,\n        currentDepth,\n        pkg,\n        result,\n        packageJsonCache\n      }));\n    }\n\n    if (pkg) {\n      // add all bins to result if they exist\n      if (pkg.bin) {\n        const dir = dirname(path);\n        const base = basename(path);\n        const scope = basename(dir);\n        const nm = /^@.+/.test(scope) ? dirname(dir) : dir;\n        const binFiles = [];\n        Object.keys(pkg.bin).forEach(b => {\n          const base = resolve(nm, '.bin', b);\n          binFiles.push(base, base + '.cmd', base + '.ps1');\n        });\n        const bins = yield Promise.all(binFiles.map(b => stat(b).then(() => b).catch(er => null)));\n        bins.filter(b => b).forEach(b => result.add(b));\n      }\n    }\n\n    if (currentDepth >= depth) {\n      result.add(path);\n      return result;\n    } // we'll need bundle list later, so get that now in parallel\n\n\n    const [dirEntries, bundleDeps] = yield Promise.all([readdir(path, {\n      withFileTypes: true\n    }), currentDepth === 0 && pkg && pkg.bundleDependencies ? bundled({\n      path,\n      packageJsonCache\n    }) : null]).catch(() => []); // not a thing, probably a missing folder\n\n    if (!dirEntries) return result; // empty folder, just add the folder itself to the result\n\n    if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n      result.add(path);\n      return result;\n    }\n\n    const recursePromises = []; // if we didn't get withFileTypes support, tack that on\n\n    if (typeof dirEntries[0] === 'string') {\n      // use a map so we can return a promise, but we mutate dirEntries in place\n      // this is much slower than getting the entries from the readdir call,\n      // but polyfills support for node versions before 10.10\n      yield Promise.all(dirEntries.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (name, index) {\n          const p = resolve(path, name);\n          const st = yield lstat(p);\n          dirEntries[index] = Object.assign(st, {\n            name\n          });\n        });\n\n        return function (_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n    }\n\n    for (const entry of dirEntries) {\n      const p = resolve(path, entry.name);\n\n      if (entry.isDirectory() === false) {\n        result.add(p);\n        continue;\n      }\n\n      if (currentDepth !== 0 || entry.name !== 'node_modules') {\n        if (currentDepth < depth - 1) {\n          recursePromises.push(pkgContents({\n            path: p,\n            packageJsonCache,\n            depth,\n            currentDepth: currentDepth + 1,\n            result\n          }));\n        } else {\n          result.add(p);\n        }\n\n        continue;\n      }\n    }\n\n    if (bundleDeps) {\n      // bundle deps are all folders\n      // we always recurse to get pkg bins, but if currentDepth is too high,\n      // it'll return early before walking their contents.\n      recursePromises.push(...bundleDeps.map(dep => {\n        const p = resolve(path, 'node_modules', dep);\n        return pkgContents({\n          path: p,\n          packageJsonCache,\n          pkg: true,\n          depth,\n          currentDepth: currentDepth + 1,\n          result\n        });\n      }));\n    }\n\n    if (recursePromises.length) yield Promise.all(recursePromises);\n    return result;\n  });\n\n  return function pkgContents(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = ({\n  path,\n  depth = 1,\n  packageJsonCache\n}) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache\n}).then(results => [...results]);\n\nif (require.main === module) {\n  const options = {\n    path: null,\n    depth: 1\n  };\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`;\n  process.argv.slice(2).forEach(arg => {\n    let match;\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) || (match = arg.match(/^-d([0-9]+|Infinity)/))) options.depth = +match[1];else if (arg === '-h' || arg === '--help') {\n      console.log(usage);\n      process.exit(0);\n    } else options.path = arg;\n  });\n\n  if (!options.path) {\n    console.error('ERROR: no path provided');\n    console.error(usage);\n    process.exit(1);\n  }\n\n  const cwd = process.cwd();\n  module.exports(options).then(list => list.sort().forEach(p => console.log(relative(cwd, p)))).catch(\n  /* istanbul ignore next - pretty unusual */\n  er => {\n    console.error(er);\n    process.exit(1);\n  });\n}","map":{"version":3,"names":["bundled","require","promisify","fs","readFile","readdir","stat","lstat","relative","resolve","basename","dirname","normalizePackageBin","readPackage","path","packageJsonCache","has","Promise","get","then","json","pkg","JSON","parse","set","catch","er","normalized","Symbol","rpj","bundledDependencies","bundleDependencies","bd","Object","keys","dependencies","optionalDependencies","Array","isArray","pkgContents","depth","currentDepth","result","Set","Map","bin","dir","base","scope","nm","test","binFiles","forEach","b","push","bins","all","map","filter","add","dirEntries","bundleDeps","withFileTypes","length","recursePromises","name","index","p","st","assign","entry","isDirectory","dep","module","exports","results","main","options","usage","process","argv","slice","arg","match","console","log","exit","error","cwd","list","sort"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@npmcli/installed-package-contents/index.js"],"sourcesContent":["// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\n\nconst bundled = require('npm-bundled')\nconst {promisify} = require('util')\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst readdir = promisify(fs.readdir)\nconst stat = promisify(fs.stat)\nconst lstat = promisify(fs.lstat)\nconst {relative, resolve, basename, dirname} = require('path')\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\nconst readPackage = ({ path, packageJsonCache }) =>\n  packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path))\n  : readFile(path).then(json => {\n      const pkg = normalizePackageBin(JSON.parse(json))\n      packageJsonCache.set(path, pkg)\n      return pkg\n    })\n    .catch(er => null)\n\n// just normalize bundle deps and bin, that's all we care about here.\nconst normalized = Symbol('package data has been normalized')\nconst rpj = ({ path, packageJsonCache }) =>\n  readPackage({path, packageJsonCache})\n  .then(pkg => {\n    if (!pkg || pkg[normalized])\n      return pkg\n    if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n      pkg.bundleDependencies = pkg.bundledDependencies\n      delete pkg.bundledDependencies\n    }\n    const bd = pkg.bundleDependencies\n    if (bd === true) {\n      pkg.bundleDependencies = [\n        ...Object.keys(pkg.dependencies || {}),\n        ...Object.keys(pkg.optionalDependencies || {}),\n      ]\n    }\n    if (typeof bd === 'object' && !Array.isArray(bd)) {\n      pkg.bundleDependencies = Object.keys(bd)\n    }\n    pkg[normalized] = true\n    return pkg\n  })\n\n\nconst pkgContents = async ({\n  path,\n  depth,\n  currentDepth = 0,\n  pkg = null,\n  result = null,\n  packageJsonCache = null,\n}) => {\n  if (!result)\n    result = new Set()\n\n  if (!packageJsonCache)\n    packageJsonCache = new Map()\n\n  if (pkg === true) {\n    return rpj({ path: path + '/package.json', packageJsonCache })\n      .then(pkg => pkgContents({\n        path,\n        depth,\n        currentDepth,\n        pkg,\n        result,\n        packageJsonCache,\n      }))\n  }\n\n  if (pkg) {\n    // add all bins to result if they exist\n    if (pkg.bin) {\n      const dir = dirname(path)\n      const base = basename(path)\n      const scope = basename(dir)\n      const nm = /^@.+/.test(scope) ? dirname(dir) : dir\n\n      const binFiles = []\n      Object.keys(pkg.bin).forEach(b => {\n        const base = resolve(nm, '.bin', b)\n        binFiles.push(base, base + '.cmd', base + '.ps1')\n      })\n\n      const bins = await Promise.all(\n        binFiles.map(b => stat(b).then(() => b).catch((er) => null))\n      )\n      bins.filter(b => b).forEach(b => result.add(b))\n    }\n  }\n\n  if (currentDepth >= depth) {\n    result.add(path)\n    return result\n  }\n\n  // we'll need bundle list later, so get that now in parallel\n  const [dirEntries, bundleDeps] = await Promise.all([\n    readdir(path, { withFileTypes: true }),\n    currentDepth === 0 && pkg && pkg.bundleDependencies\n      ? bundled({ path, packageJsonCache }) : null,\n  ]).catch(() => [])\n\n  // not a thing, probably a missing folder\n  if (!dirEntries)\n    return result\n\n  // empty folder, just add the folder itself to the result\n  if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n    result.add(path)\n    return result\n  }\n\n  const recursePromises = []\n\n  // if we didn't get withFileTypes support, tack that on\n  if (typeof dirEntries[0] === 'string') {\n    // use a map so we can return a promise, but we mutate dirEntries in place\n    // this is much slower than getting the entries from the readdir call,\n    // but polyfills support for node versions before 10.10\n    await Promise.all(dirEntries.map(async (name, index) => {\n      const p = resolve(path, name)\n      const st = await lstat(p)\n      dirEntries[index] = Object.assign(st, {name})\n    }))\n  }\n\n  for (const entry of dirEntries) {\n    const p = resolve(path, entry.name)\n    if (entry.isDirectory() === false) {\n      result.add(p)\n      continue\n    }\n\n    if (currentDepth !== 0 || entry.name !== 'node_modules') {\n      if (currentDepth < depth - 1) {\n        recursePromises.push(pkgContents({\n          path: p,\n          packageJsonCache,\n          depth,\n          currentDepth: currentDepth + 1,\n          result,\n        }))\n      } else {\n        result.add(p)\n      }\n      continue\n    }\n  }\n\n  if (bundleDeps) {\n    // bundle deps are all folders\n    // we always recurse to get pkg bins, but if currentDepth is too high,\n    // it'll return early before walking their contents.\n    recursePromises.push(...bundleDeps.map(dep => {\n      const p = resolve(path, 'node_modules', dep)\n      return pkgContents({\n        path: p,\n        packageJsonCache,\n        pkg: true,\n        depth,\n        currentDepth: currentDepth + 1,\n        result,\n      })\n    }))\n  }\n\n  if (recursePromises.length)\n    await Promise.all(recursePromises)\n\n  return result\n}\n\nmodule.exports = ({path, depth = 1, packageJsonCache}) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache,\n}).then(results => [...results])\n\n\nif (require.main === module) {\n  const options = { path: null, depth: 1 }\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`\n\n  process.argv.slice(2).forEach(arg => {\n    let match\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) ||\n        (match = arg.match(/^-d([0-9]+|Infinity)/)))\n      options.depth = +match[1]\n    else if (arg === '-h' || arg === '--help') {\n      console.log(usage)\n      process.exit(0)\n    } else\n      options.path = arg\n  })\n  if (!options.path)  {\n    console.error('ERROR: no path provided')\n    console.error(usage)\n    process.exit(1)\n  }\n  const cwd = process.cwd()\n  module.exports(options)\n    .then(list => list.sort().forEach(p => console.log(relative(cwd, p))))\n    .catch(/* istanbul ignore next - pretty unusual */ er => {\n      console.error(er)\n      process.exit(1)\n    })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}