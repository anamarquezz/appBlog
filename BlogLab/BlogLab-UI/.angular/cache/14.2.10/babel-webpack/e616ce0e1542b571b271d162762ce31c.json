{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Minipass = require('minipass');\n\nconst MinipassSized = require('minipass-sized');\n\nconst Blob = require('./blob.js');\n\nconst {\n  BUFFER\n} = Blob;\n\nconst FetchError = require('./fetch-error.js'); // optional dependency on 'encoding'\n\n\nlet convert;\n\ntry {\n  convert = require('encoding').convert;\n} catch (e) {// defer error until textConverted is called\n}\n\nconst INTERNALS = Symbol('Body internals');\nconst CONSUME_BODY = Symbol('consumeBody');\n\nclass Body {\n  constructor(bodyArg, options = {}) {\n    const {\n      size = 0,\n      timeout = 0\n    } = options;\n    const body = bodyArg === undefined || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]' ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er : new FetchError(`Invalid response while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].body;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n\n  arrayBuffer() {\n    return this[CONSUME_BODY]().then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  }\n\n  blob() {\n    const ct = this.headers && this.headers.get('content-type') || '';\n    return this[CONSUME_BODY]().then(buf => Object.assign(new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  }\n\n  json() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const buf = yield _this[CONSUME_BODY]();\n\n      try {\n        return JSON.parse(buf.toString());\n      } catch (er) {\n        throw new FetchError(`invalid json response body at ${_this.url} reason: ${er.message}`, 'invalid-json');\n      }\n    })();\n  }\n\n  text() {\n    return this[CONSUME_BODY]().then(buf => buf.toString());\n  }\n\n  buffer() {\n    return this[CONSUME_BODY]();\n  }\n\n  textConverted() {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers));\n  }\n\n  [CONSUME_BODY]() {\n    if (this[INTERNALS].disturbed) {\n      return Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    }\n\n    this[INTERNALS].disturbed = true;\n\n    if (this[INTERNALS].error) {\n      return Promise.reject(this[INTERNALS].error);\n    } // body is null\n\n\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n\n    if (Buffer.isBuffer(this.body)) {\n      return Promise.resolve(this.body);\n    }\n\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body;\n    /* istanbul ignore if: should never happen */\n\n    if (!Minipass.isStream(upstream)) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n\n    const stream = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({\n      size: this.size\n    }) : new Minipass(); // allow timeout on slow response body, but only if the stream is still writable. this\n    // makes the timeout center on the socket stream from lib/index.js rather than the\n    // intermediary minipass stream we create to receive the data\n\n    const resTimeout = this.timeout && stream.writable ? setTimeout(() => {\n      stream.emit('error', new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n    }, this.timeout) : null; // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n\n    if (resTimeout && resTimeout.unref) {\n      resTimeout.unref();\n    } // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n\n\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er));\n        upstream.pipe(stream);\n      }\n\n      resolve();\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout);\n      return buf;\n    }).catch(er => {\n      clearTimeout(resTimeout); // request was aborted, reject with this Error\n\n      if (er.name === 'AbortError' || er.name === 'FetchError') {\n        throw er;\n      } else if (er.name === 'RangeError') {\n        throw new FetchError(`Could not create Buffer from response body for ${this.url}: ${er.message}`, 'system', er);\n      } else {\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n      }\n    });\n  }\n\n  static clone(instance) {\n    if (instance.bodyUsed) {\n      throw new Error('cannot clone body after it is used');\n    }\n\n    const body = instance.body; // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass();\n      const p1 = new Minipass();\n      const p2 = new Minipass();\n      tee.on('error', er => {\n        p1.emit('error', er);\n        p2.emit('error', er);\n      });\n      body.on('error', er => tee.emit('error', er));\n      tee.pipe(p1);\n      tee.pipe(p2);\n      body.pipe(tee); // set instance body to one fork, return the other\n\n      instance[INTERNALS].body = p1;\n      return p2;\n    } else {\n      return instance.body;\n    }\n  }\n\n  static extractContentType(body) {\n    return body === null || body === undefined ? null : typeof body === 'string' ? 'text/plain;charset=UTF-8' : isURLSearchParams(body) ? 'application/x-www-form-urlencoded;charset=UTF-8' : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === 'function' ? `multipart/form-data;boundary=${body.getBoundary()}` : Minipass.isStream(body) ? null : 'text/plain;charset=UTF-8';\n  }\n\n  static getTotalBytes(instance) {\n    const {\n      body\n    } = instance;\n    return body === null || body === undefined ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === 'function' && ( // detect form data input from form-data module\n    body._lengthRetrievers &&\n    /* istanbul ignore next */\n    body._lengthRetrievers.length === 0 || // 1.x\n    body.hasKnownLength && body.hasKnownLength()) // 2.x\n    ? body.getLengthSync() : null;\n  }\n\n  static writeToStream(dest, instance) {\n    const {\n      body\n    } = instance;\n\n    if (body === null || body === undefined) {\n      dest.end();\n    } else if (Buffer.isBuffer(body) || typeof body === 'string') {\n      dest.end(body);\n    } else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body;\n      stream.on('error', er => dest.emit('error', er)).pipe(dest);\n    }\n\n    return dest;\n  }\n\n}\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\n\nconst isURLSearchParams = obj => // Duck-typing as a necessary condition.\ntypeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function' ? false // Brand-checking and more duck-typing as optional condition.\n: obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n\nconst isBlob = obj => typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function') {\n    throw new Error('The package `encoding` must be installed to use the textConverted() function');\n  }\n\n  const ct = headers && headers.get('content-type');\n  let charset = 'utf-8';\n  let res; // header\n\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  } // no charset in content type, peek at response body for at most 1024 bytes\n\n\n  const str = buffer.slice(0, 1024).toString(); // html5\n\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  } // html4\n\n\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\n      if (res) {\n        res.pop();\n      } // drop last quote\n\n    }\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  } // xml\n\n\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  } // found charset\n\n\n  if (res) {\n    charset = res.pop(); // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  } // turn raw buffers into a single utf-8 buffer\n\n\n  return convert(buffer, 'UTF-8', charset).toString();\n};\n\nmodule.exports = Body;","map":{"version":3,"names":["Minipass","require","MinipassSized","Blob","BUFFER","FetchError","convert","e","INTERNALS","Symbol","CONSUME_BODY","Body","constructor","bodyArg","options","size","timeout","body","undefined","isURLSearchParams","Buffer","from","toString","isBlob","isBuffer","Object","prototype","call","ArrayBuffer","isView","buffer","byteOffset","byteLength","isStream","String","disturbed","error","on","er","name","url","message","bodyUsed","arrayBuffer","then","buf","slice","blob","ct","headers","get","assign","type","toLowerCase","json","JSON","parse","text","textConverted","convertBody","Promise","reject","TypeError","resolve","alloc","upstream","stream","resTimeout","writable","setTimeout","emit","unref","pipe","concat","clearTimeout","catch","clone","instance","Error","getBoundary","tee","p1","p2","extractContentType","getTotalBytes","length","getLengthSync","_lengthRetrievers","hasKnownLength","writeToStream","dest","end","defineProperties","enumerable","obj","append","delete","getAll","has","set","sort","test","toStringTag","charset","res","exec","str","pop","module","exports"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/minipass-fetch/lib/body.js"],"sourcesContent":["'use strict'\nconst Minipass = require('minipass')\nconst MinipassSized = require('minipass-sized')\n\nconst Blob = require('./blob.js')\nconst { BUFFER } = Blob\nconst FetchError = require('./fetch-error.js')\n\n// optional dependency on 'encoding'\nlet convert\ntry {\n  convert = require('encoding').convert\n} catch (e) {\n  // defer error until textConverted is called\n}\n\nconst INTERNALS = Symbol('Body internals')\nconst CONSUME_BODY = Symbol('consumeBody')\n\nclass Body {\n  constructor (bodyArg, options = {}) {\n    const { size = 0, timeout = 0 } = options\n    const body = bodyArg === undefined || bodyArg === null ? null\n      : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString())\n      : isBlob(bodyArg) ? bodyArg\n      : Buffer.isBuffer(bodyArg) ? bodyArg\n      : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]'\n        ? Buffer.from(bodyArg)\n        : ArrayBuffer.isView(bodyArg)\n          ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength)\n          : Minipass.isStream(bodyArg) ? bodyArg\n          : Buffer.from(String(bodyArg))\n\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null,\n    }\n\n    this.size = size\n    this.timeout = timeout\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er\n          : new FetchError(`Invalid response while trying to fetch ${\n            this.url}: ${er.message}`, 'system', er)\n        this[INTERNALS].error = error\n      })\n    }\n  }\n\n  get body () {\n    return this[INTERNALS].body\n  }\n\n  get bodyUsed () {\n    return this[INTERNALS].disturbed\n  }\n\n  arrayBuffer () {\n    return this[CONSUME_BODY]().then(buf =>\n      buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n  }\n\n  blob () {\n    const ct = this.headers && this.headers.get('content-type') || ''\n    return this[CONSUME_BODY]().then(buf => Object.assign(\n      new Blob([], { type: ct.toLowerCase() }),\n      { [BUFFER]: buf }\n    ))\n  }\n\n  async json () {\n    const buf = await this[CONSUME_BODY]()\n    try {\n      return JSON.parse(buf.toString())\n    } catch (er) {\n      throw new FetchError(\n        `invalid json response body at ${this.url} reason: ${er.message}`,\n        'invalid-json'\n      )\n    }\n  }\n\n  text () {\n    return this[CONSUME_BODY]().then(buf => buf.toString())\n  }\n\n  buffer () {\n    return this[CONSUME_BODY]()\n  }\n\n  textConverted () {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers))\n  }\n\n  [CONSUME_BODY] () {\n    if (this[INTERNALS].disturbed) {\n      return Promise.reject(new TypeError(`body used already for: ${\n        this.url}`))\n    }\n\n    this[INTERNALS].disturbed = true\n\n    if (this[INTERNALS].error) {\n      return Promise.reject(this[INTERNALS].error)\n    }\n\n    // body is null\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0))\n    }\n\n    if (Buffer.isBuffer(this.body)) {\n      return Promise.resolve(this.body)\n    }\n\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body\n\n    /* istanbul ignore if: should never happen */\n    if (!Minipass.isStream(upstream)) {\n      return Promise.resolve(Buffer.alloc(0))\n    }\n\n    const stream = this.size && upstream instanceof MinipassSized ? upstream\n      : !this.size && upstream instanceof Minipass &&\n        !(upstream instanceof MinipassSized) ? upstream\n      : this.size ? new MinipassSized({ size: this.size })\n      : new Minipass()\n\n    // allow timeout on slow response body, but only if the stream is still writable. this\n    // makes the timeout center on the socket stream from lib/index.js rather than the\n    // intermediary minipass stream we create to receive the data\n    const resTimeout = this.timeout && stream.writable ? setTimeout(() => {\n      stream.emit('error', new FetchError(\n        `Response timeout while trying to fetch ${\n          this.url} (over ${this.timeout}ms)`, 'body-timeout'))\n    }, this.timeout) : null\n\n    // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n    if (resTimeout && resTimeout.unref) {\n      resTimeout.unref()\n    }\n\n    // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er))\n        upstream.pipe(stream)\n      }\n      resolve()\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout)\n      return buf\n    }).catch(er => {\n      clearTimeout(resTimeout)\n      // request was aborted, reject with this Error\n      if (er.name === 'AbortError' || er.name === 'FetchError') {\n        throw er\n      } else if (er.name === 'RangeError') {\n        throw new FetchError(`Could not create Buffer from response body for ${\n          this.url}: ${er.message}`, 'system', er)\n      } else {\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${\n          this.url}: ${er.message}`, 'system', er)\n      }\n    })\n  }\n\n  static clone (instance) {\n    if (instance.bodyUsed) {\n      throw new Error('cannot clone body after it is used')\n    }\n\n    const body = instance.body\n\n    // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass()\n      const p1 = new Minipass()\n      const p2 = new Minipass()\n      tee.on('error', er => {\n        p1.emit('error', er)\n        p2.emit('error', er)\n      })\n      body.on('error', er => tee.emit('error', er))\n      tee.pipe(p1)\n      tee.pipe(p2)\n      body.pipe(tee)\n      // set instance body to one fork, return the other\n      instance[INTERNALS].body = p1\n      return p2\n    } else {\n      return instance.body\n    }\n  }\n\n  static extractContentType (body) {\n    return body === null || body === undefined ? null\n      : typeof body === 'string' ? 'text/plain;charset=UTF-8'\n      : isURLSearchParams(body)\n        ? 'application/x-www-form-urlencoded;charset=UTF-8'\n        : isBlob(body) ? body.type || null\n        : Buffer.isBuffer(body) ? null\n        : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null\n        : ArrayBuffer.isView(body) ? null\n        : typeof body.getBoundary === 'function'\n          ? `multipart/form-data;boundary=${body.getBoundary()}`\n          : Minipass.isStream(body) ? null\n          : 'text/plain;charset=UTF-8'\n  }\n\n  static getTotalBytes (instance) {\n    const { body } = instance\n    return (body === null || body === undefined) ? 0\n      : isBlob(body) ? body.size\n      : Buffer.isBuffer(body) ? body.length\n      : body && typeof body.getLengthSync === 'function' && (\n        // detect form data input from form-data module\n        body._lengthRetrievers &&\n        /* istanbul ignore next */ body._lengthRetrievers.length === 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) // 2.x\n        ? body.getLengthSync()\n        : null\n  }\n\n  static writeToStream (dest, instance) {\n    const { body } = instance\n\n    if (body === null || body === undefined) {\n      dest.end()\n    } else if (Buffer.isBuffer(body) || typeof body === 'string') {\n      dest.end(body)\n    } else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body\n      stream.on('error', er => dest.emit('error', er)).pipe(dest)\n    }\n\n    return dest\n  }\n}\n\nObject.defineProperties(Body.prototype, {\n  body: { enumerable: true },\n  bodyUsed: { enumerable: true },\n  arrayBuffer: { enumerable: true },\n  blob: { enumerable: true },\n  json: { enumerable: true },\n  text: { enumerable: true },\n})\n\nconst isURLSearchParams = obj =>\n  // Duck-typing as a necessary condition.\n  (typeof obj !== 'object' ||\n    typeof obj.append !== 'function' ||\n    typeof obj.delete !== 'function' ||\n    typeof obj.get !== 'function' ||\n    typeof obj.getAll !== 'function' ||\n    typeof obj.has !== 'function' ||\n    typeof obj.set !== 'function') ? false\n  // Brand-checking and more duck-typing as optional condition.\n  : obj.constructor.name === 'URLSearchParams' ||\n    Object.prototype.toString.call(obj) === '[object URLSearchParams]' ||\n    typeof obj.sort === 'function'\n\nconst isBlob = obj =>\n  typeof obj === 'object' &&\n  typeof obj.arrayBuffer === 'function' &&\n  typeof obj.type === 'string' &&\n  typeof obj.stream === 'function' &&\n  typeof obj.constructor === 'function' &&\n  typeof obj.constructor.name === 'string' &&\n  /^(Blob|File)$/.test(obj.constructor.name) &&\n  /^(Blob|File)$/.test(obj[Symbol.toStringTag])\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function') {\n    throw new Error('The package `encoding` must be installed to use the textConverted() function')\n  }\n\n  const ct = headers && headers.get('content-type')\n  let charset = 'utf-8'\n  let res\n\n  // header\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct)\n  }\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  const str = buffer.slice(0, 1024).toString()\n\n  // html5\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str)\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str)\n      if (res) {\n        res.pop()\n      } // drop last quote\n    }\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop())\n    }\n  }\n\n  // xml\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // found charset\n  if (res) {\n    charset = res.pop()\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030'\n    }\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(\n    buffer,\n    'UTF-8',\n    charset\n  ).toString()\n}\n\nmodule.exports = Body\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}