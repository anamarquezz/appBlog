{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJsonSchemaToOptions = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nfunction parseJsonSchemaToOptions(_x, _x2) {\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\n\nfunction _parseJsonSchemaToOptions() {\n  _parseJsonSchemaToOptions = _asyncToGenerator(function* (registry, schema, interactive = true) {\n    const options = [];\n\n    function visitor(current, pointer, parentSchema) {\n      if (!parentSchema) {\n        // Ignore root.\n        return;\n      } else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n        // Ignore subitems (objects or arrays).\n        return;\n      } else if (core_1.json.isJsonArray(current)) {\n        return;\n      }\n\n      if (pointer.indexOf('/not/') != -1) {\n        // We don't support anyOf/not.\n        throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n      }\n\n      const ptr = core_1.json.schema.parseJsonPointer(pointer);\n      const name = ptr[ptr.length - 1];\n\n      if (ptr[ptr.length - 2] != 'properties') {\n        // Skip any non-property items.\n        return;\n      }\n\n      const typeSet = core_1.json.schema.getTypesOfSchema(current);\n\n      if (typeSet.size == 0) {\n        throw new Error('Cannot find type of schema.');\n      } // We only support number, string or boolean (or array of those), so remove everything else.\n\n\n      const types = [...typeSet].filter(x => {\n        switch (x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n\n          case 'array':\n            // Only include arrays if they're boolean, string or number.\n            if (core_1.json.isJsonObject(current.items) && typeof current.items.type == 'string' && ['boolean', 'number', 'string'].includes(current.items.type)) {\n              return true;\n            }\n\n            return false;\n\n          default:\n            return false;\n        }\n      });\n\n      if (types.length == 0) {\n        // This means it's not usable on the command line. e.g. an Object.\n        return;\n      } // Only keep enum values we support (booleans, numbers and strings).\n\n\n      const enumValues = (core_1.json.isJsonArray(current.enum) && current.enum || []).filter(x => {\n        switch (typeof x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n\n          default:\n            return false;\n        }\n      });\n      let defaultValue = undefined;\n\n      if (current.default !== undefined) {\n        switch (types[0]) {\n          case 'string':\n            if (typeof current.default == 'string') {\n              defaultValue = current.default;\n            }\n\n            break;\n\n          case 'number':\n            if (typeof current.default == 'number') {\n              defaultValue = current.default;\n            }\n\n            break;\n\n          case 'boolean':\n            if (typeof current.default == 'boolean') {\n              defaultValue = current.default;\n            }\n\n            break;\n        }\n      }\n\n      const type = types[0];\n      const $default = current.$default;\n      const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n      const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n      let required = core_1.json.isJsonArray(schema.required) ? schema.required.includes(name) : false;\n\n      if (required && interactive && current['x-prompt']) {\n        required = false;\n      }\n\n      const alias = core_1.json.isJsonArray(current.aliases) ? [...current.aliases].map(x => '' + x) : current.alias ? ['' + current.alias] : [];\n      const format = typeof current.format == 'string' ? current.format : undefined;\n      const visible = current.visible === undefined || current.visible === true;\n      const hidden = !!current.hidden || !visible;\n      const xUserAnalytics = current['x-user-analytics'];\n      const userAnalytics = typeof xUserAnalytics == 'number' ? xUserAnalytics : undefined; // Deprecated is set only if it's true or a string.\n\n      const xDeprecated = current['x-deprecated'];\n      const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n      const option = {\n        name,\n        description: '' + (current.description === undefined ? '' : current.description),\n        type,\n        default: defaultValue,\n        choices: enumValues.length ? enumValues : undefined,\n        required,\n        alias,\n        format,\n        hidden,\n        userAnalytics,\n        deprecated,\n        positional\n      };\n      options.push(option);\n    }\n\n    const flattenedSchema = yield registry.flatten(schema).toPromise();\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor); // Sort by positional and name.\n\n    return options.sort((a, b) => {\n      if (a.positional) {\n        return b.positional ? a.positional - b.positional : a.name.localeCompare(b.name);\n      } else if (b.positional) {\n        return -1;\n      }\n\n      return a.name.localeCompare(b.name);\n    });\n  });\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\n\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseJsonSchemaToOptions","core_1","require","registry","schema","interactive","options","visitor","current","pointer","parentSchema","split","length","json","isJsonArray","indexOf","Error","ptr","parseJsonPointer","name","typeSet","getTypesOfSchema","size","types","filter","x","isJsonObject","items","type","includes","enumValues","enum","defaultValue","undefined","default","$default","$defaultIndex","positional","required","alias","aliases","map","format","visible","hidden","xUserAnalytics","userAnalytics","xDeprecated","deprecated","option","description","choices","push","flattenedSchema","flatten","toPromise","visitJsonSchema","sort","a","b","localeCompare"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@angular/cli/src/command-builder/utilities/json-schema.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJsonSchemaToOptions = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nasync function parseJsonSchemaToOptions(registry, schema, interactive = true) {\n    const options = [];\n    function visitor(current, pointer, parentSchema) {\n        if (!parentSchema) {\n            // Ignore root.\n            return;\n        }\n        else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n            // Ignore subitems (objects or arrays).\n            return;\n        }\n        else if (core_1.json.isJsonArray(current)) {\n            return;\n        }\n        if (pointer.indexOf('/not/') != -1) {\n            // We don't support anyOf/not.\n            throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n        }\n        const ptr = core_1.json.schema.parseJsonPointer(pointer);\n        const name = ptr[ptr.length - 1];\n        if (ptr[ptr.length - 2] != 'properties') {\n            // Skip any non-property items.\n            return;\n        }\n        const typeSet = core_1.json.schema.getTypesOfSchema(current);\n        if (typeSet.size == 0) {\n            throw new Error('Cannot find type of schema.');\n        }\n        // We only support number, string or boolean (or array of those), so remove everything else.\n        const types = [...typeSet].filter((x) => {\n            switch (x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                case 'array':\n                    // Only include arrays if they're boolean, string or number.\n                    if (core_1.json.isJsonObject(current.items) &&\n                        typeof current.items.type == 'string' &&\n                        ['boolean', 'number', 'string'].includes(current.items.type)) {\n                        return true;\n                    }\n                    return false;\n                default:\n                    return false;\n            }\n        });\n        if (types.length == 0) {\n            // This means it's not usable on the command line. e.g. an Object.\n            return;\n        }\n        // Only keep enum values we support (booleans, numbers and strings).\n        const enumValues = ((core_1.json.isJsonArray(current.enum) && current.enum) || []).filter((x) => {\n            switch (typeof x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                default:\n                    return false;\n            }\n        });\n        let defaultValue = undefined;\n        if (current.default !== undefined) {\n            switch (types[0]) {\n                case 'string':\n                    if (typeof current.default == 'string') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'number':\n                    if (typeof current.default == 'number') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'boolean':\n                    if (typeof current.default == 'boolean') {\n                        defaultValue = current.default;\n                    }\n                    break;\n            }\n        }\n        const type = types[0];\n        const $default = current.$default;\n        const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n        const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n        let required = core_1.json.isJsonArray(schema.required) ? schema.required.includes(name) : false;\n        if (required && interactive && current['x-prompt']) {\n            required = false;\n        }\n        const alias = core_1.json.isJsonArray(current.aliases)\n            ? [...current.aliases].map((x) => '' + x)\n            : current.alias\n                ? ['' + current.alias]\n                : [];\n        const format = typeof current.format == 'string' ? current.format : undefined;\n        const visible = current.visible === undefined || current.visible === true;\n        const hidden = !!current.hidden || !visible;\n        const xUserAnalytics = current['x-user-analytics'];\n        const userAnalytics = typeof xUserAnalytics == 'number' ? xUserAnalytics : undefined;\n        // Deprecated is set only if it's true or a string.\n        const xDeprecated = current['x-deprecated'];\n        const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n        const option = {\n            name,\n            description: '' + (current.description === undefined ? '' : current.description),\n            type,\n            default: defaultValue,\n            choices: enumValues.length ? enumValues : undefined,\n            required,\n            alias,\n            format,\n            hidden,\n            userAnalytics,\n            deprecated,\n            positional,\n        };\n        options.push(option);\n    }\n    const flattenedSchema = await registry.flatten(schema).toPromise();\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor);\n    // Sort by positional and name.\n    return options.sort((a, b) => {\n        if (a.positional) {\n            return b.positional ? a.positional - b.positional : a.name.localeCompare(b.name);\n        }\n        else if (b.positional) {\n            return -1;\n        }\n        return a.name.localeCompare(b.name);\n    });\n}\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}