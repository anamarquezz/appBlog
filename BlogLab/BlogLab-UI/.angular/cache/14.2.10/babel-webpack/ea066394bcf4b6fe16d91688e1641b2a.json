{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  HttpErrorAuthOTP\n} = require('./errors.js');\n\nconst checkResponse = require('./check-response.js');\n\nconst getAuth = require('./auth.js');\n\nconst fetch = require('make-fetch-happen');\n\nconst JSONStream = require('minipass-json-stream');\n\nconst npa = require('npm-package-arg');\n\nconst qs = require('querystring');\n\nconst url = require('url');\n\nconst zlib = require('minizlib');\n\nconst Minipass = require('minipass');\n\nconst defaultOpts = require('./default-opts.js'); // WhatWG URL throws if it's not fully resolved\n\n\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u);\n  } catch (_) {\n    return false;\n  }\n};\n\nmodule.exports = regFetch;\n\nfunction regFetch(uri,\n/* istanbul ignore next */\nopts_ = {}) {\n  const opts = { ...defaultOpts,\n    ...opts_\n  }; // if we did not get a fully qualified URI, then we look at the registry\n  // config or relevant scope to resolve it.\n\n  const uriValid = urlIsValid(uri);\n  let registry = opts.registry || defaultOpts.registry;\n\n  if (!uriValid) {\n    registry = opts.registry = opts.spec && pickRegistry(opts.spec, opts) || opts.registry || registry;\n    uri = `${registry.trim().replace(/\\/?$/g, '')}/${uri.trim().replace(/^\\//, '')}`; // asserts that this is now valid\n\n    new url.URL(uri);\n  }\n\n  const method = opts.method || 'GET'; // through that takes into account the scope, the prefix of `uri`, etc\n\n  const startTime = Date.now();\n  const auth = getAuth(uri, opts);\n  const headers = getHeaders(uri, auth, opts);\n  let body = opts.body;\n  const bodyIsStream = Minipass.isStream(body);\n  const bodyIsPromise = body && typeof body === 'object' && typeof body.then === 'function';\n\n  if (body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)) {\n    headers['content-type'] = headers['content-type'] || 'application/json';\n    body = JSON.stringify(body);\n  } else if (body && !headers['content-type']) {\n    headers['content-type'] = 'application/octet-stream';\n  }\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip';\n\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip();\n      body.on('error',\n      /* istanbul ignore next: unlikely and hard to test */\n      err => gz.emit('error', err));\n      body = body.pipe(gz);\n    } else if (!bodyIsPromise) {\n      body = new zlib.Gzip().end(body).concat();\n    }\n  }\n\n  const parsed = new url.URL(uri);\n\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query) : opts.query;\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined) {\n        parsed.searchParams.set(key, q[key]);\n      }\n    });\n    uri = url.format(parsed);\n  }\n\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false;\n    opts.preferOffline = false;\n    opts.preferOnline = true;\n  }\n\n  const doFetch = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (fetchBody) {\n      const p = fetch(uri, {\n        agent: opts.agent,\n        algorithms: opts.algorithms,\n        body: fetchBody,\n        cache: getCacheMode(opts),\n        cachePath: opts.cache,\n        ca: opts.ca,\n        cert: auth.cert || opts.cert,\n        headers,\n        integrity: opts.integrity,\n        key: auth.key || opts.key,\n        localAddress: opts.localAddress,\n        maxSockets: opts.maxSockets,\n        memoize: opts.memoize,\n        method: method,\n        noProxy: opts.noProxy,\n        proxy: opts.httpsProxy || opts.proxy,\n        retry: opts.retry ? opts.retry : {\n          retries: opts.fetchRetries,\n          factor: opts.fetchRetryFactor,\n          minTimeout: opts.fetchRetryMintimeout,\n          maxTimeout: opts.fetchRetryMaxtimeout\n        },\n        strictSSL: opts.strictSSL,\n        timeout: opts.timeout || 30 * 1000\n      }).then(res => checkResponse({\n        method,\n        uri,\n        res,\n        registry,\n        startTime,\n        auth,\n        opts\n      }));\n\n      if (typeof opts.otpPrompt === 'function') {\n        return p.catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (er) {\n            if (er instanceof HttpErrorAuthOTP) {\n              let otp; // if otp fails to complete, we fail with that failure\n\n              try {\n                otp = yield opts.otpPrompt();\n              } catch (_) {// ignore this error\n              } // if no otp provided, or otpPrompt errored, throw the original HTTP error\n\n\n              if (!otp) {\n                throw er;\n              }\n\n              return regFetch(uri, { ...opts,\n                otp\n              });\n            }\n\n            throw er;\n          });\n\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      } else {\n        return p;\n      }\n    });\n\n    return function doFetch(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return Promise.resolve(body).then(doFetch);\n}\n\nmodule.exports.json = fetchJSON;\n\nfunction fetchJSON(uri, opts) {\n  return regFetch(uri, opts).then(res => res.json());\n}\n\nmodule.exports.json.stream = fetchJSONStream;\n\nfunction fetchJSONStream(uri, jsonPath,\n/* istanbul ignore next */\nopts_ = {}) {\n  const opts = { ...defaultOpts,\n    ...opts_\n  };\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON);\n  regFetch(uri, opts).then(res => res.body.on('error',\n  /* istanbul ignore next: unlikely and difficult to test */\n  er => parser.emit('error', er)).pipe(parser)).catch(er => parser.emit('error', er));\n  return parser;\n}\n\nmodule.exports.pickRegistry = pickRegistry;\n\nfunction pickRegistry(spec, opts = {}) {\n  spec = npa(spec);\n  let registry = spec.scope && opts[spec.scope.replace(/^@?/, '@') + ':registry'];\n\n  if (!registry && opts.scope) {\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry'];\n  }\n\n  if (!registry) {\n    registry = opts.registry || defaultOpts.registry;\n  }\n\n  return registry;\n}\n\nfunction getCacheMode(opts) {\n  return opts.offline ? 'only-if-cached' : opts.preferOffline ? 'force-cache' : opts.preferOnline ? 'no-cache' : 'default';\n}\n\nfunction getHeaders(uri, auth, opts) {\n  const headers = Object.assign({\n    'user-agent': opts.userAgent\n  }, opts.headers || {});\n\n  if (opts.authType) {\n    headers['npm-auth-type'] = opts.authType;\n  }\n\n  if (opts.scope) {\n    headers['npm-scope'] = opts.scope;\n  }\n\n  if (opts.npmSession) {\n    headers['npm-session'] = opts.npmSession;\n  }\n\n  if (opts.npmCommand) {\n    headers['npm-command'] = opts.npmCommand;\n  } // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n\n\n  if (auth.token) {\n    headers.authorization = `Bearer ${auth.token}`;\n  } else if (auth.auth) {\n    headers.authorization = `Basic ${auth.auth}`;\n  }\n\n  if (opts.otp) {\n    headers['npm-otp'] = opts.otp;\n  }\n\n  return headers;\n}\n\nmodule.exports.cleanUrl = require('./clean-url.js');","map":{"version":3,"names":["HttpErrorAuthOTP","require","checkResponse","getAuth","fetch","JSONStream","npa","qs","url","zlib","Minipass","defaultOpts","urlIsValid","u","URL","_","module","exports","regFetch","uri","opts_","opts","uriValid","registry","spec","pickRegistry","trim","replace","method","startTime","Date","now","auth","headers","getHeaders","body","bodyIsStream","isStream","bodyIsPromise","then","Buffer","isBuffer","JSON","stringify","gzip","gz","Gzip","on","err","emit","pipe","end","concat","parsed","query","q","parse","Object","keys","forEach","key","undefined","searchParams","set","format","get","offline","preferOffline","preferOnline","doFetch","fetchBody","p","agent","algorithms","cache","getCacheMode","cachePath","ca","cert","integrity","localAddress","maxSockets","memoize","noProxy","proxy","httpsProxy","retry","retries","fetchRetries","factor","fetchRetryFactor","minTimeout","fetchRetryMintimeout","maxTimeout","fetchRetryMaxtimeout","strictSSL","timeout","res","otpPrompt","catch","er","otp","Promise","resolve","json","fetchJSON","stream","fetchJSONStream","jsonPath","parser","mapJSON","scope","assign","userAgent","authType","npmSession","npmCommand","token","authorization","cleanUrl"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/npm-registry-fetch/lib/index.js"],"sourcesContent":["'use strict'\n\nconst { HttpErrorAuthOTP } = require('./errors.js')\nconst checkResponse = require('./check-response.js')\nconst getAuth = require('./auth.js')\nconst fetch = require('make-fetch-happen')\nconst JSONStream = require('minipass-json-stream')\nconst npa = require('npm-package-arg')\nconst qs = require('querystring')\nconst url = require('url')\nconst zlib = require('minizlib')\nconst Minipass = require('minipass')\n\nconst defaultOpts = require('./default-opts.js')\n\n// WhatWG URL throws if it's not fully resolved\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u)\n  } catch (_) {\n    return false\n  }\n}\n\nmodule.exports = regFetch\nfunction regFetch (uri, /* istanbul ignore next */ opts_ = {}) {\n  const opts = {\n    ...defaultOpts,\n    ...opts_,\n  }\n\n  // if we did not get a fully qualified URI, then we look at the registry\n  // config or relevant scope to resolve it.\n  const uriValid = urlIsValid(uri)\n  let registry = opts.registry || defaultOpts.registry\n  if (!uriValid) {\n    registry = opts.registry = (\n      (opts.spec && pickRegistry(opts.spec, opts)) ||\n      opts.registry ||\n      registry\n    )\n    uri = `${\n      registry.trim().replace(/\\/?$/g, '')\n    }/${\n      uri.trim().replace(/^\\//, '')\n    }`\n    // asserts that this is now valid\n    new url.URL(uri)\n  }\n\n  const method = opts.method || 'GET'\n\n  // through that takes into account the scope, the prefix of `uri`, etc\n  const startTime = Date.now()\n  const auth = getAuth(uri, opts)\n  const headers = getHeaders(uri, auth, opts)\n  let body = opts.body\n  const bodyIsStream = Minipass.isStream(body)\n  const bodyIsPromise = body &&\n    typeof body === 'object' &&\n    typeof body.then === 'function'\n\n  if (\n    body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)\n  ) {\n    headers['content-type'] = headers['content-type'] || 'application/json'\n    body = JSON.stringify(body)\n  } else if (body && !headers['content-type']) {\n    headers['content-type'] = 'application/octet-stream'\n  }\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip'\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip()\n      body.on('error', /* istanbul ignore next: unlikely and hard to test */\n        err => gz.emit('error', err))\n      body = body.pipe(gz)\n    } else if (!bodyIsPromise) {\n      body = new zlib.Gzip().end(body).concat()\n    }\n  }\n\n  const parsed = new url.URL(uri)\n\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query)\n      : opts.query\n\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined) {\n        parsed.searchParams.set(key, q[key])\n      }\n    })\n    uri = url.format(parsed)\n  }\n\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false\n    opts.preferOffline = false\n    opts.preferOnline = true\n  }\n\n  const doFetch = async fetchBody => {\n    const p = fetch(uri, {\n      agent: opts.agent,\n      algorithms: opts.algorithms,\n      body: fetchBody,\n      cache: getCacheMode(opts),\n      cachePath: opts.cache,\n      ca: opts.ca,\n      cert: auth.cert || opts.cert,\n      headers,\n      integrity: opts.integrity,\n      key: auth.key || opts.key,\n      localAddress: opts.localAddress,\n      maxSockets: opts.maxSockets,\n      memoize: opts.memoize,\n      method: method,\n      noProxy: opts.noProxy,\n      proxy: opts.httpsProxy || opts.proxy,\n      retry: opts.retry ? opts.retry : {\n        retries: opts.fetchRetries,\n        factor: opts.fetchRetryFactor,\n        minTimeout: opts.fetchRetryMintimeout,\n        maxTimeout: opts.fetchRetryMaxtimeout,\n      },\n      strictSSL: opts.strictSSL,\n      timeout: opts.timeout || 30 * 1000,\n    }).then(res => checkResponse({\n      method,\n      uri,\n      res,\n      registry,\n      startTime,\n      auth,\n      opts,\n    }))\n\n    if (typeof opts.otpPrompt === 'function') {\n      return p.catch(async er => {\n        if (er instanceof HttpErrorAuthOTP) {\n          let otp\n          // if otp fails to complete, we fail with that failure\n          try {\n            otp = await opts.otpPrompt()\n          } catch (_) {\n            // ignore this error\n          }\n          // if no otp provided, or otpPrompt errored, throw the original HTTP error\n          if (!otp) {\n            throw er\n          }\n          return regFetch(uri, { ...opts, otp })\n        }\n        throw er\n      })\n    } else {\n      return p\n    }\n  }\n\n  return Promise.resolve(body).then(doFetch)\n}\n\nmodule.exports.json = fetchJSON\nfunction fetchJSON (uri, opts) {\n  return regFetch(uri, opts).then(res => res.json())\n}\n\nmodule.exports.json.stream = fetchJSONStream\nfunction fetchJSONStream (uri, jsonPath,\n  /* istanbul ignore next */ opts_ = {}) {\n  const opts = { ...defaultOpts, ...opts_ }\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON)\n  regFetch(uri, opts).then(res =>\n    res.body.on('error',\n      /* istanbul ignore next: unlikely and difficult to test */\n      er => parser.emit('error', er)).pipe(parser)\n  ).catch(er => parser.emit('error', er))\n  return parser\n}\n\nmodule.exports.pickRegistry = pickRegistry\nfunction pickRegistry (spec, opts = {}) {\n  spec = npa(spec)\n  let registry = spec.scope &&\n    opts[spec.scope.replace(/^@?/, '@') + ':registry']\n\n  if (!registry && opts.scope) {\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry']\n  }\n\n  if (!registry) {\n    registry = opts.registry || defaultOpts.registry\n  }\n\n  return registry\n}\n\nfunction getCacheMode (opts) {\n  return opts.offline ? 'only-if-cached'\n    : opts.preferOffline ? 'force-cache'\n    : opts.preferOnline ? 'no-cache'\n    : 'default'\n}\n\nfunction getHeaders (uri, auth, opts) {\n  const headers = Object.assign({\n    'user-agent': opts.userAgent,\n  }, opts.headers || {})\n\n  if (opts.authType) {\n    headers['npm-auth-type'] = opts.authType\n  }\n\n  if (opts.scope) {\n    headers['npm-scope'] = opts.scope\n  }\n\n  if (opts.npmSession) {\n    headers['npm-session'] = opts.npmSession\n  }\n\n  if (opts.npmCommand) {\n    headers['npm-command'] = opts.npmCommand\n  }\n\n  // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n  if (auth.token) {\n    headers.authorization = `Bearer ${auth.token}`\n  } else if (auth.auth) {\n    headers.authorization = `Basic ${auth.auth}`\n  }\n\n  if (opts.otp) {\n    headers['npm-otp'] = opts.otp\n  }\n\n  return headers\n}\n\nmodule.exports.cleanUrl = require('./clean-url.js')\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}