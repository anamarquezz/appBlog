{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  URL\n} = require('url');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst zlib = require('minizlib');\n\nconst Minipass = require('minipass');\n\nconst Body = require('./body.js');\n\nconst {\n  writeToStream,\n  getTotalBytes\n} = Body;\n\nconst Response = require('./response.js');\n\nconst Headers = require('./headers.js');\n\nconst {\n  createHeadersLenient\n} = Headers;\n\nconst Request = require('./request.js');\n\nconst {\n  getNodeRequestOptions\n} = Request;\n\nconst FetchError = require('./fetch-error.js');\n\nconst AbortError = require('./abort-error.js'); // XXX this should really be split up and unit-ized for easier testing\n// and better DRY implementation of data/http request aborting\n\n\nconst fetch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (url, opts) {\n    if (/^data:/.test(url)) {\n      const request = new Request(url, opts); // delay 1 promise tick so that the consumer can abort right away\n\n      return Promise.resolve().then(() => new Promise((resolve, reject) => {\n        let type, data;\n\n        try {\n          const {\n            pathname,\n            search\n          } = new URL(url);\n          const split = pathname.split(',');\n\n          if (split.length < 2) {\n            throw new Error('invalid data: URI');\n          }\n\n          const mime = split.shift();\n          const base64 = /;base64$/.test(mime);\n          type = base64 ? mime.slice(0, -1 * ';base64'.length) : mime;\n          const rawData = decodeURIComponent(split.join(',') + search);\n          data = base64 ? Buffer.from(rawData, 'base64') : Buffer.from(rawData);\n        } catch (er) {\n          return reject(new FetchError(`[${request.method}] ${request.url} invalid URL, ${er.message}`, 'system', er));\n        }\n\n        const {\n          signal\n        } = request;\n\n        if (signal && signal.aborted) {\n          return reject(new AbortError('The user aborted a request.'));\n        }\n\n        const headers = {\n          'Content-Length': data.length\n        };\n\n        if (type) {\n          headers['Content-Type'] = type;\n        }\n\n        return resolve(new Response(data, {\n          headers\n        }));\n      }));\n    }\n\n    return new Promise((resolve, reject) => {\n      // build request object\n      const request = new Request(url, opts);\n      let options;\n\n      try {\n        options = getNodeRequestOptions(request);\n      } catch (er) {\n        return reject(er);\n      }\n\n      const send = (options.protocol === 'https:' ? https : http).request;\n      const {\n        signal\n      } = request;\n      let response = null;\n\n      const abort = () => {\n        const error = new AbortError('The user aborted a request.');\n        reject(error);\n\n        if (Minipass.isStream(request.body) && typeof request.body.destroy === 'function') {\n          request.body.destroy(error);\n        }\n\n        if (response && response.body) {\n          response.body.emit('error', error);\n        }\n      };\n\n      if (signal && signal.aborted) {\n        return abort();\n      }\n\n      const abortAndFinalize = () => {\n        abort();\n        finalize();\n      };\n\n      const finalize = () => {\n        req.abort();\n\n        if (signal) {\n          signal.removeEventListener('abort', abortAndFinalize);\n        }\n\n        clearTimeout(reqTimeout);\n      }; // send request\n\n\n      const req = send(options);\n\n      if (signal) {\n        signal.addEventListener('abort', abortAndFinalize);\n      }\n\n      let reqTimeout = null;\n\n      if (request.timeout) {\n        req.once('socket', socket => {\n          reqTimeout = setTimeout(() => {\n            reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n            finalize();\n          }, request.timeout);\n        });\n      }\n\n      req.on('error', er => {\n        // if a 'response' event is emitted before the 'error' event, then by the\n        // time this handler is run it's too late to reject the Promise for the\n        // response. instead, we forward the error event to the response stream\n        // so that the error will surface to the user when they try to consume\n        // the body. this is done as a side effect of aborting the request except\n        // for in windows, where we must forward the event manually, otherwise\n        // there is no longer a ref'd socket attached to the request and the\n        // stream never ends so the event loop runs out of work and the process\n        // exits without warning.\n        // coverage skipped here due to the difficulty in testing\n        // istanbul ignore next\n        if (req.res) {\n          req.res.emit('error', er);\n        }\n\n        reject(new FetchError(`request to ${request.url} failed, reason: ${er.message}`, 'system', er));\n        finalize();\n      });\n      req.on('response', res => {\n        clearTimeout(reqTimeout);\n        const headers = createHeadersLenient(res.headers); // HTTP fetch step 5\n\n        if (fetch.isRedirect(res.statusCode)) {\n          // HTTP fetch step 5.2\n          const location = headers.get('Location'); // HTTP fetch step 5.3\n\n          const locationURL = location === null ? null : new URL(location, request.url).toString(); // HTTP fetch step 5.5\n\n          if (request.redirect === 'error') {\n            reject(new FetchError('uri requested responds with a redirect, ' + `redirect mode is set to error: ${request.url}`, 'no-redirect'));\n            finalize();\n            return;\n          } else if (request.redirect === 'manual') {\n            // node-fetch-specific step: make manual redirect a bit easier to\n            // use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL);\n              } catch (err) {\n                /* istanbul ignore next: nodejs server prevent invalid\n                   response headers, we can't test this through normal\n                   request */\n                reject(err);\n              }\n            }\n          } else if (request.redirect === 'follow' && locationURL !== null) {\n            // HTTP-redirect fetch step 5\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n              finalize();\n              return;\n            } // HTTP-redirect fetch step 9\n\n\n            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n              reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n              finalize();\n              return;\n            } // Update host due to redirection\n\n\n            request.headers.set('host', new URL(locationURL).host); // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n\n            const requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout\n            }; // if the redirect is to a new hostname, strip the authorization and cookie headers\n\n            const parsedOriginal = new URL(request.url);\n            const parsedRedirect = new URL(locationURL);\n\n            if (parsedOriginal.hostname !== parsedRedirect.hostname) {\n              requestOpts.headers.delete('authorization');\n              requestOpts.headers.delete('cookie');\n            } // HTTP-redirect fetch step 11\n\n\n            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n              requestOpts.method = 'GET';\n              requestOpts.body = undefined;\n              requestOpts.headers.delete('content-length');\n            } // HTTP-redirect fetch step 15\n\n\n            resolve(fetch(new Request(locationURL, requestOpts)));\n            finalize();\n            return;\n          }\n        } // end if(isRedirect)\n        // prepare response\n\n\n        res.once('end', () => signal && signal.removeEventListener('abort', abortAndFinalize));\n        const body = new Minipass(); // if an error occurs, either on the response stream itself, on one of the\n        // decoder streams, or a response length timeout from the Body class, we\n        // forward the error through to our internal body stream. If we see an\n        // error event on that, we call finalize to abort the request and ensure\n        // we don't leave a socket believing a request is in flight.\n        // this is difficult to test, so lacks specific coverage.\n\n        body.on('error', finalize); // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n\n        res.on('error',\n        /* istanbul ignore next */\n        er => body.emit('error', er));\n        res.on('data', chunk => body.write(chunk));\n        res.on('end', () => body.end());\n        const responseOptions = {\n          url: request.url,\n          status: res.statusCode,\n          statusText: res.statusMessage,\n          headers: headers,\n          size: request.size,\n          timeout: request.timeout,\n          counter: request.counter,\n          trailer: new Promise(resolveTrailer => res.on('end', () => resolveTrailer(createHeadersLenient(res.trailers))))\n        }; // HTTP-network fetch step 12.1.1.3\n\n        const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 12.1.1.4: handle content codings\n        // in following scenarios we ignore compression support\n        // 1. compression support is disabled\n        // 2. HEAD request\n        // 3. no Content-Encoding header\n        // 4. no content response (204)\n        // 5. content not modified response (304)\n\n        if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n          response = new Response(body, responseOptions);\n          resolve(response);\n          return;\n        } // Be less strict when decoding compressed responses, since sometimes\n        // servers send slightly invalid responses that are still accepted\n        // by common browsers.\n        // Always using Z_SYNC_FLUSH is what cURL does.\n\n\n        const zlibOptions = {\n          flush: zlib.constants.Z_SYNC_FLUSH,\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\n        }; // for gzip\n\n        if (codings === 'gzip' || codings === 'x-gzip') {\n          const unzip = new zlib.Gunzip(zlibOptions);\n          response = new Response( // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error',\n          /* istanbul ignore next */\n          er => unzip.emit('error', er)).pipe(unzip), responseOptions);\n          resolve(response);\n          return;\n        } // for deflate\n\n\n        if (codings === 'deflate' || codings === 'x-deflate') {\n          // handle the infamous raw deflate response from old servers\n          // a hack for old IIS and Apache servers\n          const raw = res.pipe(new Minipass());\n          raw.once('data', chunk => {\n            // see http://stackoverflow.com/questions/37519828\n            const decoder = (chunk[0] & 0x0F) === 0x08 ? new zlib.Inflate() : new zlib.InflateRaw(); // exceedingly rare that the stream would have an error,\n            // but just in case we proxy it to the stream in use.\n\n            body.on('error',\n            /* istanbul ignore next */\n            er => decoder.emit('error', er)).pipe(decoder);\n            response = new Response(decoder, responseOptions);\n            resolve(response);\n          });\n          return;\n        } // for br\n\n\n        if (codings === 'br') {\n          // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n          // istanbul ignore next\n          try {\n            var decoder = new zlib.BrotliDecompress();\n          } catch (err) {\n            reject(err);\n            finalize();\n            return;\n          } // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n\n\n          body.on('error',\n          /* istanbul ignore next */\n          er => decoder.emit('error', er)).pipe(decoder);\n          response = new Response(decoder, responseOptions);\n          resolve(response);\n          return;\n        } // otherwise, use response as-is\n\n\n        response = new Response(body, responseOptions);\n        resolve(response);\n      });\n      writeToStream(req, request);\n    });\n  });\n\n  return function fetch(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = fetch;\n\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n\nfetch.Headers = Headers;\nfetch.Request = Request;\nfetch.Response = Response;\nfetch.FetchError = FetchError;\nfetch.AbortError = AbortError;","map":{"version":3,"names":["URL","require","http","https","zlib","Minipass","Body","writeToStream","getTotalBytes","Response","Headers","createHeadersLenient","Request","getNodeRequestOptions","FetchError","AbortError","fetch","url","opts","test","request","Promise","resolve","then","reject","type","data","pathname","search","split","length","Error","mime","shift","base64","slice","rawData","decodeURIComponent","join","Buffer","from","er","method","message","signal","aborted","headers","options","send","protocol","response","abort","error","isStream","body","destroy","emit","abortAndFinalize","finalize","req","removeEventListener","clearTimeout","reqTimeout","addEventListener","timeout","once","socket","setTimeout","on","res","isRedirect","statusCode","location","get","locationURL","toString","redirect","set","err","counter","follow","host","requestOpts","agent","compress","parsedOriginal","parsedRedirect","hostname","delete","undefined","chunk","write","end","responseOptions","status","statusText","statusMessage","size","trailer","resolveTrailer","trailers","codings","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","unzip","Gunzip","pipe","raw","decoder","Inflate","InflateRaw","BrotliDecompress","module","exports","code"],"sources":["C:/sources/GitHub/appBlog/BlogLab/BlogLab-UI/node_modules/minipass-fetch/lib/index.js"],"sourcesContent":["'use strict'\nconst { URL } = require('url')\nconst http = require('http')\nconst https = require('https')\nconst zlib = require('minizlib')\nconst Minipass = require('minipass')\n\nconst Body = require('./body.js')\nconst { writeToStream, getTotalBytes } = Body\nconst Response = require('./response.js')\nconst Headers = require('./headers.js')\nconst { createHeadersLenient } = Headers\nconst Request = require('./request.js')\nconst { getNodeRequestOptions } = Request\nconst FetchError = require('./fetch-error.js')\nconst AbortError = require('./abort-error.js')\n\n// XXX this should really be split up and unit-ized for easier testing\n// and better DRY implementation of data/http request aborting\nconst fetch = async (url, opts) => {\n  if (/^data:/.test(url)) {\n    const request = new Request(url, opts)\n    // delay 1 promise tick so that the consumer can abort right away\n    return Promise.resolve().then(() => new Promise((resolve, reject) => {\n      let type, data\n      try {\n        const { pathname, search } = new URL(url)\n        const split = pathname.split(',')\n        if (split.length < 2) {\n          throw new Error('invalid data: URI')\n        }\n        const mime = split.shift()\n        const base64 = /;base64$/.test(mime)\n        type = base64 ? mime.slice(0, -1 * ';base64'.length) : mime\n        const rawData = decodeURIComponent(split.join(',') + search)\n        data = base64 ? Buffer.from(rawData, 'base64') : Buffer.from(rawData)\n      } catch (er) {\n        return reject(new FetchError(`[${request.method}] ${\n          request.url} invalid URL, ${er.message}`, 'system', er))\n      }\n\n      const { signal } = request\n      if (signal && signal.aborted) {\n        return reject(new AbortError('The user aborted a request.'))\n      }\n\n      const headers = { 'Content-Length': data.length }\n      if (type) {\n        headers['Content-Type'] = type\n      }\n      return resolve(new Response(data, { headers }))\n    }))\n  }\n\n  return new Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(url, opts)\n    let options\n    try {\n      options = getNodeRequestOptions(request)\n    } catch (er) {\n      return reject(er)\n    }\n\n    const send = (options.protocol === 'https:' ? https : http).request\n    const { signal } = request\n    let response = null\n    const abort = () => {\n      const error = new AbortError('The user aborted a request.')\n      reject(error)\n      if (Minipass.isStream(request.body) &&\n          typeof request.body.destroy === 'function') {\n        request.body.destroy(error)\n      }\n      if (response && response.body) {\n        response.body.emit('error', error)\n      }\n    }\n\n    if (signal && signal.aborted) {\n      return abort()\n    }\n\n    const abortAndFinalize = () => {\n      abort()\n      finalize()\n    }\n\n    const finalize = () => {\n      req.abort()\n      if (signal) {\n        signal.removeEventListener('abort', abortAndFinalize)\n      }\n      clearTimeout(reqTimeout)\n    }\n\n    // send request\n    const req = send(options)\n\n    if (signal) {\n      signal.addEventListener('abort', abortAndFinalize)\n    }\n\n    let reqTimeout = null\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          reject(new FetchError(`network timeout at: ${\n            request.url}`, 'request-timeout'))\n          finalize()\n        }, request.timeout)\n      })\n    }\n\n    req.on('error', er => {\n      // if a 'response' event is emitted before the 'error' event, then by the\n      // time this handler is run it's too late to reject the Promise for the\n      // response. instead, we forward the error event to the response stream\n      // so that the error will surface to the user when they try to consume\n      // the body. this is done as a side effect of aborting the request except\n      // for in windows, where we must forward the event manually, otherwise\n      // there is no longer a ref'd socket attached to the request and the\n      // stream never ends so the event loop runs out of work and the process\n      // exits without warning.\n      // coverage skipped here due to the difficulty in testing\n      // istanbul ignore next\n      if (req.res) {\n        req.res.emit('error', er)\n      }\n      reject(new FetchError(`request to ${request.url} failed, reason: ${\n        er.message}`, 'system', er))\n      finalize()\n    })\n\n    req.on('response', res => {\n      clearTimeout(reqTimeout)\n\n      const headers = createHeadersLenient(res.headers)\n\n      // HTTP fetch step 5\n      if (fetch.isRedirect(res.statusCode)) {\n        // HTTP fetch step 5.2\n        const location = headers.get('Location')\n\n        // HTTP fetch step 5.3\n        const locationURL = location === null ? null\n          : (new URL(location, request.url)).toString()\n\n        // HTTP fetch step 5.5\n        if (request.redirect === 'error') {\n          reject(new FetchError('uri requested responds with a redirect, ' +\n            `redirect mode is set to error: ${request.url}`, 'no-redirect'))\n          finalize()\n          return\n        } else if (request.redirect === 'manual') {\n          // node-fetch-specific step: make manual redirect a bit easier to\n          // use by setting the Location header value to the resolved URL.\n          if (locationURL !== null) {\n            // handle corrupted header\n            try {\n              headers.set('Location', locationURL)\n            } catch (err) {\n              /* istanbul ignore next: nodejs server prevent invalid\n                 response headers, we can't test this through normal\n                 request */\n              reject(err)\n            }\n          }\n        } else if (request.redirect === 'follow' && locationURL !== null) {\n          // HTTP-redirect fetch step 5\n          if (request.counter >= request.follow) {\n            reject(new FetchError(`maximum redirect reached at: ${\n              request.url}`, 'max-redirect'))\n            finalize()\n            return\n          }\n\n          // HTTP-redirect fetch step 9\n          if (res.statusCode !== 303 &&\n              request.body &&\n              getTotalBytes(request) === null) {\n            reject(new FetchError(\n              'Cannot follow redirect with body being a readable stream',\n              'unsupported-redirect'\n            ))\n            finalize()\n            return\n          }\n\n          // Update host due to redirection\n          request.headers.set('host', (new URL(locationURL)).host)\n\n          // HTTP-redirect fetch step 6 (counter increment)\n          // Create a new Request object.\n          const requestOpts = {\n            headers: new Headers(request.headers),\n            follow: request.follow,\n            counter: request.counter + 1,\n            agent: request.agent,\n            compress: request.compress,\n            method: request.method,\n            body: request.body,\n            signal: request.signal,\n            timeout: request.timeout,\n          }\n\n          // if the redirect is to a new hostname, strip the authorization and cookie headers\n          const parsedOriginal = new URL(request.url)\n          const parsedRedirect = new URL(locationURL)\n          if (parsedOriginal.hostname !== parsedRedirect.hostname) {\n            requestOpts.headers.delete('authorization')\n            requestOpts.headers.delete('cookie')\n          }\n\n          // HTTP-redirect fetch step 11\n          if (res.statusCode === 303 || (\n            (res.statusCode === 301 || res.statusCode === 302) &&\n              request.method === 'POST'\n          )) {\n            requestOpts.method = 'GET'\n            requestOpts.body = undefined\n            requestOpts.headers.delete('content-length')\n          }\n\n          // HTTP-redirect fetch step 15\n          resolve(fetch(new Request(locationURL, requestOpts)))\n          finalize()\n          return\n        }\n      } // end if(isRedirect)\n\n      // prepare response\n      res.once('end', () =>\n        signal && signal.removeEventListener('abort', abortAndFinalize))\n\n      const body = new Minipass()\n      // if an error occurs, either on the response stream itself, on one of the\n      // decoder streams, or a response length timeout from the Body class, we\n      // forward the error through to our internal body stream. If we see an\n      // error event on that, we call finalize to abort the request and ensure\n      // we don't leave a socket believing a request is in flight.\n      // this is difficult to test, so lacks specific coverage.\n      body.on('error', finalize)\n      // exceedingly rare that the stream would have an error,\n      // but just in case we proxy it to the stream in use.\n      res.on('error', /* istanbul ignore next */ er => body.emit('error', er))\n      res.on('data', (chunk) => body.write(chunk))\n      res.on('end', () => body.end())\n\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout,\n        counter: request.counter,\n        trailer: new Promise(resolveTrailer =>\n          res.on('end', () => resolveTrailer(createHeadersLenient(res.trailers)))),\n      }\n\n      // HTTP-network fetch step 12.1.1.3\n      const codings = headers.get('Content-Encoding')\n\n      // HTTP-network fetch step 12.1.1.4: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress ||\n          request.method === 'HEAD' ||\n          codings === null ||\n          res.statusCode === 204 ||\n          res.statusCode === 304) {\n        response = new Response(body, responseOptions)\n        resolve(response)\n        return\n      }\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib.constants.Z_SYNC_FLUSH,\n        finishFlush: zlib.constants.Z_SYNC_FLUSH,\n      }\n\n      // for gzip\n      if (codings === 'gzip' || codings === 'x-gzip') {\n        const unzip = new zlib.Gunzip(zlibOptions)\n        response = new Response(\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => unzip.emit('error', er)).pipe(unzip),\n          responseOptions\n        )\n        resolve(response)\n        return\n      }\n\n      // for deflate\n      if (codings === 'deflate' || codings === 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new Minipass())\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          const decoder = (chunk[0] & 0x0F) === 0x08\n            ? new zlib.Inflate()\n            : new zlib.InflateRaw()\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n          response = new Response(decoder, responseOptions)\n          resolve(response)\n        })\n        return\n      }\n\n      // for br\n      if (codings === 'br') {\n        // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n        // istanbul ignore next\n        try {\n          var decoder = new zlib.BrotliDecompress()\n        } catch (err) {\n          reject(err)\n          finalize()\n          return\n        }\n        // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n        body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n        response = new Response(decoder, responseOptions)\n        resolve(response)\n        return\n      }\n\n      // otherwise, use response as-is\n      response = new Response(body, responseOptions)\n      resolve(response)\n    })\n\n    writeToStream(req, request)\n  })\n}\n\nmodule.exports = fetch\n\nfetch.isRedirect = code =>\n  code === 301 ||\n  code === 302 ||\n  code === 303 ||\n  code === 307 ||\n  code === 308\n\nfetch.Headers = Headers\nfetch.Request = Request\nfetch.Response = Response\nfetch.FetchError = FetchError\nfetch.AbortError = AbortError\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}